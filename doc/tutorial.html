<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Rust 언어 튜토리얼</title>
  <link rel="stylesheet" href="rust.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Rust 언어 튜토리얼</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#머리말"><span class="toc-section-number">1</span> 머리말</a><ul>
<li><a href="#scope"><span class="toc-section-number">1.1</span> Scope</a></li>
<li><a href="#conventions"><span class="toc-section-number">1.2</span> Conventions</a></li>
</ul></li>
<li><a href="#getting-started"><span class="toc-section-number">2</span> Getting started</a><ul>
<li><a href="#compiling-your-first-program"><span class="toc-section-number">2.1</span> Compiling your first program</a></li>
<li><a href="#using-the-rust-tool"><span class="toc-section-number">2.2</span> Using the rust tool</a></li>
<li><a href="#editing-rust-code"><span class="toc-section-number">2.3</span> Editing Rust code</a></li>
</ul></li>
<li><a href="#syntax-basics"><span class="toc-section-number">3</span> Syntax basics</a><ul>
<li><a href="#expressions-and-semicolons"><span class="toc-section-number">3.1</span> Expressions and semicolons</a></li>
<li><a href="#primitive-types-and-literals"><span class="toc-section-number">3.2</span> Primitive types and literals</a></li>
<li><a href="#operators"><span class="toc-section-number">3.3</span> Operators</a></li>
<li><a href="#syntax-extensions"><span class="toc-section-number">3.4</span> Syntax extensions</a></li>
</ul></li>
<li><a href="#control-structures"><span class="toc-section-number">4</span> Control structures</a><ul>
<li><a href="#conditionals"><span class="toc-section-number">4.1</span> Conditionals</a></li>
<li><a href="#pattern-matching"><span class="toc-section-number">4.2</span> Pattern matching</a></li>
<li><a href="#loops"><span class="toc-section-number">4.3</span> Loops</a></li>
</ul></li>
<li><a href="#data-structures"><span class="toc-section-number">5</span> Data structures</a><ul>
<li><a href="#structs"><span class="toc-section-number">5.1</span> Structs</a></li>
<li><a href="#enums"><span class="toc-section-number">5.2</span> Enums</a></li>
<li><a href="#tuples"><span class="toc-section-number">5.3</span> Tuples</a></li>
<li><a href="#tuple-structs"><span class="toc-section-number">5.4</span> Tuple structs</a></li>
</ul></li>
<li><a href="#functions"><span class="toc-section-number">6</span> Functions</a></li>
<li><a href="#destructors"><span class="toc-section-number">7</span> Destructors</a></li>
<li><a href="#ownership"><span class="toc-section-number">8</span> Ownership</a></li>
<li><a href="#boxes"><span class="toc-section-number">9</span> Boxes</a><ul>
<li><a href="#owned-boxes"><span class="toc-section-number">9.1</span> Owned boxes</a></li>
<li><a href="#managed-boxes"><span class="toc-section-number">9.2</span> Managed boxes</a></li>
</ul></li>
<li><a href="#move-semantics"><span class="toc-section-number">10</span> Move semantics</a></li>
<li><a href="#borrowed-pointers"><span class="toc-section-number">11</span> Borrowed pointers</a><ul>
<li><a href="#freezing"><span class="toc-section-number">11.1</span> Freezing</a></li>
</ul></li>
<li><a href="#dereferencing-pointers"><span class="toc-section-number">12</span> Dereferencing pointers</a></li>
<li><a href="#vectors-and-strings"><span class="toc-section-number">13</span> Vectors and strings</a></li>
<li><a href="#closures"><span class="toc-section-number">14</span> Closures</a><ul>
<li><a href="#managed-closures"><span class="toc-section-number">14.1</span> Managed closures</a></li>
<li><a href="#owned-closures"><span class="toc-section-number">14.2</span> Owned closures</a></li>
<li><a href="#closure-compatibility"><span class="toc-section-number">14.3</span> Closure compatibility</a></li>
<li><a href="#do-syntax"><span class="toc-section-number">14.4</span> Do syntax</a></li>
<li><a href="#for-loops"><span class="toc-section-number">14.5</span> For loops</a></li>
</ul></li>
<li><a href="#methods"><span class="toc-section-number">15</span> Methods</a></li>
<li><a href="#generics"><span class="toc-section-number">16</span> Generics</a><ul>
<li><a href="#traits"><span class="toc-section-number">16.1</span> Traits</a></li>
<li><a href="#declaring-and-implementing-traits"><span class="toc-section-number">16.2</span> Declaring and implementing traits</a></li>
<li><a href="#bounded-type-parameters-and-static-method-dispatch"><span class="toc-section-number">16.3</span> Bounded type parameters and static method dispatch</a></li>
<li><a href="#trait-objects-and-dynamic-method-dispatch"><span class="toc-section-number">16.4</span> Trait objects and dynamic method dispatch</a></li>
<li><a href="#trait-inheritance"><span class="toc-section-number">16.5</span> Trait inheritance</a></li>
</ul></li>
<li><a href="#modules-and-crates"><span class="toc-section-number">17</span> Modules and crates</a><ul>
<li><a href="#crates"><span class="toc-section-number">17.1</span> Crates</a></li>
<li><a href="#using-other-crates"><span class="toc-section-number">17.2</span> Using other crates</a></li>
<li><a href="#a-minimal-example"><span class="toc-section-number">17.3</span> A minimal example</a></li>
<li><a href="#the-core-library"><span class="toc-section-number">17.4</span> The core library</a><ul>
<li><a href="#core-injection-and-the-rust-prelude"><span class="toc-section-number">17.4.1</span> Core injection and the Rust prelude</a></li>
</ul></li>
</ul></li>
<li><a href="#what-next"><span class="toc-section-number">18</span> What next?</a></li>
</ul>
</div>
<h1 id="머리말"><a href="#TOC"><span class="header-section-number">1</span> 머리말</a></h1>
<p>Rust는 타입 안전성, 메모리 안전성, 동시성 그리고 성능에 초점을 맞춘 프로그래밍 언어이다. 몇 가지로 분류되는 일반적인 에러들로부터 자유로운 대규모, 고성능 소프트웨어를 작성하도록 계획되었다. Rust는 능률적인 데이터 구조를 장려하는 고수준의 메모리 모델과 세그멘테이션 오류를 일으키는 무효한 메모리 접근을 예방하는 안전한 동시성 패턴을 가지고 있다. 컴파일 시간에 타입이 정해진다.</p>
<p>As a multi-paradigm language, Rust supports writing code in procedural, functional and object-oriented styles. Some of its pleasant high-level features include:</p>
<ul>
<li><strong>Type inference.</strong> Type annotations on local variable declarations are optional.</li>
<li><strong>Safe task-based concurrency.</strong> Rust's lightweight tasks do not share memory, instead communicating through messages.</li>
<li><strong>Higher-order functions.</strong> Efficient and flexible closures provide iteration and other control structures</li>
<li><strong>Pattern matching and algebraic data types.</strong> Pattern matching on Rust's enumeration types (a more powerful version of C's enums, similar to algebraic data types in functional languages) is a compact and expressive way to encode program logic.</li>
<li><strong>Polymorphism.</strong> Rust has type-parametric functions and types, type classes and OO-style interfaces.</li>
</ul>
<h2 id="scope"><a href="#TOC"><span class="header-section-number">1.1</span> Scope</a></h2>
<p>This is an introductory tutorial for the Rust programming language. It covers the fundamentals of the language, including the syntax, the type system and memory model, generics, and modules. <a href="#what-next">Additional tutorials</a> cover specific language features in greater depth.</p>
<p>This tutorial assumes that the reader is already familiar with one or more languages in the C family. Understanding of pointers and general memory management techniques will help.</p>
<h2 id="conventions"><a href="#TOC"><span class="header-section-number">1.2</span> Conventions</a></h2>
<p>Throughout the tutorial, language keywords and identifiers defined in example code are displayed in <code>code font</code>.</p>
<p>Code snippets are indented, and also shown in a monospaced font. Not all snippets constitute whole programs. For brevity, we'll often show fragments of programs that don't compile on their own. To try them out, you might have to wrap them in <code>fn main() { ... }</code>, and make sure they don't contain references to names that aren't actually defined.</p>
<blockquote>
<p><strong><em>Warning:</em></strong> Rust is a language under ongoing development. Notes about potential changes to the language, implementation deficiencies, and other caveats appear offset in blockquotes.</p>
</blockquote>
<h1 id="getting-started"><a href="#TOC"><span class="header-section-number">2</span> Getting started</a></h1>
<p>The Rust compiler currently must be built from a <a href="http://static.rust-lang.org/dist/rust-0.6.tar.gz">tarball</a>, unless you are on Windows, in which case using the <a href="http://static.rust-lang.org/dist/rust-0.6-install.exe">installer</a> is recommended.</p>
<p>Since the Rust compiler is written in Rust, it must be built by a precompiled &quot;snapshot&quot; version of itself (made in an earlier state of development). As such, source builds require a connection to the Internet, to fetch snapshots, and an OS that can execute the available snapshot binaries.</p>
<p>Snapshot binaries are currently built and tested on several platforms:</p>
<ul>
<li>Windows (7, Server 2008 R2), x86 only</li>
<li>Linux (various distributions), x86 and x86-64</li>
<li>OSX 10.6 (&quot;Snow Leopard&quot;) or greater, x86 and x86-64</li>
</ul>
<p>You may find that other platforms work, but these are our &quot;tier 1&quot; supported build environments that are most likely to work.</p>
<blockquote>
<p><strong><em>Note:</em></strong> Windows users should read the detailed &quot;<a href="https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust">getting started</a>&quot; notes on the wiki. Even when using the binary installer, the Windows build requires a MinGW installation, the precise details of which are not discussed here. Finally, <code>rustc</code> may need to be <a href="https://github.com/mozilla/rust/issues/3319">referred to as <code>rustc.exe</code></a>. It's a bummer, we know.</p>
</blockquote>
<p>To build from source you will also need the following prerequisite packages:</p>
<ul>
<li>g++ 4.4 or clang++ 3.x</li>
<li>python 2.6 or later (but not 3.x)</li>
<li>perl 5.0 or later</li>
<li>gnu make 3.81 or later</li>
<li>curl</li>
</ul>
<p>If you've fulfilled those prerequisites, something along these lines should work.</p>
<pre class="notrust"><code>$ curl -O http://static.rust-lang.org/dist/rust-0.6.tar.gz
$ tar -xzf rust-0.6.tar.gz
$ cd rust-0.6
$ ./configure
$ make &amp;&amp; make install</code></pre>
<p>You may need to use <code>sudo make install</code> if you do not normally have permission to modify the destination directory. The install locations can be adjusted by passing a <code>--prefix</code> argument to <code>configure</code>. Various other options are also supported: pass <code>--help</code> for more information on them.</p>
<p>When complete, <code>make install</code> will place several programs into <code>/usr/local/bin</code>: <code>rustc</code>, the Rust compiler; <code>rustdoc</code>, the API-documentation tool; <code>rustpkg</code>, the Rust package manager; <code>rusti</code>, the Rust REPL; and <code>rust</code>, a tool which acts both as a unified interface for them, and for a few common command line scenarios.</p>
<h2 id="compiling-your-first-program"><a href="#TOC"><span class="header-section-number">2.1</span> Compiling your first program</a></h2>
<p>Rust program files are, by convention, given the extension <code>.rs</code>. Say we have a file <code>hello.rs</code> containing this program:</p>
<pre><code>fn main() {
    io::println(&quot;hello?&quot;);
}</code></pre>
<p>If the Rust compiler was installed successfully, running <code>rustc hello.rs</code> will produce an executable called <code>hello</code> (or <code>hello.exe</code> on Windows) which, upon running, will likely do exactly what you expect.</p>
<p>The Rust compiler tries to provide useful information when it encounters an error. If you introduce an error into the program (for example, by changing <code>io::println</code> to some nonexistent function), and then compile it, you'll see an error message like this:</p>
<pre class="notrust"><code>hello.rs:2:4: 2:16 error: unresolved name: io::print_with_unicorns
hello.rs:2     io::print_with_unicorns(&quot;hello?&quot;);
               ^~~~~~~~~~~~~~~~~~~~~~~</code></pre>
<p>In its simplest form, a Rust program is a <code>.rs</code> file with some types and functions defined in it. If it has a <code>main</code> function, it can be compiled to an executable. Rust does not allow code that's not a declaration to appear at the top level of the file: all statements must live inside a function. Rust programs can also be compiled as libraries, and included in other programs.</p>
<h2 id="using-the-rust-tool"><a href="#TOC"><span class="header-section-number">2.2</span> Using the rust tool</a></h2>
<p>While using <code>rustc</code> directly to generate your executables, and then running them manually is a perfectly valid way to test your code, for smaller projects, prototypes, or if you're a beginner, it might be more convenient to use the <code>rust</code> tool.</p>
<p>The <code>rust</code> tool provides central access to the other rust tools, as well as handy shortcuts for directly running source files. For example, if you have a file <code>foo.rs</code> in your current directory, <code>rust run foo.rs</code> would attempt to compile it and, if successful, directly run the resulting binary.</p>
<p>To get a list of all available commands, simply call <code>rust</code> without any argument.</p>
<h2 id="editing-rust-code"><a href="#TOC"><span class="header-section-number">2.3</span> Editing Rust code</a></h2>
<p>There are vim highlighting and indentation scripts in the Rust source distribution under <code>src/etc/vim/</code>. There is an emacs mode under <code>src/etc/emacs/</code> called <code>rust-mode</code>, but do read the instructions included in that directory. In particular, if you are running emacs 24, then using emacs's internal package manager to install <code>rust-mode</code> is the easiest way to keep it up to date. There is also a package for Sublime Text 2, available both <a href="http://github.com/dbp/sublime-rust">standalone</a> and through <a href="http://wbond.net/sublime_packages/package_control">Sublime Package Control</a>, and support for Kate under <code>src/etc/kate</code>.</p>
<p>There is ctags support via <code>src/etc/ctags.rust</code>, but many other tools and editors are not yet supported. If you end up writing a Rust mode for your favorite editor, let us know so that we can link to it.</p>
<h1 id="syntax-basics"><a href="#TOC"><span class="header-section-number">3</span> Syntax basics</a></h1>
<p>Assuming you've programmed in any C-family language (C++, Java, JavaScript, C#, or PHP), Rust will feel familiar. Code is arranged in blocks delineated by curly braces; there are control structures for branching and looping, like the familiar <code>if</code> and <code>while</code>; function calls are written <code>myfunc(arg1, arg2)</code>; operators are written the same and mostly have the same precedence as in C; comments are again like C; module names are separated with double-colon (<code>::</code>) as with C++.</p>
<p>The main surface difference to be aware of is that the condition at the head of control structures like <code>if</code> and <code>while</code> does not require parentheses, while their bodies <em>must</em> be wrapped in braces. Single-statement, unbraced bodies are not allowed.</p>
<pre><code># mod universe { pub fn recalibrate() -&gt; bool { true } }
fn main() {
    /* A simple loop */
    loop {
        // A tricky calculation
        if universe::recalibrate() {
            return;
        }
    }
}</code></pre>
<p>The <code>let</code> keyword introduces a local variable. Variables are immutable by default. To introduce a local variable that you can re-assign later, use <code>let mut</code> instead.</p>
<pre><code>let hi = &quot;hi&quot;;
let mut count = 0;

while count &lt; 10 {
    io::println(fmt!(&quot;count: %?&quot;, count));
    count += 1;
}</code></pre>
<p>Although Rust can almost always infer the types of local variables, you can specify a variable's type by following it with a colon, then the type name. Static items, on the other hand, always require a type annotation.</p>
<pre><code>static monster_factor: float = 57.8;
let monster_size = monster_factor * 10.0;
let monster_size: int = 50;</code></pre>
<p>Local variables may shadow earlier declarations, as in the previous example: <code>monster_size</code> was first declared as a <code>float</code>, and then a second <code>monster_size</code> was declared as an <code>int</code>. If you were to actually compile this example, though, the compiler would determine that the first <code>monster_size</code> is unused and issue a warning (because this situation is likely to indicate a programmer error). For occasions where unused variables are intentional, their names may be prefixed with an underscore to silence the warning, like <code>let _monster_size = 50;</code>.</p>
<p>Rust identifiers start with an alphabetic character or an underscore, and after that may contain any sequence of alphabetic characters, numbers, or underscores. The preferred style is to write function, variable, and module names with lowercase letters, using underscores where they help readability, while writing types in camel case.</p>
<pre><code>let my_variable = 100;
type MyType = int;     // primitive types are _not_ camel case</code></pre>
<h2 id="expressions-and-semicolons"><a href="#TOC"><span class="header-section-number">3.1</span> Expressions and semicolons</a></h2>
<p>Though it isn't apparent in all code, there is a fundamental difference between Rust's syntax and predecessors like C. Many constructs that are statements in C are expressions in Rust, allowing code to be more concise. For example, you might write a piece of code like this:</p>
<pre><code># let item = &quot;salad&quot;;
let price;
if item == &quot;salad&quot; {
    price = 3.50;
} else if item == &quot;muffin&quot; {
    price = 2.25;
} else {
    price = 2.00;
}</code></pre>
<p>But, in Rust, you don't have to repeat the name <code>price</code>:</p>
<pre><code># let item = &quot;salad&quot;;
let price =
    if item == &quot;salad&quot; {
        3.50
    } else if item == &quot;muffin&quot; {
        2.25
    } else {
        2.00
    };</code></pre>
<p>Both pieces of code are exactly equivalent: they assign a value to <code>price</code> depending on the condition that holds. Note that there are no semicolons in the blocks of the second snippet. This is important: the lack of a semicolon after the last statement in a braced block gives the whole block the value of that last expression.</p>
<p>Put another way, the semicolon in Rust <em>ignores the value of an expression</em>. Thus, if the branches of the <code>if</code> had looked like <code>{ 4; }</code>, the above example would simply assign <code>()</code> (nil or void) to <code>price</code>. But without the semicolon, each branch has a different value, and <code>price</code> gets the value of the branch that was taken.</p>
<p>In short, everything that's not a declaration (declarations are <code>let</code> for variables; <code>fn</code> for functions; and any top-level named items such as <a href="#traits">traits</a>, <a href="#enums">enum types</a>, and <a href="#constants">constants</a>) is an expression, including function bodies.</p>
<pre><code>fn is_four(x: int) -&gt; bool {
   // No need for a return statement. The result of the expression
   // is used as the return value.
   x == 4
}</code></pre>
<h2 id="primitive-types-and-literals"><a href="#TOC"><span class="header-section-number">3.2</span> Primitive types and literals</a></h2>
<p>There are general signed and unsigned integer types, <code>int</code> and <code>uint</code>, as well as 8-, 16-, 32-, and 64-bit variants, <code>i8</code>, <code>u16</code>, etc. Integers can be written in decimal (<code>144</code>), hexadecimal (<code>0x90</code>), or binary (<code>0b10010000</code>) base. Each integral type has a corresponding literal suffix that can be used to indicate the type of a literal: <code>i</code> for <code>int</code>, <code>u</code> for <code>uint</code>, <code>i8</code> for the <code>i8</code> type.</p>
<p>In the absence of an integer literal suffix, Rust will infer the integer type based on type annotations and function signatures in the surrounding program. In the absence of any type information at all, Rust will assume that an unsuffixed integer literal has type <code>int</code>.</p>
<pre><code>let a = 1;       // a is an int
let b = 10i;     // b is an int, due to the &#39;i&#39; suffix
let c = 100u;    // c is a uint
let d = 1000i32; // d is an i32</code></pre>
<p>There are three floating-point types: <code>float</code>, <code>f32</code>, and <code>f64</code>. Floating-point numbers are written <code>0.0</code>, <code>1e6</code>, or <code>2.1e-4</code>. Like integers, floating-point literals are inferred to the correct type. Suffixes <code>f</code>, <code>f32</code>, and <code>f64</code> can be used to create literals of a specific type.</p>
<p>The keywords <code>true</code> and <code>false</code> produce literals of type <code>bool</code>.</p>
<p>Characters, the <code>char</code> type, are four-byte Unicode codepoints, whose literals are written between single quotes, as in <code>'x'</code>. Just like C, Rust understands a number of character escapes, using the backslash character, such as <code>\n</code>, <code>\r</code>, and <code>\t</code>. String literals, written between double quotes, allow the same escape sequences. More on strings <a href="#vectors-and-strings">later</a>.</p>
<p>The nil type, written <code>()</code>, has a single value, also written <code>()</code>.</p>
<h2 id="operators"><a href="#TOC"><span class="header-section-number">3.3</span> Operators</a></h2>
<p>Rust's set of operators contains very few surprises. Arithmetic is done with <code>*</code>, <code>/</code>, <code>%</code>, <code>+</code>, and <code>-</code> (multiply, quotient, remainder, add, and subtract). <code>-</code> is also a unary prefix operator that negates numbers. As in C, the bitwise operators <code>&gt;&gt;</code>, <code>&lt;&lt;</code>, <code>&amp;</code>, <code>|</code>, and <code>^</code> are also supported.</p>
<p>Note that, if applied to an integer value, <code>!</code> flips all the bits (like <code>~</code> in C).</p>
<p>The comparison operators are the traditional <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>. Short-circuiting (lazy) boolean operators are written <code>&amp;&amp;</code> (and) and <code>||</code> (or).</p>
<p>For type casting, Rust uses the binary <code>as</code> operator. It takes an expression on the left side and a type on the right side and will, if a meaningful conversion exists, convert the result of the expression to the given type.</p>
<pre><code>let x: float = 4.0;
let y: uint = x as uint;
assert!(y == 4u);</code></pre>
<h2 id="syntax-extensions"><a href="#TOC"><span class="header-section-number">3.4</span> Syntax extensions</a></h2>
<p><em>Syntax extensions</em> are special forms that are not built into the language, but are instead provided by the libraries. To make it clear to the reader when a name refers to a syntax extension, the names of all syntax extensions end with <code>!</code>. The standard library defines a few syntax extensions, the most useful of which is <code>fmt!</code>, a <code>sprintf</code>-style text formatter that you will often see in examples.</p>
<p><code>fmt!</code> supports most of the directives that <a href="http://en.cppreference.com/w/cpp/io/c/fprintf">printf</a> supports, but unlike printf, will give you a compile-time error when the types of the directives don't match the types of the arguments.</p>
<pre><code># let mystery_object = ();

io::println(fmt!(&quot;%s is %d&quot;, &quot;the answer&quot;, 43));

// %? will conveniently print any type
io::println(fmt!(&quot;what is this thing: %?&quot;, mystery_object));</code></pre>
<p>You can define your own syntax extensions with the macro system. For details, see the <a href="tutorial-macros.html">macro tutorial</a>.</p>
<h1 id="control-structures"><a href="#TOC"><span class="header-section-number">4</span> Control structures</a></h1>
<h2 id="conditionals"><a href="#TOC"><span class="header-section-number">4.1</span> Conditionals</a></h2>
<p>We've seen <code>if</code> expressions a few times already. To recap, braces are compulsory, an <code>if</code> can have an optional <code>else</code> clause, and multiple <code>if</code>/<code>else</code> constructs can be chained together:</p>
<pre><code>if false {
    io::println(&quot;that&#39;s odd&quot;);
} else if true {
    io::println(&quot;right&quot;);
} else {
    io::println(&quot;neither true nor false&quot;);
}</code></pre>
<p>The condition given to an <code>if</code> construct <em>must</em> be of type <code>bool</code> (no implicit conversion happens). If the arms are blocks that have a value, this value must be of the same type for every arm in which control reaches the end of the block:</p>
<pre><code>fn signum(x: int) -&gt; int {
    if x &lt; 0 { -1 }
    else if x &gt; 0 { 1 }
    else { return 0 }
}</code></pre>
<h2 id="pattern-matching"><a href="#TOC"><span class="header-section-number">4.2</span> Pattern matching</a></h2>
<p>Rust's <code>match</code> construct is a generalized, cleaned-up version of C's <code>switch</code> construct. You provide it with a value and a number of <em>arms</em>, each labelled with a pattern, and the code compares the value against each pattern in order until one matches. The matching pattern executes its corresponding arm.</p>
<pre><code># let my_number = 1;
match my_number {
  0     =&gt; io::println(&quot;zero&quot;),
  1 | 2 =&gt; io::println(&quot;one or two&quot;),
  3..10 =&gt; io::println(&quot;three to ten&quot;),
  _     =&gt; io::println(&quot;something else&quot;)
}</code></pre>
<p>Unlike in C, there is no &quot;falling through&quot; between arms: only one arm executes, and it doesn't have to explicitly <code>break</code> out of the construct when it is finished.</p>
<p>A <code>match</code> arm consists of a <em>pattern</em>, then an arrow <code>=&gt;</code>, followed by an <em>action</em> (expression). Literals are valid patterns and match only their own value. A single arm may match multiple different patterns by combining them with the pipe operator (<code>|</code>), so long as every pattern binds the same set of variables. Ranges of numeric literal patterns can be expressed with two dots, as in <code>M..N</code>. The underscore (<code>_</code>) is a wildcard pattern that matches any single value. The asterisk (<code>*</code>) is a different wildcard that can match one or more fields in an <code>enum</code> variant.</p>
<p>The patterns in a match arm are followed by a fat arrow, <code>=&gt;</code>, then an expression to evaluate. Each case is separated by commas. It's often convenient to use a block expression for each case, in which case the commas are optional.</p>
<pre><code># let my_number = 1;
match my_number {
  0 =&gt; { io::println(&quot;zero&quot;) }
  _ =&gt; { io::println(&quot;something else&quot;) }
}</code></pre>
<p><code>match</code> constructs must be <em>exhaustive</em>: they must have an arm covering every possible case. For example, the typechecker would reject the previous example if the arm with the wildcard pattern was omitted.</p>
<p>A powerful application of pattern matching is <em>destructuring</em>: matching in order to bind names to the contents of data types.</p>
<blockquote>
<p><strong><em>Note:</em></strong> The following code makes use of tuples (<code>(float, float)</code>) which are explained in section 5.3. For now you can think of tuples as a list of items.</p>
</blockquote>
<pre><code>fn angle(vector: (float, float)) -&gt; float {
    let pi = float::consts::pi;
    match vector {
      (0f, y) if y &lt; 0f =&gt; 1.5 * pi,
      (0f, y) =&gt; 0.5 * pi,
      (x, y) =&gt; float::atan(y / x)
    }
}</code></pre>
<p>A variable name in a pattern matches any value, <em>and</em> binds that name to the value of the matched value inside of the arm's action. Thus, <code>(0f, y)</code> matches any tuple whose first element is zero, and binds <code>y</code> to the second element. <code>(x, y)</code> matches any two-element tuple, and binds both elements to variables.</p>
<p>Any <code>match</code> arm can have a guard clause (written <code>if EXPR</code>), called a <em>pattern guard</em>, which is an expression of type <code>bool</code> that determines, after the pattern is found to match, whether the arm is taken or not. The variables bound by the pattern are in scope in this guard expression. The first arm in the <code>angle</code> example shows an example of a pattern guard.</p>
<p>You've already seen simple <code>let</code> bindings, but <code>let</code> is a little fancier than you've been led to believe. It, too, supports destructuring patterns. For example, you can write this to extract the fields from a tuple, introducing two variables at once: <code>a</code> and <code>b</code>.</p>
<pre><code># fn get_tuple_of_two_ints() -&gt; (int, int) { (1, 1) }
let (a, b) = get_tuple_of_two_ints();</code></pre>
<p>Let bindings only work with <em>irrefutable</em> patterns: that is, patterns that can never fail to match. This excludes <code>let</code> from matching literals and most <code>enum</code> variants.</p>
<h2 id="loops"><a href="#TOC"><span class="header-section-number">4.3</span> Loops</a></h2>
<p><code>while</code> denotes a loop that iterates as long as its given condition (which must have type <code>bool</code>) evaluates to <code>true</code>. Inside a loop, the keyword <code>break</code> aborts the loop, and <code>loop</code> aborts the current iteration and continues with the next.</p>
<pre><code>let mut cake_amount = 8;
while cake_amount &gt; 0 {
    cake_amount -= 1;
}</code></pre>
<p><code>loop</code> denotes an infinite loop, and is the preferred way of writing <code>while true</code>:</p>
<pre><code>let mut x = 5;
loop {
    x += x - 3;
    if x % 5 == 0 { break; }
    io::println(int::to_str(x));
}</code></pre>
<p>This code prints out a weird sequence of numbers and stops as soon as it finds one that can be divided by five.</p>
<p>For more involved iteration, such as enumerating the elements of a collection, Rust uses <a href="#closures">higher-order functions</a>.</p>
<h1 id="data-structures"><a href="#TOC"><span class="header-section-number">5</span> Data structures</a></h1>
<h2 id="structs"><a href="#TOC"><span class="header-section-number">5.1</span> Structs</a></h2>
<p>Rust struct types must be declared before they are used using the <code>struct</code> syntax: <code>struct Name { field1: T1, field2: T2 [, ...] }</code>, where <code>T1</code>, <code>T2</code>, ... denote types. To construct a struct, use the same syntax, but leave off the <code>struct</code>: for example: <code>Point { x: 1.0, y: 2.0 }</code>.</p>
<p>Structs are quite similar to C structs and are even laid out the same way in memory (so you can read from a Rust struct in C, and vice-versa). Use the dot operator to access struct fields, as in <code>mypoint.x</code>.</p>
<pre><code>struct Point {
    x: float,
    y: float
}</code></pre>
<p>Inherited mutability means that any field of a struct may be mutable, if the struct is in a mutable slot (or a field of a struct in a mutable slot, and so forth).</p>
<p>With a value (say, <code>mypoint</code>) of such a type in a mutable location, you can do <code>mypoint.y += 1.0</code>. But in an immutable location, such an assignment to a struct without inherited mutability would result in a type error.</p>
<pre class="xfail-test"><code># struct Point { x: float, y: float }
let mut mypoint = Point { x: 1.0, y: 1.0 };
let origin = Point { x: 0.0, y: 0.0 };

mypoint.y += 1.0; // mypoint is mutable, and its fields as well
origin.y += 1.0; // ERROR: assigning to immutable field</code></pre>
<p><code>match</code> patterns destructure structs. The basic syntax is <code>Name { fieldname: pattern, ... }</code>:</p>
<pre><code># struct Point { x: float, y: float }
# let mypoint = Point { x: 0.0, y: 0.0 };
match mypoint {
    Point { x: 0.0, y: yy } =&gt; { io::println(yy.to_str());                     }
    Point { x: xx,  y: yy } =&gt; { io::println(xx.to_str() + &quot; &quot; + yy.to_str()); }
}</code></pre>
<p>In general, the field names of a struct do not have to appear in the same order they appear in the type. When you are not interested in all the fields of a struct, a struct pattern may end with <code>, _</code> (as in <code>Name { field1, _ }</code>) to indicate that you're ignoring all other fields. Additionally, struct fields have a shorthand matching form that simply reuses the field name as the binding name.</p>
<pre><code># struct Point { x: float, y: float }
# let mypoint = Point { x: 0.0, y: 0.0 };
match mypoint {
    Point { x, _ } =&gt; { io::println(x.to_str()) }
}</code></pre>
<h2 id="enums"><a href="#TOC"><span class="header-section-number">5.2</span> Enums</a></h2>
<p>Enums are datatypes that have several alternate representations. For example, consider the type shown earlier:</p>
<pre><code># struct Point { x: float, y: float }
enum Shape {
    Circle(Point, float),
    Rectangle(Point, Point)
}</code></pre>
<p>A value of this type is either a <code>Circle</code>, in which case it contains a <code>Point</code> struct and a float, or a <code>Rectangle</code>, in which case it contains two <code>Point</code> structs. The run-time representation of such a value includes an identifier of the actual form that it holds, much like the &quot;tagged union&quot; pattern in C, but with better static guarantees.</p>
<p>The above declaration will define a type <code>Shape</code> that can refer to such shapes, and two functions, <code>Circle</code> and <code>Rectangle</code>, which can be used to construct values of the type (taking arguments of the specified types). So <code>Circle(Point { x: 0f, y: 0f }, 10f)</code> is the way to create a new circle.</p>
<p>Enum variants need not have parameters. This <code>enum</code> declaration, for example, is equivalent to a C enum:</p>
<pre><code>enum Direction {
    North,
    East,
    South,
    West
}</code></pre>
<p>This declaration defines <code>North</code>, <code>East</code>, <code>South</code>, and <code>West</code> as constants, all of which have type <code>Direction</code>.</p>
<p>When an enum is C-like (that is, when none of the variants have parameters), it is possible to explicitly set the discriminator values to a constant value:</p>
<pre><code>enum Color {
  Red = 0xff0000,
  Green = 0x00ff00,
  Blue = 0x0000ff
}</code></pre>
<p>If an explicit discriminator is not specified for a variant, the value defaults to the value of the previous variant plus one. If the first variant does not have a discriminator, it defaults to 0. For example, the value of <code>North</code> is 0, <code>East</code> is 1, <code>South</code> is 2, and <code>West</code> is 3.</p>
<p>When an enum is C-like, you can apply the <code>as</code> cast operator to convert it to its discriminator value as an <code>int</code>.</p>
<p>For enum types with multiple variants, destructuring is the only way to get at their contents. All variant constructors can be used as patterns, as in this definition of <code>area</code>:</p>
<pre><code># struct Point {x: float, y: float}
# enum Shape { Circle(Point, float), Rectangle(Point, Point) }
fn area(sh: Shape) -&gt; float {
    match sh {
        Circle(_, size) =&gt; float::consts::pi * size * size,
        Rectangle(Point { x, y }, Point { x: x2, y: y2 }) =&gt; (x2 - x) * (y2 - y)
    }
}</code></pre>
<p>You can write a lone <code>_</code> to ignore an individual field, and can ignore all fields of a variant like: <code>Circle(*)</code>. As in their introduction form, nullary enum patterns are written without parentheses.</p>
<pre><code># struct Point { x: float, y: float }
# enum Direction { North, East, South, West }
fn point_from_direction(dir: Direction) -&gt; Point {
    match dir {
        North =&gt; Point { x:  0f, y:  1f },
        East  =&gt; Point { x:  1f, y:  0f },
        South =&gt; Point { x:  0f, y: -1f },
        West  =&gt; Point { x: -1f, y:  0f }
    }
}</code></pre>
<p>Enum variants may also be structs. For example:</p>
<pre><code># use core::float;
# struct Point { x: float, y: float }
# fn square(x: float) -&gt; float { x * x }
enum Shape {
    Circle { center: Point, radius: float },
    Rectangle { top_left: Point, bottom_right: Point }
}
fn area(sh: Shape) -&gt; float {
    match sh {
        Circle { radius: radius, _ } =&gt; float::consts::pi * square(radius),
        Rectangle { top_left: top_left, bottom_right: bottom_right } =&gt; {
            (bottom_right.x - top_left.x) * (bottom_right.y - top_left.y)
        }
    }
}</code></pre>
<h2 id="tuples"><a href="#TOC"><span class="header-section-number">5.3</span> Tuples</a></h2>
<p>Tuples in Rust behave exactly like structs, except that their fields do not have names. Thus, you cannot access their fields with dot notation. Tuples can have any arity except for 0 (though you may consider unit, <code>()</code>, as the empty tuple if you like).</p>
<pre><code>let mytup: (int, int, float) = (10, 20, 30.0);
match mytup {
  (a, b, c) =&gt; info!(a + b + (c as int))
}</code></pre>
<h2 id="tuple-structs"><a href="#TOC"><span class="header-section-number">5.4</span> Tuple structs</a></h2>
<p>Rust also has <em>tuple structs</em>, which behave like both structs and tuples, except that, unlike tuples, tuple structs have names (so <code>Foo(1, 2)</code> has a different type from <code>Bar(1, 2)</code>), and tuple structs' <em>fields</em> do not have names.</p>
<p>For example: ~~~~ struct MyTup(int, int, float); let mytup: MyTup = MyTup(10, 20, 30.0); match mytup { MyTup(a, b, c) =&gt; info!(a + b + (c as int)) } ~~~~</p>
<a name="newtype"></a>
<p>There is a special case for tuple structs with a single field, which are sometimes called &quot;newtypes&quot; (after Haskell's &quot;newtype&quot; feature). These are used to define new types in such a way that the new name is not just a synonym for an existing type but is rather its own distinct type.</p>
<pre><code>struct GizmoId(int);</code></pre>
<p>For convenience, you can extract the contents of such a struct with the dereference (<code>*</code>) unary operator:</p>
<pre><code># struct GizmoId(int);
let my_gizmo_id: GizmoId = GizmoId(10);
let id_int: int = *my_gizmo_id;</code></pre>
<p>Types like this can be useful to differentiate between data that have the same type but must be used in different ways.</p>
<pre><code>struct Inches(int);
struct Centimeters(int);</code></pre>
<p>The above definitions allow for a simple way for programs to avoid confusing numbers that correspond to different units.</p>
<h1 id="functions"><a href="#TOC"><span class="header-section-number">6</span> Functions</a></h1>
<p>We've already seen several function definitions. Like all other static declarations, such as <code>type</code>, functions can be declared both at the top level and inside other functions (or in modules, which we'll come back to <a href="#modules-and-crates">later</a>). The <code>fn</code> keyword introduces a function. A function has an argument list, which is a parenthesized list of <code>expr: type</code> pairs separated by commas. An arrow <code>-&gt;</code> separates the argument list and the function's return type.</p>
<pre><code>fn line(a: int, b: int, x: int) -&gt; int {
    return a * x + b;
}</code></pre>
<p>The <code>return</code> keyword immediately returns from the body of a function. It is optionally followed by an expression to return. A function can also return a value by having its top-level block produce an expression.</p>
<pre><code>fn line(a: int, b: int, x: int) -&gt; int {
    a * x + b
}</code></pre>
<p>It's better Rust style to write a return value this way instead of writing an explicit <code>return</code>. The utility of <code>return</code> comes in when returning early from a function. Functions that do not return a value are said to return nil, <code>()</code>, and both the return type and the return value may be omitted from the definition. The following two functions are equivalent.</p>
<pre><code>fn do_nothing_the_hard_way() -&gt; () { return (); }

fn do_nothing_the_easy_way() { }</code></pre>
<p>Ending the function with a semicolon like so is equivalent to returning <code>()</code>.</p>
<pre><code>fn line(a: int, b: int, x: int) -&gt; int { a * x + b  }
fn oops(a: int, b: int, x: int) -&gt; ()  { a * x + b; }

assert!(8 == line(5, 3, 1));
assert!(() == oops(5, 3, 1));</code></pre>
<p>As with <code>match</code> expressions and <code>let</code> bindings, function arguments support pattern destructuring. Like <code>let</code>, argument patterns must be irrefutable, as in this example that unpacks the first value from a tuple and returns it.</p>
<pre><code>fn first((value, _): (int, float)) -&gt; int { value }</code></pre>
<h1 id="destructors"><a href="#TOC"><span class="header-section-number">7</span> Destructors</a></h1>
<p>A <em>destructor</em> is a function responsible for cleaning up the resources used by an object when it is no longer accessible. Destructors can be defined to handle the release of resources like files, sockets and heap memory.</p>
<p>Objects are never accessible after their destructor has been called, so there are no dynamic failures from accessing freed resources. When a task fails, the destructors of all objects in the task are called.</p>
<p>The <code>~</code> sigil represents a unique handle for a memory allocation on the heap:</p>
<pre><code>{
    // an integer allocated on the heap
    let y = ~10;
}
// the destructor frees the heap memory as soon as `y` goes out of scope</code></pre>
<p>Rust includes syntax for heap memory allocation in the language since it's commonly used, but the same semantics can be implemented by a type with a custom destructor.</p>
<h1 id="ownership"><a href="#TOC"><span class="header-section-number">8</span> Ownership</a></h1>
<p>Rust formalizes the concept of object ownership to delegate management of an object's lifetime to either a variable or a task-local garbage collector. An object's owner is responsible for managing the lifetime of the object by calling the destructor, and the owner determines whether the object is mutable.</p>
<p>Ownership is recursive, so mutability is inherited recursively and a destructor destroys the contained tree of owned objects. Variables are top-level owners and destroy the contained object when they go out of scope. A box managed by the garbage collector starts a new ownership tree, and the destructor is called when it is collected.</p>
<pre><code>// the struct owns the objects contained in the `x` and `y` fields
struct Foo { x: int, y: ~int }

{
    // `a` is the owner of the struct, and thus the owner of the struct&#39;s fields
    let a = Foo { x: 5, y: ~10 };
}
// when `a` goes out of scope, the destructor for the `~int` in the struct&#39;s
// field is called

// `b` is mutable, and the mutability is inherited by the objects it owns
let mut b = Foo { x: 5, y: ~10 };
b.x = 10;</code></pre>
<p>If an object doesn't contain garbage-collected boxes, it consists of a single ownership tree and is given the <code>Owned</code> trait which allows it to be sent between tasks. Custom destructors can only be implemented directly on types that are <code>Owned</code>, but garbage-collected boxes can still <em>contain</em> types with custom destructors.</p>
<h1 id="boxes"><a href="#TOC"><span class="header-section-number">9</span> Boxes</a></h1>
<p>Many modern languages represent values as pointers to heap memory by default. In contrast, Rust, like C and C++, represents such types directly. Another way to say this is that aggregate data in Rust are <em>unboxed</em>. This means that if you <code>let x = Point { x: 1f, y: 1f };</code>, you are creating a struct on the stack. If you then copy it into a data structure, you copy the entire struct, not just a pointer.</p>
<p>For small structs like <code>Point</code>, this is usually more efficient than allocating memory and indirecting through a pointer. But for big structs, or mutable state, it can be useful to have a single copy on the stack or on the heap, and refer to that through a pointer.</p>
<h2 id="owned-boxes"><a href="#TOC"><span class="header-section-number">9.1</span> Owned boxes</a></h2>
<p>An owned box (<code>~</code>) is a uniquely owned allocation on the heap. It inherits the mutability and lifetime of the owner as it would if there was no box:</p>
<pre><code>let x = 5; // immutable
let mut y = 5; // mutable
y += 2;

let x = ~5; // immutable
let mut y = ~5; // mutable
*y += 2; // the * operator is needed to access the contained value</code></pre>
<p>The purpose of an owned box is to add a layer of indirection in order to create recursive data structures or cheaply pass around an object larger than a pointer. Since an owned box has a unique owner, it can only be used to represent a tree data structure.</p>
<p>The following struct won't compile, because the lack of indirection would mean it has an infinite size:</p>
<pre class="xfail-test"><code>struct Foo {
    child: Option&lt;Foo&gt;
}</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> The <code>Option</code> type is an enum that represents an <em>optional</em> value. It's comparable to a nullable pointer in many other languages, but stores the contained value unboxed.</p>
</blockquote>
<p>Adding indirection with an owned pointer allocates the child outside of the struct on the heap, which makes it a finite size and won't result in a compile-time error:</p>
<pre><code>struct Foo {
    child: Option&lt;~Foo&gt;
}</code></pre>
<h2 id="managed-boxes"><a href="#TOC"><span class="header-section-number">9.2</span> Managed boxes</a></h2>
<p>A managed box (<code>@</code>) is a heap allocation with the lifetime managed by a task-local garbage collector. It will be destroyed at some point after there are no references left to the box, no later than the end of the task. Managed boxes lack an owner, so they start a new ownership tree and don't inherit mutability. They do own the contained object, and mutability is defined by the type of the shared box (<code>@</code> or <code>@mut</code>). An object containing a managed box is not <code>Owned</code>, and can't be sent between tasks.</p>
<pre><code>let a = @5; // immutable

let mut b = @5; // mutable variable, immutable box
b = @10;

let c = @mut 5; // immutable variable, mutable box
*c = 10;

let mut d = @mut 5; // mutable variable, mutable box
*d += 5;
d = @mut 15;</code></pre>
<p>A mutable variable and an immutable variable can refer to the same box, given that their types are compatible. Mutability of a box is a property of its type, however, so for example a mutable handle to an immutable box cannot be assigned a reference to a mutable box.</p>
<pre><code>let a = @1;     // immutable box
let b = @mut 2; // mutable box

let mut c : @int;       // declare a variable with type managed immutable int
let mut d : @mut int;   // and one of type managed mutable int

c = a;          // box type is the same, okay
d = b;          // box type is the same, okay</code></pre>
<pre class="xfail-test"><code>// but b cannot be assigned to c, or a to d
c = b;          // error</code></pre>
<h1 id="move-semantics"><a href="#TOC"><span class="header-section-number">10</span> Move semantics</a></h1>
<p>Rust uses a shallow copy for parameter passing, assignment and returning values from functions. A shallow copy is considered a move of ownership if the ownership tree of the copied value includes an owned box or a type with a custom destructor. After a value has been moved, it can no longer be used from the source location and will not be destroyed there.</p>
<pre><code>let x = ~5;
let y = x.clone(); // y is a newly allocated box
let z = x; // no new memory allocated, x can no longer be used</code></pre>
<p>Since in owned boxes mutability is a property of the owner, not the box, mutable boxes may become immutable when they are moved, and vice-versa.</p>
<pre><code>let r = ~13;
let mut s = r; // box becomes mutable
*s += 1;
let t = s; // box becomes immutable</code></pre>
<h1 id="borrowed-pointers"><a href="#TOC"><span class="header-section-number">11</span> Borrowed pointers</a></h1>
<p>Rust's borrowed pointers are a general purpose reference type. In contrast with owned boxes, where the holder of an owned box is the owner of the pointed-to memory, borrowed pointers never imply ownership. A pointer can be borrowed to any object, and the compiler verifies that it cannot outlive the lifetime of the object.</p>
<p>As an example, consider a simple struct type, <code>Point</code>:</p>
<pre><code>struct Point {
    x: float,
    y: float
}</code></pre>
<p>We can use this simple definition to allocate points in many different ways. For example, in this code, each of these three local variables contains a point, but allocated in a different location:</p>
<pre><code># struct Point { x: float, y: float }
let on_the_stack : Point  =  Point { x: 3.0, y: 4.0 };
let managed_box  : @Point = @Point { x: 5.0, y: 1.0 };
let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };</code></pre>
<p>Suppose we wanted to write a procedure that computed the distance between any two points, no matter where they were stored. For example, we might like to compute the distance between <code>on_the_stack</code> and <code>managed_box</code>, or between <code>managed_box</code> and <code>owned_box</code>. One option is to define a function that takes two arguments of type point—that is, it takes the points by value. But this will cause the points to be copied when we call the function. For points, this is probably not so bad, but often copies are expensive or, worse, if there are mutable fields, they can change the semantics of your program. So we’d like to define a function that takes the points by pointer. We can use borrowed pointers to do this:</p>
<pre><code># struct Point { x: float, y: float }
# fn sqrt(f: float) -&gt; float { 0f }
fn compute_distance(p1: &amp;Point, p2: &amp;Point) -&gt; float {
    let x_d = p1.x - p2.x;
    let y_d = p1.y - p2.y;
    sqrt(x_d * x_d + y_d * y_d)
}</code></pre>
<p>Now we can call <code>compute_distance()</code> in various ways:</p>
<pre><code># struct Point{ x: float, y: float };
# let on_the_stack : Point  =  Point { x: 3.0, y: 4.0 };
# let managed_box  : @Point = @Point { x: 5.0, y: 1.0 };
# let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };
# fn compute_distance(p1: &amp;Point, p2: &amp;Point) -&gt; float { 0f }
compute_distance(&amp;on_the_stack, managed_box);
compute_distance(managed_box, owned_box);</code></pre>
<p>Here the <code>&amp;</code> operator is used to take the address of the variable <code>on_the_stack</code>; this is because <code>on_the_stack</code> has the type <code>Point</code> (that is, a struct value) and we have to take its address to get a value. We also call this <em>borrowing</em> the local variable <code>on_the_stack</code>, because we are creating an alias: that is, another route to the same data.</p>
<p>In the case of the boxes <code>managed_box</code> and <code>owned_box</code>, however, no explicit action is necessary. The compiler will automatically convert a box like <code>@point</code> or <code>~point</code> to a borrowed pointer like <code>&amp;point</code>. This is another form of borrowing; in this case, the contents of the managed/owned box are being lent out.</p>
<p>Whenever a value is borrowed, there are some limitations on what you can do with the original. For example, if the contents of a variable have been lent out, you cannot send that variable to another task, nor will you be permitted to take actions that might cause the borrowed value to be freed or to change its type. This rule should make intuitive sense: you must wait for a borrowed value to be returned (that is, for the borrowed pointer to go out of scope) before you can make full use of it again.</p>
<p>For a more in-depth explanation of borrowed pointers, read the <a href="tutorial-borrowed-ptr.html">borrowed pointer tutorial</a>.</p>
<h2 id="freezing"><a href="#TOC"><span class="header-section-number">11.1</span> Freezing</a></h2>
<p>Borrowing an immutable pointer to an object freezes it and prevents mutation. <code>Owned</code> objects have freezing enforced statically at compile-time.</p>
<pre><code>let mut x = 5;
{
    let y = &amp;x; // x is now frozen, it cannot be modified
}
// x is now unfrozen again</code></pre>
<p>Mutable managed boxes handle freezing dynamically when any of their contents are borrowed, and the task will fail if an attempt to modify them is made while they are frozen:</p>
<pre><code>let x = @mut 5;
let y = x;
{
    let z = &amp;*y; // the managed box is now frozen
    // modifying it through x or y will cause a task failure
}
// the box is now unfrozen again</code></pre>
<h1 id="dereferencing-pointers"><a href="#TOC"><span class="header-section-number">12</span> Dereferencing pointers</a></h1>
<p>Rust uses the unary star operator (<code>*</code>) to access the contents of a box or pointer, similarly to C.</p>
<pre><code>let managed = @10;
let owned = ~20;
let borrowed = &amp;30;

let sum = *managed + *owned + *borrowed;</code></pre>
<p>Dereferenced mutable pointers may appear on the left hand side of assignments. Such an assignment modifies the value that the pointer points to.</p>
<pre><code>let managed = @mut 10;
let mut owned = ~20;

let mut value = 30;
let borrowed = &amp;mut value;

*managed = *owned + 10;
*owned = *borrowed + 100;
*borrowed = *managed + 1000;</code></pre>
<p>Pointers have high operator precedence, but lower precedence than the dot operator used for field and method access. This precedence order can sometimes make code awkward and parenthesis-filled.</p>
<pre><code># struct Point { x: float, y: float }
# enum Shape { Rectangle(Point, Point) }
# impl Shape { fn area(&amp;self) -&gt; int { 0 } }
let start = @Point { x: 10f, y: 20f };
let end = ~Point { x: (*start).x + 100f, y: (*start).y + 100f };
let rect = &amp;Rectangle(*start, *end);
let area = (*rect).area();</code></pre>
<p>To combat this ugliness the dot operator applies <em>automatic pointer dereferencing</em> to the receiver (the value on the left-hand side of the dot), so in most cases, explicitly dereferencing the receiver is not necessary.</p>
<pre><code># struct Point { x: float, y: float }
# enum Shape { Rectangle(Point, Point) }
# impl Shape { fn area(&amp;self) -&gt; int { 0 } }
let start = @Point { x: 10f, y: 20f };
let end = ~Point { x: start.x + 100f, y: start.y + 100f };
let rect = &amp;Rectangle(*start, *end);
let area = rect.area();</code></pre>
<p>You can write an expression that dereferences any number of pointers automatically. For example, if you felt inclined, you could write something silly like</p>
<pre><code># struct Point { x: float, y: float }
let point = &amp;@~Point { x: 10f, y: 20f };
io::println(fmt!(&quot;%f&quot;, point.x));</code></pre>
<p>The indexing operator (<code>[]</code>) also auto-dereferences.</p>
<h1 id="vectors-and-strings"><a href="#TOC"><span class="header-section-number">13</span> Vectors and strings</a></h1>
<p>A vector is a contiguous section of memory containing zero or more values of the same type. Like other types in Rust, vectors can be stored on the stack, the local heap, or the exchange heap. Borrowed pointers to vectors are also called 'slices'.</p>
<pre><code># enum Crayon {
#     Almond, AntiqueBrass, Apricot,
#     Aquamarine, Asparagus, AtomicTangerine,
#     BananaMania, Beaver, Bittersweet,
#     Black, BlizzardBlue, Blue
# }
// A fixed-size stack vector
let stack_crayons: [Crayon, ..3] = [Almond, AntiqueBrass, Apricot];

// A borrowed pointer to stack-allocated vector
let stack_crayons: &amp;[Crayon] = &amp;[Aquamarine, Asparagus, AtomicTangerine];

// A local heap (managed) vector of crayons
let local_crayons: @[Crayon] = @[BananaMania, Beaver, Bittersweet];

// An exchange heap (owned) vector of crayons
let exchange_crayons: ~[Crayon] = ~[Black, BlizzardBlue, Blue];</code></pre>
<p>The <code>+</code> operator means concatenation when applied to vector types.</p>
<pre><code># enum Crayon { Almond, AntiqueBrass, Apricot,
#               Aquamarine, Asparagus, AtomicTangerine,
#               BananaMania, Beaver, Bittersweet };

let my_crayons = ~[Almond, AntiqueBrass, Apricot];
let your_crayons = ~[BananaMania, Beaver, Bittersweet];

// Add two vectors to create a new one
let our_crayons = my_crayons + your_crayons;

// += will append to a vector, provided it lives in a mutable slot
let mut my_crayons = my_crayons;
my_crayons += your_crayons;</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> The above examples of vector addition use owned vectors. Some operations on slices and stack vectors are not yet well-supported. Owned vectors are often the most usable.</p>
</blockquote>
<p>Square brackets denote indexing into a vector:</p>
<pre><code># enum Crayon { Almond, AntiqueBrass, Apricot,
#               Aquamarine, Asparagus, AtomicTangerine,
#               BananaMania, Beaver, Bittersweet };
# fn draw_scene(c: Crayon) { }
let crayons: [Crayon, ..3] = [BananaMania, Beaver, Bittersweet];
match crayons[0] {
    Bittersweet =&gt; draw_scene(crayons[0]),
    _ =&gt; ()
}</code></pre>
<p>A vector can be destructured using pattern matching:</p>
<pre><code>let numbers: [int, ..3] = [1, 2, 3];
let score = match numbers {
    [] =&gt; 0,
    [a] =&gt; a * 10,
    [a, b] =&gt; a * 6 + b * 4,
    [a, b, c, ..rest] =&gt; a * 5 + b * 3 + c * 2 + rest.len() as int
};</code></pre>
<p>The elements of a vector <em>inherit the mutability of the vector</em>, and as such, individual elements may not be reassigned when the vector lives in an immutable slot.</p>
<pre class="xfail-test"><code># enum Crayon { Almond, AntiqueBrass, Apricot,
#               Aquamarine, Asparagus, AtomicTangerine,
#               BananaMania, Beaver, Bittersweet };
let crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];

crayons[0] = Apricot; // ERROR: Can&#39;t assign to immutable vector</code></pre>
<p>Moving it into a mutable slot makes the elements assignable.</p>
<pre><code># enum Crayon { Almond, AntiqueBrass, Apricot,
#               Aquamarine, Asparagus, AtomicTangerine,
#               BananaMania, Beaver, Bittersweet };
let crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];

// Put the vector into a mutable slot
let mut mutable_crayons = crayons;

// Now it&#39;s mutable to the bone
mutable_crayons[0] = Apricot;</code></pre>
<p>This is a simple example of Rust's <em>dual-mode data structures</em>, also referred to as <em>freezing and thawing</em>.</p>
<p>Strings are implemented with vectors of <code>u8</code>, though they have a distinct type. They support most of the same allocation options as vectors, though the string literal without a storage sigil (for example, <code>&quot;foo&quot;</code>) is treated differently than a comparable vector (<code>[foo]</code>). Whereas plain vectors are stack-allocated fixed-length vectors, plain strings are borrowed pointers to read-only (static) memory. All strings are immutable.</p>
<pre><code>// A plain string is a slice to read-only (static) memory
let stack_crayons: &amp;str = &quot;Almond, AntiqueBrass, Apricot&quot;;

// The same thing, but with the `&amp;`
let stack_crayons: &amp;str = &amp;&quot;Aquamarine, Asparagus, AtomicTangerine&quot;;

// A local heap (managed) string
let local_crayons: @str = @&quot;BananaMania, Beaver, Bittersweet&quot;;

// An exchange heap (owned) string
let exchange_crayons: ~str = ~&quot;Black, BlizzardBlue, Blue&quot;;</code></pre>
<p>Both vectors and strings support a number of useful <a href="#functions-and-methods">methods</a>, defined in <a href="core/vec.html"><code>core::vec</code></a> and <a href="core/str.html"><code>core::str</code></a>. Here are some examples.</p>
<pre><code># use core::io::println;
# enum Crayon {
#     Almond, AntiqueBrass, Apricot,
#     Aquamarine, Asparagus, AtomicTangerine,
#     BananaMania, Beaver, Bittersweet
# }
# fn unwrap_crayon(c: Crayon) -&gt; int { 0 }
# fn eat_crayon_wax(i: int) { }
# fn store_crayon_in_nasal_cavity(i: uint, c: Crayon) { }
# fn crayon_to_str(c: Crayon) -&gt; &amp;str { &quot;&quot; }

let crayons = [Almond, AntiqueBrass, Apricot];

// Check the length of the vector
assert!(crayons.len() == 3);
assert!(!crayons.is_empty());

// Iterate over a vector, obtaining a pointer to each element
for crayons.each |crayon| {
    let delicious_crayon_wax = unwrap_crayon(*crayon);
    eat_crayon_wax(delicious_crayon_wax);
}

// Map vector elements
let crayon_names = crayons.map(|v| crayon_to_str(*v));
let favorite_crayon_name = crayon_names[0];

// Remove whitespace from before and after the string
let new_favorite_crayon_name = favorite_crayon_name.trim();

if favorite_crayon_name.len() &gt; 5 {
   // Create a substring
   println(favorite_crayon_name.substr(0, 5));
}</code></pre>
<h1 id="closures"><a href="#TOC"><span class="header-section-number">14</span> Closures</a></h1>
<p>Named functions, like those we've seen so far, may not refer to local variables declared outside the function: they do not close over their environment (sometimes referred to as &quot;capturing&quot; variables in their environment). For example, you couldn't write the following:</p>
<pre class="ignore"><code>let foo = 10;

fn bar() -&gt; int {
   return foo; // `bar` cannot refer to `foo`
}</code></pre>
<p>Rust also supports <em>closures</em>, functions that can access variables in the enclosing scope.</p>
<pre><code># use println = core::io::println;
fn call_closure_with_ten(b: &amp;fn(int)) { b(10); }

let captured_var = 20;
let closure = |arg| println(fmt!(&quot;captured_var=%d, arg=%d&quot;, captured_var, arg));

call_closure_with_ten(closure);</code></pre>
<p>Closures begin with the argument list between vertical bars and are followed by a single expression. The types of the arguments are generally omitted, as is the return type, because the compiler can almost always infer them. In the rare case where the compiler needs assistance, though, the arguments and return types may be annotated.</p>
<pre><code>let square = |x: int| -&gt; uint { x * x as uint };</code></pre>
<p>There are several forms of closure, each with its own role. The most common, called a <em>stack closure</em>, has type <code>&amp;fn</code> and can directly access local variables in the enclosing scope.</p>
<pre><code>let mut max = 0;
[1, 2, 3].map(|x| if *x &gt; max { max = *x });</code></pre>
<p>Stack closures are very efficient because their environment is allocated on the call stack and refers by pointer to captured locals. To ensure that stack closures never outlive the local variables to which they refer, stack closures are not first-class. That is, they can only be used in argument position; they cannot be stored in data structures or returned from functions. Despite these limitations, stack closures are used pervasively in Rust code.</p>
<h2 id="managed-closures"><a href="#TOC"><span class="header-section-number">14.1</span> Managed closures</a></h2>
<p>When you need to store a closure in a data structure, a stack closure will not do, since the compiler will refuse to let you store it. For this purpose, Rust provides a type of closure that has an arbitrary lifetime, written <code>@fn</code> (boxed closure, analogous to the <code>@</code> pointer type described earlier). This type of closure <em>is</em> first-class.</p>
<p>A managed closure does not directly access its environment, but merely copies out the values that it closes over into a private data structure. This means that it can not assign to these variables, and cannot observe updates to them.</p>
<p>This code creates a closure that adds a given string to its argument, returns it from a function, and then calls it:</p>
<pre><code># extern mod std;
fn mk_appender(suffix: ~str) -&gt; @fn(~str) -&gt; ~str {
    // The compiler knows that we intend this closure to be of type @fn
    return |s| s + suffix;
}

fn main() {
    let shout = mk_appender(~&quot;!&quot;);
    io::println(shout(~&quot;hey ho, let&#39;s go&quot;));
}</code></pre>
<h2 id="owned-closures"><a href="#TOC"><span class="header-section-number">14.2</span> Owned closures</a></h2>
<p>Owned closures, written <code>~fn</code> in analogy to the <code>~</code> pointer type, hold on to things that can safely be sent between processes. They copy the values they close over, much like managed closures, but they also own them: that is, no other code can access them. Owned closures are used in concurrent code, particularly for spawning <a href="tutorial-tasks.html">tasks</a>.</p>
<h2 id="closure-compatibility"><a href="#TOC"><span class="header-section-number">14.3</span> Closure compatibility</a></h2>
<p>Rust closures have a convenient subtyping property: you can pass any kind of closure (as long as the arguments and return types match) to functions that expect a <code>&amp;fn()</code>. Thus, when writing a higher-order function that only calls its function argument, and does nothing else with it, you should almost always declare the type of that argument as <code>&amp;fn()</code>. That way, callers may pass any kind of closure.</p>
<pre><code>fn call_twice(f: &amp;fn()) { f(); f(); }
let closure = || { &quot;I&#39;m a closure, and it doesn&#39;t matter what type I am&quot;; };
fn function() { &quot;I&#39;m a normal function&quot;; }
call_twice(closure);
call_twice(function);</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> Both the syntax and the semantics will be changing in small ways. At the moment they can be unsound in some scenarios, particularly with non-copyable types.</p>
</blockquote>
<h2 id="do-syntax"><a href="#TOC"><span class="header-section-number">14.4</span> Do syntax</a></h2>
<p>The <code>do</code> expression provides a way to treat higher-order functions (functions that take closures as arguments) as control structures.</p>
<p>Consider this function that iterates over a vector of integers, passing in a pointer to each integer in the vector:</p>
<pre><code>fn each(v: &amp;[int], op: &amp;fn(v: &amp;int)) {
   let mut n = 0;
   while n &lt; v.len() {
       op(&amp;v[n]);
       n += 1;
   }
}</code></pre>
<p>As an aside, the reason we pass in a <em>pointer</em> to an integer rather than the integer itself is that this is how the actual <code>each()</code> function for vectors works. <code>vec::each</code> though is a <a href="#generics">generic</a> function, so must be efficient to use for all types. Passing the elements by pointer avoids copying potentially large objects.</p>
<p>As a caller, if we use a closure to provide the final operator argument, we can write it in a way that has a pleasant, block-like structure.</p>
<pre><code># fn each(v: &amp;[int], op: &amp;fn(v: &amp;int)) { }
# fn do_some_work(i: &amp;int) { }
each([1, 2, 3], |n| {
    do_some_work(n);
});</code></pre>
<p>This is such a useful pattern that Rust has a special form of function call that can be written more like a built-in control structure:</p>
<pre><code># fn each(v: &amp;[int], op: &amp;fn(v: &amp;int)) { }
# fn do_some_work(i: &amp;int) { }
do each([1, 2, 3]) |n| {
    do_some_work(n);
}</code></pre>
<p>The call is prefixed with the keyword <code>do</code> and, instead of writing the final closure inside the argument list, it appears outside of the parentheses, where it looks more like a typical block of code.</p>
<p><code>do</code> is a convenient way to create tasks with the <code>task::spawn</code> function. <code>spawn</code> has the signature <code>spawn(fn: ~fn())</code>. In other words, it is a function that takes an owned closure that takes no arguments.</p>
<pre><code>use core::task::spawn;

do spawn() || {
    debug!(&quot;I&#39;m a task, whatever&quot;);
}</code></pre>
<p>Look at all those bars and parentheses -- that's two empty argument lists back to back. Since that is so unsightly, empty argument lists may be omitted from <code>do</code> expressions.</p>
<pre><code># use core::task::spawn;
do spawn {
   debug!(&quot;Kablam!&quot;);
}</code></pre>
<p>If you want to see the output of <code>debug!</code> statements, you will need to turn on <code>debug!</code> logging. To enable <code>debug!</code> logging, set the RUST_LOG environment variable to the name of your crate, which, for a file named <code>foo.rs</code>, will be <code>foo</code> (e.g., with bash, <code>export RUST_LOG=foo</code>).</p>
<h2 id="for-loops"><a href="#TOC"><span class="header-section-number">14.5</span> For loops</a></h2>
<p>The most common way to express iteration in Rust is with a <code>for</code> loop. Like <code>do</code>, <code>for</code> is a nice syntax for describing control flow with closures. Additionally, within a <code>for</code> loop, <code>break</code>, <code>loop</code>, and <code>return</code> work just as they do with <code>while</code> and <code>loop</code>.</p>
<p>Consider again our <code>each</code> function, this time improved to break early when the iteratee returns <code>false</code>:</p>
<pre><code>fn each(v: &amp;[int], op: &amp;fn(v: &amp;int) -&gt; bool) {
   let mut n = 0;
   while n &lt; v.len() {
       if !op(&amp;v[n]) {
           break;
       }
       n += 1;
   }
}</code></pre>
<p>And using this function to iterate over a vector:</p>
<pre><code># use each = core::vec::each;
# use println = core::io::println;
each([2, 4, 8, 5, 16], |n| {
    if *n % 2 != 0 {
        println(&quot;found odd number!&quot;);
        false
    } else { true }
});</code></pre>
<p>With <code>for</code>, functions like <code>each</code> can be treated more like built-in looping structures. When calling <code>each</code> in a <code>for</code> loop, instead of returning <code>false</code> to break out of the loop, you just write <code>break</code>. To skip ahead to the next iteration, write <code>loop</code>.</p>
<pre><code># use each = core::vec::each;
# use println = core::io::println;
for each([2, 4, 8, 5, 16]) |n| {
    if *n % 2 != 0 {
        println(&quot;found odd number!&quot;);
        break;
    }
}</code></pre>
<p>As an added bonus, you can use the <code>return</code> keyword, which is not normally allowed in closures, in a block that appears as the body of a <code>for</code> loop: the meaning of <code>return</code> in such a block is to return from the enclosing function, not just the loop body.</p>
<pre><code># use each = core::vec::each;
fn contains(v: &amp;[int], elt: int) -&gt; bool {
    for each(v) |x| {
        if (*x == elt) { return true; }
    }
    false
}</code></pre>
<p>Notice that, because <code>each</code> passes each value by borrowed pointer, the iteratee needs to dereference it before using it. In these situations it can be convenient to lean on Rust's argument patterns to bind <code>x</code> to the actual value, not the pointer.</p>
<pre><code># use each = core::vec::each;
# fn contains(v: &amp;[int], elt: int) -&gt; bool {
    for each(v) |&amp;x| {
        if (x == elt) { return true; }
    }
#    false
# }</code></pre>
<p><code>for</code> syntax only works with stack closures.</p>
<blockquote>
<p><strong><em>Note:</em></strong> This is, essentially, a special loop protocol: the keywords <code>break</code>, <code>loop</code>, and <code>return</code> work, in varying degree, with <code>while</code>, <code>loop</code>, <code>do</code>, and <code>for</code> constructs.</p>
</blockquote>
<h1 id="methods"><a href="#TOC"><span class="header-section-number">15</span> Methods</a></h1>
<p>Methods are like functions except that they always begin with a special argument, called <code>self</code>, which has the type of the method's receiver. The <code>self</code> argument is like <code>this</code> in C++ and many other languages. Methods are called with dot notation, as in <code>my_vec.len()</code>.</p>
<p><em>Implementations</em>, written with the <code>impl</code> keyword, can define methods on most Rust types, including structs and enums. As an example, let's define a <code>draw</code> method on our <code>Shape</code> enum.</p>
<pre><code># fn draw_circle(p: Point, f: float) { }
# fn draw_rectangle(p: Point, p: Point) { }
struct Point {
    x: float,
    y: float
}

enum Shape {
    Circle(Point, float),
    Rectangle(Point, Point)
}

impl Shape {
    fn draw(&amp;self) {
        match *self {
            Circle(p, f) =&gt; draw_circle(p, f),
            Rectangle(p1, p2) =&gt; draw_rectangle(p1, p2)
        }
    }
}

let s = Circle(Point { x: 1f, y: 2f }, 3f);
s.draw();</code></pre>
<p>This defines an <em>implementation</em> for <code>Shape</code> containing a single method, <code>draw</code>. In most respects the <code>draw</code> method is defined like any other function, except for the name <code>self</code>.</p>
<p>The type of <code>self</code> is the type on which the method is implemented, or a pointer thereof. As an argument it is written either <code>self</code>, <code>&amp;self</code>, <code>@self</code>, or <code>~self</code>. A caller must in turn have a compatible pointer type to call the method.</p>
<pre><code># fn draw_circle(p: Point, f: float) { }
# fn draw_rectangle(p: Point, p: Point) { }
# struct Point { x: float, y: float }
# enum Shape {
#     Circle(Point, float),
#     Rectangle(Point, Point)
# }
impl Shape {
    fn draw_borrowed(&amp;self) { ... }
    fn draw_managed(@self) { ... }
    fn draw_owned(~self) { ... }
    fn draw_value(self) { ... }
}

let s = Circle(Point { x: 1f, y: 2f }, 3f);

(@s).draw_managed();
(~s).draw_owned();
(&amp;s).draw_borrowed();
s.draw_value();</code></pre>
<p>Methods typically take a borrowed pointer self type, so the compiler will go to great lengths to convert a callee to a borrowed pointer.</p>
<pre><code># fn draw_circle(p: Point, f: float) { }
# fn draw_rectangle(p: Point, p: Point) { }
# struct Point { x: float, y: float }
# enum Shape {
#     Circle(Point, float),
#     Rectangle(Point, Point)
# }
# impl Shape {
#    fn draw_borrowed(&amp;self) { ... }
#    fn draw_managed(@self) { ... }
#    fn draw_owned(~self) { ... }
#    fn draw_value(self) { ... }
# }
# let s = Circle(Point { x: 1f, y: 2f }, 3f);
// As with typical function arguments, managed and unique pointers
// are automatically converted to borrowed pointers

(@s).draw_borrowed();
(~s).draw_borrowed();

// Unlike typical function arguments, the self value will
// automatically be referenced ...
s.draw_borrowed();

// ... and dereferenced
(&amp; &amp;s).draw_borrowed();

// ... and dereferenced and borrowed
(&amp;@~s).draw_borrowed();</code></pre>
<p>Implementations may also define standalone (sometimes called &quot;static&quot;) methods. The absence of a <code>self</code> paramater distinguishes such methods. These methods are the preferred way to define constructor functions.</p>
<pre class="xfail-test"><code>impl Circle {
    fn area(&amp;self) -&gt; float { ... }
    fn new(area: float) -&gt; Circle { ... }
}</code></pre>
<p>To call such a method, just prefix it with the type name and a double colon:</p>
<pre><code># use core::float::consts::pi;
# use core::float::sqrt;
struct Circle { radius: float }
impl Circle {
    fn new(area: float) -&gt; Circle { Circle { radius: sqrt(area / pi) } }
}
let c = Circle::new(42.5);</code></pre>
<h1 id="generics"><a href="#TOC"><span class="header-section-number">16</span> Generics</a></h1>
<p>Throughout this tutorial, we've been defining functions that act only on specific data types. With type parameters we can also define functions whose arguments have generic types, and which can be invoked with a variety of types. Consider a generic <code>map</code> function, which takes a function <code>function</code> and a vector <code>vector</code> and returns a new vector consisting of the result of applying <code>function</code> to each element of <code>vector</code>:</p>
<pre><code>fn map&lt;T, U&gt;(vector: &amp;[T], function: &amp;fn(v: &amp;T) -&gt; U) -&gt; ~[U] {
    let mut accumulator = ~[];
    for vec::each(vector) |element| {
        accumulator.push(function(element));
    }
    return accumulator;
}</code></pre>
<p>When defined with type parameters, as denoted by <code>&lt;T, U&gt;</code>, this function can be applied to any type of vector, as long as the type of <code>function</code>'s argument and the type of the vector's contents agree with each other.</p>
<p>Inside a generic function, the names of the type parameters (capitalized by convention) stand for opaque types. All you can do with instances of these types is pass them around: you can't apply any operations to them or pattern-match on them. Note that instances of generic types are often passed by pointer. For example, the parameter <code>function()</code> is supplied with a pointer to a value of type <code>T</code> and not a value of type <code>T</code> itself. This ensures that the function works with the broadest set of types possible, since some types are expensive or illegal to copy and pass by value.</p>
<p>Generic <code>type</code>, <code>struct</code>, and <code>enum</code> declarations follow the same pattern:</p>
<pre><code># use core::hashmap::HashMap;
type Set&lt;T&gt; = HashMap&lt;T, ()&gt;;

struct Stack&lt;T&gt; {
    elements: ~[T]
}

enum Option&lt;T&gt; {
    Some(T),
    None
}</code></pre>
<p>These declarations can be instantiated to valid types like <code>Set&lt;int&gt;</code>, <code>Stack&lt;int&gt;</code>, and <code>Option&lt;int&gt;</code>.</p>
<p>The last type in that example, <code>Option</code>, appears frequently in Rust code. Because Rust does not have null pointers (except in unsafe code), we need another way to write a function whose result isn't defined on every possible combination of arguments of the appropriate types. The usual way is to write a function that returns <code>Option&lt;T&gt;</code> instead of <code>T</code>.</p>
<pre><code># struct Point { x: float, y: float }
# enum Shape { Circle(Point, float), Rectangle(Point, Point) }
fn radius(shape: Shape) -&gt; Option&lt;float&gt; {
    match shape {
        Circle(_, radius) =&gt; Some(radius),
        Rectangle(*)      =&gt; None
    }
}</code></pre>
<p>The Rust compiler compiles generic functions very efficiently by <em>monomorphizing</em> them. <em>Monomorphization</em> is a fancy name for a simple idea: generate a separate copy of each generic function at each call site, a copy that is specialized to the argument types and can thus be optimized specifically for them. In this respect, Rust's generics have similar performance characteristics to C++ templates.</p>
<h2 id="traits"><a href="#TOC"><span class="header-section-number">16.1</span> Traits</a></h2>
<p>Within a generic function the operations available on generic types are very limited. After all, since the function doesn't know what types it is operating on, it can't safely modify or query their values. This is where <em>traits</em> come into play. Traits are Rust's most powerful tool for writing polymorphic code. Java developers will see them as similar to Java interfaces, and Haskellers will notice their similarities to type classes. Rust's traits are a form of <em>bounded polymorphism</em>: a trait is a way of limiting the set of possible types that a type parameter could refer to.</p>
<p>As motivation, let us consider copying in Rust. The <code>copy</code> operation is not defined for all Rust types. One reason is user-defined destructors: copying a type that has a destructor could result in the destructor running multiple times. Therefore, types with user-defined destructors cannot be copied, either implicitly or explicitly, and neither can types that own other types containing destructors.</p>
<p>This complicates handling of generic functions. If you have a type parameter <code>T</code>, can you copy values of that type? In Rust, you can't, and if you try to run the following code the compiler will complain.</p>
<pre class="xfail-test"><code>// This does not compile
fn head_bad&lt;T&gt;(v: &amp;[T]) -&gt; T {
    v[0] // error: copying a non-copyable value
}</code></pre>
<p>However, we can tell the compiler that the <code>head</code> function is only for copyable types: that is, those that have the <code>Copy</code> trait.</p>
<pre><code>// This does
fn head&lt;T: Copy&gt;(v: &amp;[T]) -&gt; T {
    v[0]
}</code></pre>
<p>This says that we can call <code>head</code> on any type <code>T</code> as long as that type implements the <code>Copy</code> trait. When instantiating a generic function, you can only instantiate it with types that implement the correct trait, so you could not apply <code>head</code> to a type with a destructor. (<code>Copy</code> is a special trait that is built in to the compiler, making it possible for the compiler to enforce this restriction.)</p>
<p>While most traits can be defined and implemented by user code, three traits are automatically derived and implemented for all applicable types by the compiler, and may not be overridden:</p>
<ul>
<li><p><code>Copy</code> - Types that can be copied, either implicitly, or explicitly with the <code>copy</code> operator. All types are copyable unless they have destructors or contain types with destructors.</p></li>
<li><p><code>Owned</code> - Owned types. Types are owned unless they contain managed boxes, managed closures, or borrowed pointers. Owned types may or may not be copyable.</p></li>
<li><p><code>Const</code> - Constant (immutable) types. These are types that do not contain mutable fields.</p></li>
</ul>
<blockquote>
<p><strong><em>Note:</em></strong> These three traits were referred to as 'kinds' in earlier iterations of the language, and often still are.</p>
</blockquote>
<p>Additionally, the <code>Drop</code> trait is used to define destructors. This trait defines one method called <code>finalize</code>, which is automatically called when a value of the type that implements this trait is destroyed, either because the value went out of scope or because the garbage collector reclaimed it.</p>
<pre><code>struct TimeBomb {
    explosivity: uint
}

impl Drop for TimeBomb {
    fn finalize(&amp;self) {
        for old_iter::repeat(self.explosivity) {
            io::println(&quot;blam!&quot;);
        }
    }
}</code></pre>
<p>It is illegal to call <code>finalize</code> directly. Only code inserted by the compiler may call it.</p>
<h2 id="declaring-and-implementing-traits"><a href="#TOC"><span class="header-section-number">16.2</span> Declaring and implementing traits</a></h2>
<p>A trait consists of a set of methods, without bodies, or may be empty, as is the case with <code>Copy</code>, <code>Owned</code>, and <code>Const</code>. For example, we could declare the trait <code>Printable</code> for things that can be printed to the console, with a single method:</p>
<pre><code>trait Printable {
    fn print(&amp;self);
}</code></pre>
<p>Traits may be implemented for specific types with <a href="#functions-and-methods">impls</a>. An impl that implements a trait includes the name of the trait at the start of the definition, as in the following impls of <code>Printable</code> for <code>int</code> and <code>~str</code>.</p>
<pre><code># trait Printable { fn print(&amp;self); }
impl Printable for int {
    fn print(&amp;self) { io::println(fmt!(&quot;%d&quot;, *self)) }
}

impl Printable for ~str {
    fn print(&amp;self) { io::println(*self) }
}

# 1.print();
# (~&quot;foo&quot;).print();</code></pre>
<p>Methods defined in an implementation of a trait may be called just like any other method, using dot notation, as in <code>1.print()</code>. Traits may themselves contain type parameters. A trait for generalized sequence types might look like the following:</p>
<pre><code>trait Seq&lt;T&gt; {
    fn len(&amp;self) -&gt; uint;
    fn iter(&amp;self, b: &amp;fn(v: &amp;T));
}

impl&lt;T&gt; Seq&lt;T&gt; for ~[T] {
    fn len(&amp;self) -&gt; uint { vec::len(*self) }
    fn iter(&amp;self, b: &amp;fn(v: &amp;T)) {
        for vec::each(*self) |elt| { b(elt); }
    }
}</code></pre>
<p>The implementation has to explicitly declare the type parameter that it binds, <code>T</code>, before using it to specify its trait type. Rust requires this declaration because the <code>impl</code> could also, for example, specify an implementation of <code>Seq&lt;int&gt;</code>. The trait type (appearing between <code>impl</code> and <code>for</code>) <em>refers</em> to a type, rather than defining one.</p>
<p>The type parameters bound by a trait are in scope in each of the method declarations. So, re-declaring the type parameter <code>T</code> as an explicit type parameter for <code>len</code>, in either the trait or the impl, would be a compile-time error.</p>
<p>Within a trait definition, <code>Self</code> is a special type that you can think of as a type parameter. An implementation of the trait for any given type <code>T</code> replaces the <code>Self</code> type parameter with <code>T</code>. The following trait describes types that support an equality operation:</p>
<pre><code>// In a trait, `self` refers to the self argument.
// `Self` refers to the type implementing the trait.
trait Eq {
    fn equals(&amp;self, other: &amp;Self) -&gt; bool;
}

// In an impl, `self` refers just to the value of the receiver
impl Eq for int {
    fn equals(&amp;self, other: &amp;int) -&gt; bool { *other == *self }
}</code></pre>
<p>Notice that in the trait definition, <code>equals</code> takes a second parameter of type <code>Self</code>. In contrast, in the <code>impl</code>, <code>equals</code> takes a second parameter of type <code>int</code>, only using <code>self</code> as the name of the receiver.</p>
<p>Just as in type implementations, traits can define standalone (static) methods. These methods are called by prefixing the method name with the trait name and a double colon. The compiler uses type inference to decide which implementation to use.</p>
<pre><code># use core::float::consts::pi;
# use core::float::sqrt;
trait Shape { fn new(area: float) -&gt; Self; }
struct Circle { radius: float }
struct Square { length: float }

impl Shape for Circle {
    fn new(area: float) -&gt; Circle { Circle { radius: sqrt(area / pi) } }
}
impl Shape for Square {
    fn new(area: float) -&gt; Square { Square { length: sqrt(area) } }
}

let area = 42.5;
let c: Circle = Shape::new(area);
let s: Square = Shape::new(area);</code></pre>
<h2 id="bounded-type-parameters-and-static-method-dispatch"><a href="#TOC"><span class="header-section-number">16.3</span> Bounded type parameters and static method dispatch</a></h2>
<p>Traits give us a language for defining predicates on types, or abstract properties that types can have. We can use this language to define <em>bounds</em> on type parameters, so that we can then operate on generic types.</p>
<pre><code># trait Printable { fn print(&amp;self); }
fn print_all&lt;T: Printable&gt;(printable_things: ~[T]) {
    for printable_things.each |thing| {
        thing.print();
    }
}</code></pre>
<p>Declaring <code>T</code> as conforming to the <code>Printable</code> trait (as we earlier did with <code>Copy</code>) makes it possible to call methods from that trait on values of type <code>T</code> inside the function. It will also cause a compile-time error when anyone tries to call <code>print_all</code> on an array whose element type does not have a <code>Printable</code> implementation.</p>
<p>Type parameters can have multiple bounds by separating them with <code>+</code>, as in this version of <code>print_all</code> that copies elements.</p>
<pre><code># trait Printable { fn print(&amp;self); }
fn print_all&lt;T: Printable + Copy&gt;(printable_things: ~[T]) {
    let mut i = 0;
    while i &lt; printable_things.len() {
        let copy_of_thing = printable_things[i];
        copy_of_thing.print();
        i += 1;
    }
}</code></pre>
<p>Method calls to bounded type parameters are <em>statically dispatched</em>, imposing no more overhead than normal function invocation, so are the preferred way to use traits polymorphically.</p>
<p>This usage of traits is similar to Haskell type classes.</p>
<h2 id="trait-objects-and-dynamic-method-dispatch"><a href="#TOC"><span class="header-section-number">16.4</span> Trait objects and dynamic method dispatch</a></h2>
<p>The above allows us to define functions that polymorphically act on values of a single unknown type that conforms to a given trait. However, consider this function:</p>
<pre><code># type Circle = int; type Rectangle = int;
# impl Drawable for int { fn draw(&amp;self) {} }
# fn new_circle() -&gt; int { 1 }
trait Drawable { fn draw(&amp;self); }

fn draw_all&lt;T: Drawable&gt;(shapes: ~[T]) {
    for shapes.each |shape| { shape.draw(); }
}
# let c: Circle = new_circle();
# draw_all(~[c]);</code></pre>
<p>You can call that on an array of circles, or an array of rectangles (assuming those have suitable <code>Drawable</code> traits defined), but not on an array containing both circles and rectangles. When such behavior is needed, a trait name can alternately be used as a type, called an <em>object</em>.</p>
<pre><code># trait Drawable { fn draw(&amp;self); }
fn draw_all(shapes: &amp;[@Drawable]) {
    for shapes.each |shape| { shape.draw(); }
}</code></pre>
<p>In this example, there is no type parameter. Instead, the <code>@Drawable</code> type denotes any managed box value that implements the <code>Drawable</code> trait. To construct such a value, you use the <code>as</code> operator to cast a value to an object:</p>
<pre><code># type Circle = int; type Rectangle = bool;
# trait Drawable { fn draw(&amp;self); }
# fn new_circle() -&gt; Circle { 1 }
# fn new_rectangle() -&gt; Rectangle { true }
# fn draw_all(shapes: &amp;[@Drawable]) {}

impl Drawable for Circle { fn draw(&amp;self) { ... } }
impl Drawable for Rectangle { fn draw(&amp;self) { ... } }

let c: @Circle = @new_circle();
let r: @Rectangle = @new_rectangle();
draw_all([c as @Drawable, r as @Drawable]);</code></pre>
<p>We omit the code for <code>new_circle</code> and <code>new_rectangle</code>; imagine that these just return <code>Circle</code>s and <code>Rectangle</code>s with a default size. Note that, like strings and vectors, objects have dynamic size and may only be referred to via one of the pointer types. Other pointer types work as well. Casts to traits may only be done with compatible pointers so, for example, an <code>@Circle</code> may not be cast to an <code>~Drawable</code>.</p>
<pre><code># type Circle = int; type Rectangle = int;
# trait Drawable { fn draw(&amp;self); }
# impl Drawable for int { fn draw(&amp;self) {} }
# fn new_circle() -&gt; int { 1 }
# fn new_rectangle() -&gt; int { 2 }
// A managed object
let boxy: @Drawable = @new_circle() as @Drawable;
// An owned object
let owny: ~Drawable = ~new_circle() as ~Drawable;
// A borrowed object
let stacky: &amp;Drawable = &amp;new_circle() as &amp;Drawable;</code></pre>
<p>Method calls to trait types are <em>dynamically dispatched</em>. Since the compiler doesn't know specifically which functions to call at compile time, it uses a lookup table (also known as a vtable or dictionary) to select the method to call at runtime.</p>
<p>This usage of traits is similar to Java interfaces.</p>
<h2 id="trait-inheritance"><a href="#TOC"><span class="header-section-number">16.5</span> Trait inheritance</a></h2>
<p>We can write a trait declaration that <em>inherits</em> from other traits, called <em>supertraits</em>. Types that implement a trait must also implement its supertraits. For example, we can define a <code>Circle</code> trait that inherits from <code>Shape</code>.</p>
<pre><code>trait Shape { fn area(&amp;self) -&gt; float; }
trait Circle : Shape { fn radius(&amp;self) -&gt; float; }</code></pre>
<p>Now, we can implement <code>Circle</code> on a type only if we also implement <code>Shape</code>.</p>
<pre><code># use core::float::consts::pi;
# use core::float::sqrt;
# trait Shape { fn area(&amp;self) -&gt; float; }
# trait Circle : Shape { fn radius(&amp;self) -&gt; float; }
# struct Point { x: float, y: float }
# fn square(x: float) -&gt; float { x * x }
struct CircleStruct { center: Point, radius: float }
impl Circle for CircleStruct {
    fn radius(&amp;self) -&gt; float { sqrt(self.area() / pi) }
}
impl Shape for CircleStruct {
    fn area(&amp;self) -&gt; float { pi * square(self.radius) }
}</code></pre>
<p>Notice that methods of <code>Circle</code> can call methods on <code>Shape</code>, as our <code>radius</code> implementation calls the <code>area</code> method. This is a silly way to compute the radius of a circle (since we could just return the <code>radius</code> field), but you get the idea.</p>
<p>In type-parameterized functions, methods of the supertrait may be called on values of subtrait-bound type parameters. Refering to the previous example of <code>trait Circle : Shape</code>:</p>
<pre><code># trait Shape { fn area(&amp;self) -&gt; float; }
# trait Circle : Shape { fn radius(&amp;self) -&gt; float; }
fn radius_times_area&lt;T: Circle&gt;(c: T) -&gt; float {
    // `c` is both a Circle and a Shape
    c.radius() * c.area()
}</code></pre>
<p>Likewise, supertrait methods may also be called on trait objects.</p>
<pre class="xfail-test"><code># use core::float::consts::pi;
# use core::float::sqrt;
# trait Shape { fn area(&amp;self) -&gt; float; }
# trait Circle : Shape { fn radius(&amp;self) -&gt; float; }
# struct Point { x: float, y: float }
# struct CircleStruct { center: Point, radius: float }
# impl Circle for CircleStruct { fn radius(&amp;self) -&gt; float { sqrt(self.area() / pi) } }
# impl Shape for CircleStruct { fn area(&amp;self) -&gt; float { pi * square(self.radius) } }

let concrete = @CircleStruct{center:Point{x:3f,y:4f},radius:5f};
let mycircle: Circle = concrete as @Circle;
let nonsense = mycircle.radius() * mycircle.area();</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> Trait inheritance does not actually work with objects yet</p>
</blockquote>
<h1 id="modules-and-crates"><a href="#TOC"><span class="header-section-number">17</span> Modules and crates</a></h1>
<p>The Rust namespace is arranged in a hierarchy of modules. Each source (.rs) file represents a single module and may in turn contain additional modules.</p>
<pre><code>mod farm {
    pub fn chicken() -&gt; &amp;str { &quot;cluck cluck&quot; }
    pub fn cow() -&gt; &amp;str { &quot;mooo&quot; }
}

fn main() {
    io::println(farm::chicken());
}</code></pre>
<p>The contents of modules can be imported into the current scope with the <code>use</code> keyword, optionally giving it an alias. <code>use</code> may appear at the beginning of crates, <code>mod</code>s, <code>fn</code>s, and other blocks.</p>
<pre><code># mod farm { pub fn chicken() { } }
# fn main() {
// Bring `chicken` into scope
use farm::chicken;

fn chicken_farmer() {
    // The same, but name it `my_chicken`
    use my_chicken = farm::chicken;
    ...
# my_chicken();
}
# chicken();
# }</code></pre>
<p>These farm animal functions have a new keyword, <code>pub</code>, attached to them. The <code>pub</code> keyword modifies an item's visibility, making it visible outside its containing module. An expression with <code>::</code>, like <code>farm::chicken</code>, can name an item outside of its containing module. Items, such as those declared with <code>fn</code>, <code>struct</code>, <code>enum</code>, <code>type</code>, or <code>static</code>, are module-private by default.</p>
<p>Visibility restrictions in Rust exist only at module boundaries. This is quite different from most object-oriented languages that also enforce restrictions on objects themselves. That's not to say that Rust doesn't support encapsulation: both struct fields and methods can be private. But this encapsulation is at the module level, not the struct level. Note that fields and methods are <em>public</em> by default.</p>
<pre><code>pub mod farm {
# pub type Chicken = int;
# type Cow = int;
# struct Human(int);
# impl Human { fn rest(&amp;self) { } }
# pub fn make_me_a_farm() -&gt; Farm { Farm { chickens: ~[], cows: ~[], farmer: Human(0) } }
    pub struct Farm {
        priv chickens: ~[Chicken],
        priv cows: ~[Cow],
        farmer: Human
    }

    impl Farm {
        priv fn feed_chickens(&amp;self) { ... }
        priv fn feed_cows(&amp;self) { ... }
        pub fn add_chicken(&amp;self, c: Chicken) { ... }
    }

    pub fn feed_animals(farm: &amp;Farm) {
        farm.feed_chickens();
        farm.feed_cows();
    }
}

fn main() {
     let f = make_me_a_farm();
     f.add_chicken(make_me_a_chicken());
     farm::feed_animals(&amp;f);
     f.farmer.rest();
}
# fn make_me_a_farm() -&gt; farm::Farm { farm::make_me_a_farm() }
# fn make_me_a_chicken() -&gt; farm::Chicken { 0 }</code></pre>
<h2 id="crates"><a href="#TOC"><span class="header-section-number">17.1</span> Crates</a></h2>
<p>The unit of independent compilation in Rust is the crate: rustc compiles a single crate at a time, from which it produces either a library or an executable.</p>
<p>When compiling a single <code>.rs</code> source file, the file acts as the whole crate. You can compile it with the <code>--lib</code> compiler switch to create a shared library, or without, provided that your file contains a <code>fn main</code> somewhere, to create an executable.</p>
<p>Larger crates typically span multiple files and are, by convention, compiled from a source file with the <code>.rc</code> extension, called a <em>crate file</em>. The crate file extension distinguishes source files that represent crates from those that do not, but otherwise source files and crate files are identical.</p>
<p>A typical crate file declares attributes associated with the crate that may affect how the compiler processes the source. Crate attributes specify metadata used for locating and linking crates, the type of crate (library or executable), and control warning and error behavior, among other things. Crate files additionally declare the external crates they depend on as well as any modules loaded from other files.</p>
<pre class="xfail-test"><code>// Crate linkage metadata
#[link(name = &quot;farm&quot;, vers = &quot;2.5&quot;, author = &quot;mjh&quot;)];

// Make a library (&quot;bin&quot; is the default)
#[crate_type = &quot;lib&quot;];

// Turn on a warning
#[warn(non_camel_case_types)]

// Link to the standard library
extern mod std;

// Load some modules from other files
mod cow;
mod chicken;
mod horse;

fn main() {
    ...
}</code></pre>
<p>Compiling this file will cause <code>rustc</code> to look for files named <code>cow.rs</code>, <code>chicken.rs</code>, and <code>horse.rs</code> in the same directory as the <code>.rc</code> file, compile them all together, and, based on the presence of the <code>crate_type = &quot;lib&quot;</code> attribute, output a shared library or an executable. (If the line <code>#[crate_type = &quot;lib&quot;];</code> was omitted, <code>rustc</code> would create an executable.)</p>
<p>The <code>#[link(...)]</code> attribute provides meta information about the module, which other crates can use to load the right module. More about that later.</p>
<p>To have a nested directory structure for your source files, you can nest mods:</p>
<pre class="ignore"><code>mod poultry {
    mod chicken;
    mod turkey;
}</code></pre>
<p>The compiler will now look for <code>poultry/chicken.rs</code> and <code>poultry/turkey.rs</code>, and export their content in <code>poultry::chicken</code> and <code>poultry::turkey</code>. You can also provide a <code>poultry.rs</code> to add content to the <code>poultry</code> module itself.</p>
<h2 id="using-other-crates"><a href="#TOC"><span class="header-section-number">17.2</span> Using other crates</a></h2>
<p>The <code>extern mod</code> directive lets you use a crate (once it's been compiled into a library) from inside another crate. <code>extern mod</code> can appear at the top of a crate file or at the top of modules. It will cause the compiler to look in the library search path (which you can extend with the <code>-L</code> switch) for a compiled Rust library with the right name, then add a module with that crate's name into the local scope.</p>
<p>For example, <code>extern mod std</code> links the <a href="std/index.html">standard library</a>.</p>
<p>When a comma-separated list of name/value pairs appears after <code>extern mod</code>, the compiler front-end matches these pairs against the attributes provided in the <code>link</code> attribute of the crate file. The front-end will only select this crate for use if the actual pairs match the declared attributes. You can provide a <code>name</code> value to override the name used to search for the crate.</p>
<p>Our example crate declared this set of <code>link</code> attributes:</p>
<pre><code>#[link(name = &quot;farm&quot;, vers = &quot;2.5&quot;, author = &quot;mjh&quot;)];</code></pre>
<p>Which you can then link with any (or all) of the following:</p>
<pre class="xfail-test"><code>extern mod farm;
extern mod my_farm (name = &quot;farm&quot;, vers = &quot;2.5&quot;);
extern mod my_auxiliary_farm (name = &quot;farm&quot;, author = &quot;mjh&quot;);</code></pre>
<p>If any of the requested metadata do not match, then the crate will not be compiled successfully.</p>
<h2 id="a-minimal-example"><a href="#TOC"><span class="header-section-number">17.3</span> A minimal example</a></h2>
<p>Now for something that you can actually compile yourself. We have these two files:</p>
<pre><code>// world.rs
#[link(name = &quot;world&quot;, vers = &quot;1.0&quot;)];
pub fn explore() -&gt; &amp;str { &quot;world&quot; }</code></pre>
<pre class="xfail-test"><code>// main.rs
extern mod world;
fn main() { io::println(~&quot;hello &quot; + world::explore()); }</code></pre>
<p>Now compile and run like this (adjust to your platform if necessary):</p>
<pre class="notrust"><code>&gt; rustc --lib world.rs  # compiles libworld-94839cbfe144198-1.0.so
&gt; rustc main.rs -L .    # compiles main
&gt; ./main
&quot;hello world&quot;</code></pre>
<p>Notice that the library produced contains the version in the filename as well as an inscrutable string of alphanumerics. These are both part of Rust's library versioning scheme. The alphanumerics are a hash representing the crate metadata.</p>
<h2 id="the-core-library"><a href="#TOC"><span class="header-section-number">17.4</span> The core library</a></h2>
<p>The Rust core library provides runtime features required by the language, including the task scheduler and memory allocators, as well as library support for Rust built-in types, platform abstractions, and other commonly used features.</p>
<p><a href="core/index.html"><code>core</code></a> includes modules corresponding to each of the integer types, each of the floating point types, the <a href="core/bool.html"><code>bool</code></a> type, <a href="core/tuple.html">tuples</a>, <a href="core/char.html">characters</a>, <a href="core/str.html">strings</a>, <a href="core/vec.html">vectors</a>, <a href="core/managed.html">managed boxes</a>, <a href="core/owned.html">owned boxes</a>, and unsafe and borrowed <a href="core/ptr.html">pointers</a>. Additionally, <code>core</code> provides some pervasive types (<a href="core/option.html"><code>option</code></a> and <a href="core/result.html"><code>result</code></a>), <a href="core/task.html">task</a> creation and <a href="core/comm.html">communication</a> primitives, platform abstractions (<a href="core/os.html"><code>os</code></a> and <a href="core/path.html"><code>path</code></a>), basic I/O abstractions (<a href="core/io.html"><code>io</code></a>), <a href="core/container.html">containers</a> like <a href="core/hashmap.html"><code>hashmap</code></a>, common traits (<a href="core/kinds.html"><code>kinds</code></a>, <a href="core/ops.html"><code>ops</code></a>, <a href="core/cmp.html"><code>cmp</code></a>, <a href="core/num.html"><code>num</code></a>, <a href="core/to_str.html"><code>to_str</code></a>, <a href="core/clone.html"><code>clone</code></a>), and complete bindings to the C standard library (<a href="core/libc.html"><code>libc</code></a>).</p>
<h3 id="core-injection-and-the-rust-prelude"><a href="#TOC"><span class="header-section-number">17.4.1</span> Core injection and the Rust prelude</a></h3>
<p><code>core</code> is imported at the topmost level of every crate by default, as if the first line of each crate was</p>
<pre><code>extern mod core;</code></pre>
<p>This means that the contents of core can be accessed from from any context with the <code>core::</code> path prefix, as in <code>use core::vec</code>, <code>use core::task::spawn</code>, etc.</p>
<p>Additionally, <code>core</code> contains a <code>prelude</code> module that reexports many of the most common core modules, types and traits. The contents of the prelude are imported into every <em>module</em> by default. Implicitly, all modules behave as if they contained the following prologue:</p>
<pre><code>use core::prelude::*;</code></pre>
<h1 id="what-next"><a href="#TOC"><span class="header-section-number">18</span> What next?</a></h1>
<p>Now that you know the essentials, check out any of the additional tutorials on individual topics.</p>
<ul>
<li><a href="tutorial-borrowed-ptr.html">Borrowed pointers</a></li>
<li><a href="tutorial-tasks.html">Tasks and communication</a></li>
<li><a href="tutorial-macros.html">Macros</a></li>
<li><a href="tutorial-ffi.html">The foreign function interface</a></li>
</ul>
<p>There is further documentation on the <a href="https://github.com/mozilla/rust/wiki/Docs">wiki</a>.</p>
</body>
</html>
