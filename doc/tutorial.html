<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Rust 언어 튜토리얼</title>
  <link rel="stylesheet" href="rust.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Rust 언어 튜토리얼</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#머리말"><span class="toc-section-number">1</span> 머리말</a><ul>
<li><a href="#범위"><span class="toc-section-number">1.1</span> 범위</a></li>
<li><a href="#관습"><span class="toc-section-number">1.2</span> 관습</a></li>
</ul></li>
<li><a href="#시작하기"><span class="toc-section-number">2</span> 시작하기</a><ul>
<li><a href="#자신의-첫-프로그램-컴파일하기"><span class="toc-section-number">2.1</span> 자신의 첫 프로그램 컴파일하기</a></li>
<li><a href="#rust-도구-사용하기"><span class="toc-section-number">2.2</span> rust 도구 사용하기</a></li>
<li><a href="#rust-코드-수정하기"><span class="toc-section-number">2.3</span> Rust 코드 수정하기</a></li>
</ul></li>
<li><a href="#기본-문법"><span class="toc-section-number">3</span> 기본 문법</a><ul>
<li><a href="#expressions-and-semicolons"><span class="toc-section-number">3.1</span> Expressions and semicolons</a></li>
<li><a href="#primitive-types-and-literals"><span class="toc-section-number">3.2</span> Primitive types and literals</a></li>
<li><a href="#operators"><span class="toc-section-number">3.3</span> Operators</a></li>
<li><a href="#syntax-extensions"><span class="toc-section-number">3.4</span> Syntax extensions</a></li>
</ul></li>
<li><a href="#control-structures"><span class="toc-section-number">4</span> Control structures</a><ul>
<li><a href="#conditionals"><span class="toc-section-number">4.1</span> Conditionals</a></li>
<li><a href="#pattern-matching"><span class="toc-section-number">4.2</span> Pattern matching</a></li>
<li><a href="#loops"><span class="toc-section-number">4.3</span> Loops</a></li>
</ul></li>
<li><a href="#data-structures"><span class="toc-section-number">5</span> Data structures</a><ul>
<li><a href="#structs"><span class="toc-section-number">5.1</span> Structs</a></li>
<li><a href="#enums"><span class="toc-section-number">5.2</span> Enums</a></li>
<li><a href="#tuples"><span class="toc-section-number">5.3</span> Tuples</a></li>
<li><a href="#tuple-structs"><span class="toc-section-number">5.4</span> Tuple structs</a></li>
</ul></li>
<li><a href="#functions"><span class="toc-section-number">6</span> Functions</a></li>
<li><a href="#destructors"><span class="toc-section-number">7</span> Destructors</a></li>
<li><a href="#ownership"><span class="toc-section-number">8</span> Ownership</a></li>
<li><a href="#boxes"><span class="toc-section-number">9</span> Boxes</a><ul>
<li><a href="#owned-boxes"><span class="toc-section-number">9.1</span> Owned boxes</a></li>
<li><a href="#managed-boxes"><span class="toc-section-number">9.2</span> Managed boxes</a></li>
</ul></li>
<li><a href="#move-semantics"><span class="toc-section-number">10</span> Move semantics</a></li>
<li><a href="#borrowed-pointers"><span class="toc-section-number">11</span> Borrowed pointers</a><ul>
<li><a href="#freezing"><span class="toc-section-number">11.1</span> Freezing</a></li>
</ul></li>
<li><a href="#dereferencing-pointers"><span class="toc-section-number">12</span> Dereferencing pointers</a></li>
<li><a href="#vectors-and-strings"><span class="toc-section-number">13</span> Vectors and strings</a></li>
<li><a href="#closures"><span class="toc-section-number">14</span> Closures</a><ul>
<li><a href="#managed-closures"><span class="toc-section-number">14.1</span> Managed closures</a></li>
<li><a href="#owned-closures"><span class="toc-section-number">14.2</span> Owned closures</a></li>
<li><a href="#closure-compatibility"><span class="toc-section-number">14.3</span> Closure compatibility</a></li>
<li><a href="#do-syntax"><span class="toc-section-number">14.4</span> Do syntax</a></li>
<li><a href="#for-loops"><span class="toc-section-number">14.5</span> For loops</a></li>
</ul></li>
<li><a href="#methods"><span class="toc-section-number">15</span> Methods</a></li>
<li><a href="#generics"><span class="toc-section-number">16</span> Generics</a><ul>
<li><a href="#traits"><span class="toc-section-number">16.1</span> Traits</a></li>
<li><a href="#declaring-and-implementing-traits"><span class="toc-section-number">16.2</span> Declaring and implementing traits</a></li>
<li><a href="#bounded-type-parameters-and-static-method-dispatch"><span class="toc-section-number">16.3</span> Bounded type parameters and static method dispatch</a></li>
<li><a href="#trait-objects-and-dynamic-method-dispatch"><span class="toc-section-number">16.4</span> Trait objects and dynamic method dispatch</a></li>
<li><a href="#trait-inheritance"><span class="toc-section-number">16.5</span> Trait inheritance</a></li>
</ul></li>
<li><a href="#modules-and-crates"><span class="toc-section-number">17</span> Modules and crates</a><ul>
<li><a href="#crates"><span class="toc-section-number">17.1</span> Crates</a></li>
<li><a href="#using-other-crates"><span class="toc-section-number">17.2</span> Using other crates</a></li>
<li><a href="#a-minimal-example"><span class="toc-section-number">17.3</span> A minimal example</a></li>
<li><a href="#the-core-library"><span class="toc-section-number">17.4</span> The core library</a><ul>
<li><a href="#core-injection-and-the-rust-prelude"><span class="toc-section-number">17.4.1</span> Core injection and the Rust prelude</a></li>
</ul></li>
</ul></li>
<li><a href="#what-next"><span class="toc-section-number">18</span> What next?</a></li>
</ul>
</div>
<h1 id="머리말"><a href="#TOC"><span class="header-section-number">1</span> 머리말</a></h1>
<p>Rust는 타입 안전성, 메모리 안전성, 동시성 그리고 성능에 초점을 맞춘 프로그래밍 언어이다. 몇 가지로 분류되는 일반적인 에러들로부터 자유로운 대규모, 고성능 소프트웨어를 작성하도록 계획되었다. Rust는 능률적인 데이터 구조를 장려하는 고수준의 메모리 모델과 세그멘테이션 오류를 일으키는 무효한 메모리 접근을 예방하는 안전한 동시성 패턴을 가지고 있다. 컴파일 시간에 타입이 정해진다.</p>
<p>다중 패러다임 언어로서, Rust는 절차형, 함수형 그리고 객체지향 스타일로 작성된 코드를 모두 지원한다. 또한 다음의 고수준의 기능들을 포함한다:</p>
<ul>
<li><strong>타입 추론</strong> 타입을 알려주는 지역 변수 선언은 선택적이다.</li>
<li><strong>안전한 태스크 기반의 동시성</strong> Rust의 가벼운 태스크들은 메모리를 공유하지 않는 대신 메시지를 통해 통신한다.</li>
<li><strong>고차(Higher-order) 함수</strong> 효율적이고 유연한 클로저는 반복과 제어 구조를 분리하여 제공한다.</li>
<li><strong>패턴 매칭과 대수적 자료구조</strong> Rust의 열거형(C의 열거형의 더 강력한 버전, 함수형 언어에서 대수적 자료구조와 비슷)에서 패턴 매칭은 프로그램 논리를 코드화하는 함축적이고 표현적인 방법이다.</li>
<li><strong>다형성</strong> Rust는 타입-인자의 함수와 타입, 타입 클래스 그리고 객체지향 스타일의 인터페이스를 가진다.</li>
</ul>
<h2 id="범위"><a href="#TOC"><span class="header-section-number">1.1</span> 범위</a></h2>
<p>이 문서는 Rust 프로그래밍 언어를 소개하는 튜토리얼이다. 문법, the 타입 시스템과 메모리 모델, 제너릭, 모듈을 포함한 언어의 기초를 다룬다. <a href="#what-next">Additional tutorials</a>은 언어에 특화된 기능을 더 깊이 다룬다.</p>
<p>이 튜토리얼은 독자가 하나 이상 의 C 계열의 언어에 이미 친숙하다고 가정한다. 포인터와 일반적인 메모리 관리 기법의 이해가 도움을 줄 것이다.</p>
<h2 id="관습"><a href="#TOC"><span class="header-section-number">1.2</span> 관습</a></h2>
<p>튜토리얼을 통해서, 예제 코드에서 정의되는 언어 키워드와 식별자는 <code>코드 글꼴</code>로 표시된다.</p>
<p>코드 조각은 들여쓰여지고, monospaced 글꼴로 보여진다. 모든 코드 조각들이 전체 프로그램을 구성하지는 않는다. 간결함을 위해, 컴파일되지 않는 프로그램의 일부분을 보여줄 것이다. 실행해보기 위해, <code>fn main() { ... }</code> 안에 넣어야할 것이다, 실제로 정의되지 않은 이름을 참조하는 것을 확인해야한다.</p>
<blockquote>
<p><strong><em>경고:</em></strong> Rust 계속 개발중인 언어이다. 언어의 잠재적인 변화, 구현 부족, 그리고 정지에 대해 알고있어야한다.</p>
</blockquote>
<h1 id="시작하기"><a href="#TOC"><span class="header-section-number">2</span> 시작하기</a></h1>
<p>현재 Rust 컴파일러는 <a href="http://static.rust-lang.org/dist/rust-0.6.tar.gz">tarball</a>로 제작되고, Windows의 경우는 <a href="http://static.rust-lang.org/dist/rust-0.6-install.exe">installer</a> 사용을 추천한다.</p>
<p>컴파일러는 Rust로 작성되었기에, 스스로 미리 컴파일된 &quot;snapshot&quot; 버전으로 만들어진다(개발 초기 단계에). 이처럼, 소스를 빌드하려면 스냅샷을 받아오기 위해 인터넷 연결과 유효한 스냅샷 바이너리를 실행할 수 있는 OS가 필요하다.</p>
<p>현재 스냅샷 바이너리는 아래의 플랫폼들에서 제작되고 테스트된다:</p>
<ul>
<li>Windows (7, Server 2008 R2), x86 only</li>
<li>Linux (various distributions), x86 and x86-64</li>
<li>OSX 10.6 (&quot;Snow Leopard&quot;) or greater, x86 and x86-64</li>
</ul>
<p>다른 플랫폼에서 작동하는 것을 찾을 수도 있지만, 선호되는 빌드 환경을 지원하는 것이 우선의 목표이다.</p>
<blockquote>
<p><strong><em>Note:</em></strong> 윈도우즈 사용자들은 위키에서 세부적인 <a href="https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust">getting started</a> 내용을 읽어야한다. 바이너리 인스톨러를 사용하더라도 윈도우즈에서 빌드하려면 MinGW 설치가 필요하다. 자세한 내용은 여기서 논의하지 않는다. 마지막으로, <code>rustc</code>는 <a href="https://github.com/mozilla/rust/issues/3319">referred to as <code>rustc.exe</code></a>를 알고 있어야한다. 기대에 어긋나는 것이라는 것은 알고있다.</p>
</blockquote>
<p>소스로부터 빌드하려면 사전에 필요한 패키지는 다음과 같다:</p>
<ul>
<li>g++ 4.4 or clang++ 3.x</li>
<li>python 2.6 or later (but not 3.x)</li>
<li>perl 5.0 or later</li>
<li>gnu make 3.81 or later</li>
<li>curl</li>
</ul>
<p>만약 충분히 필요 조건을 만족한다면, 다음의 명령들을 수행하면 된다.</p>
<pre class="notrust"><code>$ curl -O http://static.rust-lang.org/dist/rust-0.6.tar.gz
$ tar -xzf rust-0.6.tar.gz
$ cd rust-0.6
$ ./configure
$ make &amp;&amp; make install</code></pre>
<p>만약 목표 디렉토리를 수정할 권한을 가지고 있지 않다면 <code>sudo make install</code>을 사용해야 할 수도 있다. 설치 장소는 <code>configure</code> 명령의 인자로 <code>--prefix</code>를 전달하여 조정할 수 있다. 다양한 다른 옵션들도 지원되고 <code>--help</code> 인자를 통해 더 자세한 정보를 얻을 수 있습니다.</p>
<p><code>make install</code>이 성공적으로 완료되면 <code>/usr/local/bin</code> 디렉토리 내의 몇가지 프로그램을 볼 수 있을 것이다. <code>rustc</code>는 the Rust 컴파일러, <code>rustdoc</code>는 API-문서 도구, 그리고 <code>rustpkg</code>는 Rust 패키지 관리자 및 빌드 시스템, <code>rusti</code>는 Rust REPL, 그리고 <code>rust</code>는, 위 명령들의 통합된 인터페이스, 몇개의 공통의 명령행 시나리오로 동작하는 도구이다.</p>
<h2 id="자신의-첫-프로그램-컴파일하기"><a href="#TOC"><span class="header-section-number">2.1</span> 자신의 첫 프로그램 컴파일하기</a></h2>
<p>관습적으로 Rust 프로그램 파일은 <code>.rs</code>라는 확장자를 가진다. 아래의 프로그램을 가지는 <code>hello.rs</code> 파일을 만들어보자.</p>
<pre><code>fn main() {
    io::println(&quot;hello?&quot;);
}</code></pre>
<p>만약 Rust 컴파일러가 성공적으로 설치되었다면, <code>rustc hello.rs</code>라고 실행하면 <code>hello</code> 라는 실행파일이 생성되고(윈도우즈에서는 <code>hello.exe</code>), 실행하면 원하는 결과가 정확히 실행될 것이다.</p>
<p>The Rust 컴파일러는 에러가 발생한 경우 유용한 정보를 제공하려고 노력한다. 프로그램에 에러를 넣고(예를 들어, <code>io:println</code> 을 존재하지 않는 함수로 바꿔서) 컴파일을 하면, 아래와 비슷한 에러 메시지를 볼 수 있을 것이다.</p>
<pre class="notrust"><code>hello.rs:2:4: 2:16 error: unresolved name: io::print_with_unicorns
hello.rs:2     io::print_with_unicorns(&quot;hello?&quot;);
               ^~~~~~~~~~~~~~~~~~~~~~~</code></pre>
<p>최대한 단순화하면, Rust 프로그램은 몇 개의 타입과 함수를 가지고 있는 <code>.rs</code> 파일이다. 만약 <code>main</code> 함수를 가지고 있으면, 실행되도록 컴파일 될 수 있다. Rust는 파일의 최상위 레벨에서 선언된 코드를 허용하지 않는다. 모든 구문은 함수 안에 존재해야 한다. Rust 프로그램은 다른 프로그램에 포함되는 라이브러리로서 컴파일 될 수 있다.</p>
<h2 id="rust-도구-사용하기"><a href="#TOC"><span class="header-section-number">2.2</span> rust 도구 사용하기</a></h2>
<p>실행되는 것을 생성하기 위해 <code>rustc</code>를 직접적으로 사용하고, 수동으로 실행하는 것은 당신의 코드를 테스트하는 완전하고 유효한 방법이지만, 작은 프로젝트이거나 프로토타입이거나 당신이 초보자라면 <code>rust</code> 도구를 사용하는 것이 더 편리할 것이다.</p>
<p><code>rust</code> 도구는 나머지 rust 도구들로의 중앙집중적 접근 뿐만아니라 소스 파일을 바로 실행하기 위해 간편한 단축 명령을 제공한다. 예를 들어, 현재 디렉토리에 <code>foo.rs</code> 파일이 있다면, <code>rust run foo.rs</code> 명령은 컴파일을 시도할 것이고, 성공하면 결과로 생성된 바이너리를 바로 실행한다.</p>
<p>모든 가능한 명령의 목록을 얻으려면, 어떤 인자도 없이 단순히 <code>rust</code>만 호출하면 된다.</p>
<h2 id="rust-코드-수정하기"><a href="#TOC"><span class="header-section-number">2.3</span> Rust 코드 수정하기</a></h2>
<p>Rust 소스 배포판 <code>src/etc/vim/</code> 하위에 vim 하이라이트와 들여쓰기 스크립트가 있다. <code>src/etc/emacs/</code> 하위에 <code>rust-mode</code>라고 불리는 emacs 모드가 있지만, 디렉토리에 포함된 설명서를 꼭 읽어라. 특히, emacs 24에서 실행한다면, <code>rust-mode</code> 설치를 최신으로 유지하는 가장 쉬운 방법인 emacs 내부 패키지 관리자를 사용해라. 또한 Sublime Text 2를 위한 패키지는 <a href="http://github.com/dbp/sublime-rust">standalone</a>와 <a href="http://wbond.net/sublime_packages/package_control">Sublime Package Control</a>를 통해서 모두 가능하고, Kate를 위한 지원은 <code>src/etc/kate</code> 하위에 있다.</p>
<p><code>src/etc/ctags.rust</code>를 통해 ctags를 지원하지만, 많은 다른 도구들과 편집기들은 아직 지원하지 않는다. 당신이 가장 선호하는 편집기를 위한 Rust 모드가 작성이 완료되면, 우리에게 알려주면 링크를 걸어주겠다.</p>
<h1 id="기본-문법"><a href="#TOC"><span class="header-section-number">3</span> 기본 문법</a></h1>
<p>당신이 C계열의 언어(C++, Java, JavaScript, C#, or PHP)로 프로그래밍을 했다고 가정하면, Rust는 비슷하다고 느낄 것이다. 코드는 중괄호로 구분되는 블록들의 나열이다. <code>if</code>와 <code>while</code>과 비슷한 분기나 반복을 위한 제어 구조도 있다. 함수는 <code>myfunc(arg1, args2);</code>라고 호출한다. 연산자도 C와 같고 거의 동일한 우선순위를 가진다. 주석 또한 C와 같다. 모듈 이름은 C++ 처럼 더블 콜론(::)으로 구분된다.</p>
<p>인지되는 주된 표면적 차이는 <code>if</code>와 <code>while</code>과 같은 제어 구조의 머리에 있는 조건이 괄호가 필요없고, 몸통은 <em>무조건</em> 중괄호로 둘러싸야한다. 몸통에 문장이 하나일때, 중괄호를 하지않는 것은 허용되지 않는다.</p>
<pre><code># mod universe { pub fn recalibrate() -&gt; bool { true } }
fn main() {
    /* A simple loop */
    loop {
        // A tricky calculation
        if universe::recalibrate() {
            return;
        }
    }
}</code></pre>
<p><code>let</code> 키워드는 지역 변수를 나타낸다. 변수는 기본적으로 변하지 않는다. 나중에 재할당할 수 있는 지역 변수를 나타내기 위해, <code>let mut</code>를 사용한다.</p>
<pre><code>let hi = &quot;hi&quot;;
let mut count = 0;

while count &lt; 10 {
    io::println(fmt!(&quot;count: %?&quot;, count));
    count += 1;
}</code></pre>
<p>Rust는 지역 변수의 타입을 거의 항상 추론할 수 있지만, 콜론 다음에 타입의 이름을 적어줌으로써 변수의 타입을 명시해줄 수 있다. 반대로, 정적 아이템은 타입 주석이 항상 필요하다.</p>
<pre><code>static monster_factor: float = 57.8;
let monster_size = monster_factor * 10.0;
let monster_size: int = 50;</code></pre>
<p>앞의 예제에서 지역 변수는 shadow earlier 선언이다: 첫번째 <code>monster_size</code>는 <code>float</code>으로, 두번째 <code>monster_size</code>는 <code>int</code>로 선언되었다. 이 예제를 실제로 컴파일하더라도, 컴파일러는 첫번째 <code>monster_size</code>는 사용되지 않는다고 판단하고 경고를 표시할 것이다(이 상황은 프로그래머 오류를 발생시킬 가능성이 있기 때문이다). 사용되지 않는 변수가 의도적인 경우, 경고를 없애기 위해, <code>let _monster_size = 50;</code>처럼 이름을 밑줄로 시작하면 된다.</p>
<p>Rust 식별자는 알파벳 문자나 밑줄로 시작하고 그 이후로 알파벳 문자, 숫자, 밑줄의 나열된다. 선호되는 스타일은 함수, 변수, 그리고 모듈 이름은 가독성에 도움을 주기위해 밑줄이 포함된 소문자로 작성하고, 타입은 camel case로 작성한다.</p>
<pre><code>let my_variable = 100;
type MyType = int;     // 기본 타입은 camel case로 작성하지 않는다.</code></pre>
<h2 id="expressions-and-semicolons"><a href="#TOC"><span class="header-section-number">3.1</span> Expressions and semicolons</a></h2>
<p>Though it isn't apparent in all code, there is a fundamental difference between Rust's syntax and predecessors like C. Many constructs that are statements in C are expressions in Rust, allowing code to be more concise. For example, you might write a piece of code like this:</p>
<pre><code># let item = &quot;salad&quot;;
let price;
if item == &quot;salad&quot; {
    price = 3.50;
} else if item == &quot;muffin&quot; {
    price = 2.25;
} else {
    price = 2.00;
}</code></pre>
<p>But, in Rust, you don't have to repeat the name <code>price</code>:</p>
<pre><code># let item = &quot;salad&quot;;
let price =
    if item == &quot;salad&quot; {
        3.50
    } else if item == &quot;muffin&quot; {
        2.25
    } else {
        2.00
    };</code></pre>
<p>Both pieces of code are exactly equivalent: they assign a value to <code>price</code> depending on the condition that holds. Note that there are no semicolons in the blocks of the second snippet. This is important: the lack of a semicolon after the last statement in a braced block gives the whole block the value of that last expression.</p>
<p>Put another way, the semicolon in Rust <em>ignores the value of an expression</em>. Thus, if the branches of the <code>if</code> had looked like <code>{ 4; }</code>, the above example would simply assign <code>()</code> (nil or void) to <code>price</code>. But without the semicolon, each branch has a different value, and <code>price</code> gets the value of the branch that was taken.</p>
<p>In short, everything that's not a declaration (declarations are <code>let</code> for variables; <code>fn</code> for functions; and any top-level named items such as <a href="#traits">traits</a>, <a href="#enums">enum types</a>, and <a href="#constants">constants</a>) is an expression, including function bodies.</p>
<pre><code>fn is_four(x: int) -&gt; bool {
   // No need for a return statement. The result of the expression
   // is used as the return value.
   x == 4
}</code></pre>
<h2 id="primitive-types-and-literals"><a href="#TOC"><span class="header-section-number">3.2</span> Primitive types and literals</a></h2>
<p>There are general signed and unsigned integer types, <code>int</code> and <code>uint</code>, as well as 8-, 16-, 32-, and 64-bit variants, <code>i8</code>, <code>u16</code>, etc. Integers can be written in decimal (<code>144</code>), hexadecimal (<code>0x90</code>), or binary (<code>0b10010000</code>) base. Each integral type has a corresponding literal suffix that can be used to indicate the type of a literal: <code>i</code> for <code>int</code>, <code>u</code> for <code>uint</code>, <code>i8</code> for the <code>i8</code> type.</p>
<p>In the absence of an integer literal suffix, Rust will infer the integer type based on type annotations and function signatures in the surrounding program. In the absence of any type information at all, Rust will assume that an unsuffixed integer literal has type <code>int</code>.</p>
<pre><code>let a = 1;       // a is an int
let b = 10i;     // b is an int, due to the &#39;i&#39; suffix
let c = 100u;    // c is a uint
let d = 1000i32; // d is an i32</code></pre>
<p>There are three floating-point types: <code>float</code>, <code>f32</code>, and <code>f64</code>. Floating-point numbers are written <code>0.0</code>, <code>1e6</code>, or <code>2.1e-4</code>. Like integers, floating-point literals are inferred to the correct type. Suffixes <code>f</code>, <code>f32</code>, and <code>f64</code> can be used to create literals of a specific type.</p>
<p>The keywords <code>true</code> and <code>false</code> produce literals of type <code>bool</code>.</p>
<p>Characters, the <code>char</code> type, are four-byte Unicode codepoints, whose literals are written between single quotes, as in <code>'x'</code>. Just like C, Rust understands a number of character escapes, using the backslash character, such as <code>\n</code>, <code>\r</code>, and <code>\t</code>. String literals, written between double quotes, allow the same escape sequences. More on strings <a href="#vectors-and-strings">later</a>.</p>
<p>The nil type, written <code>()</code>, has a single value, also written <code>()</code>.</p>
<h2 id="operators"><a href="#TOC"><span class="header-section-number">3.3</span> Operators</a></h2>
<p>Rust's set of operators contains very few surprises. Arithmetic is done with <code>*</code>, <code>/</code>, <code>%</code>, <code>+</code>, and <code>-</code> (multiply, quotient, remainder, add, and subtract). <code>-</code> is also a unary prefix operator that negates numbers. As in C, the bitwise operators <code>&gt;&gt;</code>, <code>&lt;&lt;</code>, <code>&amp;</code>, <code>|</code>, and <code>^</code> are also supported.</p>
<p>Note that, if applied to an integer value, <code>!</code> flips all the bits (like <code>~</code> in C).</p>
<p>The comparison operators are the traditional <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>. Short-circuiting (lazy) boolean operators are written <code>&amp;&amp;</code> (and) and <code>||</code> (or).</p>
<p>For type casting, Rust uses the binary <code>as</code> operator. It takes an expression on the left side and a type on the right side and will, if a meaningful conversion exists, convert the result of the expression to the given type.</p>
<pre><code>let x: float = 4.0;
let y: uint = x as uint;
assert!(y == 4u);</code></pre>
<h2 id="syntax-extensions"><a href="#TOC"><span class="header-section-number">3.4</span> Syntax extensions</a></h2>
<p><em>Syntax extensions</em> are special forms that are not built into the language, but are instead provided by the libraries. To make it clear to the reader when a name refers to a syntax extension, the names of all syntax extensions end with <code>!</code>. The standard library defines a few syntax extensions, the most useful of which is <code>fmt!</code>, a <code>sprintf</code>-style text formatter that you will often see in examples.</p>
<p><code>fmt!</code> supports most of the directives that <a href="http://en.cppreference.com/w/cpp/io/c/fprintf">printf</a> supports, but unlike printf, will give you a compile-time error when the types of the directives don't match the types of the arguments.</p>
<pre><code># let mystery_object = ();

io::println(fmt!(&quot;%s is %d&quot;, &quot;the answer&quot;, 43));

// %? will conveniently print any type
io::println(fmt!(&quot;what is this thing: %?&quot;, mystery_object));</code></pre>
<p>You can define your own syntax extensions with the macro system. For details, see the <a href="tutorial-macros.html">macro tutorial</a>.</p>
<h1 id="control-structures"><a href="#TOC"><span class="header-section-number">4</span> Control structures</a></h1>
<h2 id="conditionals"><a href="#TOC"><span class="header-section-number">4.1</span> Conditionals</a></h2>
<p>We've seen <code>if</code> expressions a few times already. To recap, braces are compulsory, an <code>if</code> can have an optional <code>else</code> clause, and multiple <code>if</code>/<code>else</code> constructs can be chained together:</p>
<pre><code>if false {
    io::println(&quot;that&#39;s odd&quot;);
} else if true {
    io::println(&quot;right&quot;);
} else {
    io::println(&quot;neither true nor false&quot;);
}</code></pre>
<p>The condition given to an <code>if</code> construct <em>must</em> be of type <code>bool</code> (no implicit conversion happens). If the arms are blocks that have a value, this value must be of the same type for every arm in which control reaches the end of the block:</p>
<pre><code>fn signum(x: int) -&gt; int {
    if x &lt; 0 { -1 }
    else if x &gt; 0 { 1 }
    else { return 0 }
}</code></pre>
<h2 id="pattern-matching"><a href="#TOC"><span class="header-section-number">4.2</span> Pattern matching</a></h2>
<p>Rust's <code>match</code> construct is a generalized, cleaned-up version of C's <code>switch</code> construct. You provide it with a value and a number of <em>arms</em>, each labelled with a pattern, and the code compares the value against each pattern in order until one matches. The matching pattern executes its corresponding arm.</p>
<pre><code># let my_number = 1;
match my_number {
  0     =&gt; io::println(&quot;zero&quot;),
  1 | 2 =&gt; io::println(&quot;one or two&quot;),
  3..10 =&gt; io::println(&quot;three to ten&quot;),
  _     =&gt; io::println(&quot;something else&quot;)
}</code></pre>
<p>Unlike in C, there is no &quot;falling through&quot; between arms: only one arm executes, and it doesn't have to explicitly <code>break</code> out of the construct when it is finished.</p>
<p>A <code>match</code> arm consists of a <em>pattern</em>, then an arrow <code>=&gt;</code>, followed by an <em>action</em> (expression). Literals are valid patterns and match only their own value. A single arm may match multiple different patterns by combining them with the pipe operator (<code>|</code>), so long as every pattern binds the same set of variables. Ranges of numeric literal patterns can be expressed with two dots, as in <code>M..N</code>. The underscore (<code>_</code>) is a wildcard pattern that matches any single value. The asterisk (<code>*</code>) is a different wildcard that can match one or more fields in an <code>enum</code> variant.</p>
<p>The patterns in a match arm are followed by a fat arrow, <code>=&gt;</code>, then an expression to evaluate. Each case is separated by commas. It's often convenient to use a block expression for each case, in which case the commas are optional.</p>
<pre><code># let my_number = 1;
match my_number {
  0 =&gt; { io::println(&quot;zero&quot;) }
  _ =&gt; { io::println(&quot;something else&quot;) }
}</code></pre>
<p><code>match</code> constructs must be <em>exhaustive</em>: they must have an arm covering every possible case. For example, the typechecker would reject the previous example if the arm with the wildcard pattern was omitted.</p>
<p>A powerful application of pattern matching is <em>destructuring</em>: matching in order to bind names to the contents of data types.</p>
<blockquote>
<p><strong><em>Note:</em></strong> The following code makes use of tuples (<code>(float, float)</code>) which are explained in section 5.3. For now you can think of tuples as a list of items.</p>
</blockquote>
<pre><code>fn angle(vector: (float, float)) -&gt; float {
    let pi = float::consts::pi;
    match vector {
      (0f, y) if y &lt; 0f =&gt; 1.5 * pi,
      (0f, y) =&gt; 0.5 * pi,
      (x, y) =&gt; float::atan(y / x)
    }
}</code></pre>
<p>A variable name in a pattern matches any value, <em>and</em> binds that name to the value of the matched value inside of the arm's action. Thus, <code>(0f, y)</code> matches any tuple whose first element is zero, and binds <code>y</code> to the second element. <code>(x, y)</code> matches any two-element tuple, and binds both elements to variables.</p>
<p>Any <code>match</code> arm can have a guard clause (written <code>if EXPR</code>), called a <em>pattern guard</em>, which is an expression of type <code>bool</code> that determines, after the pattern is found to match, whether the arm is taken or not. The variables bound by the pattern are in scope in this guard expression. The first arm in the <code>angle</code> example shows an example of a pattern guard.</p>
<p>You've already seen simple <code>let</code> bindings, but <code>let</code> is a little fancier than you've been led to believe. It, too, supports destructuring patterns. For example, you can write this to extract the fields from a tuple, introducing two variables at once: <code>a</code> and <code>b</code>.</p>
<pre><code># fn get_tuple_of_two_ints() -&gt; (int, int) { (1, 1) }
let (a, b) = get_tuple_of_two_ints();</code></pre>
<p>Let bindings only work with <em>irrefutable</em> patterns: that is, patterns that can never fail to match. This excludes <code>let</code> from matching literals and most <code>enum</code> variants.</p>
<h2 id="loops"><a href="#TOC"><span class="header-section-number">4.3</span> Loops</a></h2>
<p><code>while</code> denotes a loop that iterates as long as its given condition (which must have type <code>bool</code>) evaluates to <code>true</code>. Inside a loop, the keyword <code>break</code> aborts the loop, and <code>loop</code> aborts the current iteration and continues with the next.</p>
<pre><code>let mut cake_amount = 8;
while cake_amount &gt; 0 {
    cake_amount -= 1;
}</code></pre>
<p><code>loop</code> denotes an infinite loop, and is the preferred way of writing <code>while true</code>:</p>
<pre><code>let mut x = 5;
loop {
    x += x - 3;
    if x % 5 == 0 { break; }
    io::println(int::to_str(x));
}</code></pre>
<p>This code prints out a weird sequence of numbers and stops as soon as it finds one that can be divided by five.</p>
<p>For more involved iteration, such as enumerating the elements of a collection, Rust uses <a href="#closures">higher-order functions</a>.</p>
<h1 id="data-structures"><a href="#TOC"><span class="header-section-number">5</span> Data structures</a></h1>
<h2 id="structs"><a href="#TOC"><span class="header-section-number">5.1</span> Structs</a></h2>
<p>Rust struct types must be declared before they are used using the <code>struct</code> syntax: <code>struct Name { field1: T1, field2: T2 [, ...] }</code>, where <code>T1</code>, <code>T2</code>, ... denote types. To construct a struct, use the same syntax, but leave off the <code>struct</code>: for example: <code>Point { x: 1.0, y: 2.0 }</code>.</p>
<p>Structs are quite similar to C structs and are even laid out the same way in memory (so you can read from a Rust struct in C, and vice-versa). Use the dot operator to access struct fields, as in <code>mypoint.x</code>.</p>
<pre><code>struct Point {
    x: float,
    y: float
}</code></pre>
<p>Inherited mutability means that any field of a struct may be mutable, if the struct is in a mutable slot (or a field of a struct in a mutable slot, and so forth).</p>
<p>With a value (say, <code>mypoint</code>) of such a type in a mutable location, you can do <code>mypoint.y += 1.0</code>. But in an immutable location, such an assignment to a struct without inherited mutability would result in a type error.</p>
<pre class="xfail-test"><code># struct Point { x: float, y: float }
let mut mypoint = Point { x: 1.0, y: 1.0 };
let origin = Point { x: 0.0, y: 0.0 };

mypoint.y += 1.0; // mypoint is mutable, and its fields as well
origin.y += 1.0; // ERROR: assigning to immutable field</code></pre>
<p><code>match</code> patterns destructure structs. The basic syntax is <code>Name { fieldname: pattern, ... }</code>:</p>
<pre><code># struct Point { x: float, y: float }
# let mypoint = Point { x: 0.0, y: 0.0 };
match mypoint {
    Point { x: 0.0, y: yy } =&gt; { io::println(yy.to_str());                     }
    Point { x: xx,  y: yy } =&gt; { io::println(xx.to_str() + &quot; &quot; + yy.to_str()); }
}</code></pre>
<p>In general, the field names of a struct do not have to appear in the same order they appear in the type. When you are not interested in all the fields of a struct, a struct pattern may end with <code>, _</code> (as in <code>Name { field1, _ }</code>) to indicate that you're ignoring all other fields. Additionally, struct fields have a shorthand matching form that simply reuses the field name as the binding name.</p>
<pre><code># struct Point { x: float, y: float }
# let mypoint = Point { x: 0.0, y: 0.0 };
match mypoint {
    Point { x, _ } =&gt; { io::println(x.to_str()) }
}</code></pre>
<h2 id="enums"><a href="#TOC"><span class="header-section-number">5.2</span> Enums</a></h2>
<p>Enums are datatypes that have several alternate representations. For example, consider the type shown earlier:</p>
<pre><code># struct Point { x: float, y: float }
enum Shape {
    Circle(Point, float),
    Rectangle(Point, Point)
}</code></pre>
<p>A value of this type is either a <code>Circle</code>, in which case it contains a <code>Point</code> struct and a float, or a <code>Rectangle</code>, in which case it contains two <code>Point</code> structs. The run-time representation of such a value includes an identifier of the actual form that it holds, much like the &quot;tagged union&quot; pattern in C, but with better static guarantees.</p>
<p>The above declaration will define a type <code>Shape</code> that can refer to such shapes, and two functions, <code>Circle</code> and <code>Rectangle</code>, which can be used to construct values of the type (taking arguments of the specified types). So <code>Circle(Point { x: 0f, y: 0f }, 10f)</code> is the way to create a new circle.</p>
<p>Enum variants need not have parameters. This <code>enum</code> declaration, for example, is equivalent to a C enum:</p>
<pre><code>enum Direction {
    North,
    East,
    South,
    West
}</code></pre>
<p>This declaration defines <code>North</code>, <code>East</code>, <code>South</code>, and <code>West</code> as constants, all of which have type <code>Direction</code>.</p>
<p>When an enum is C-like (that is, when none of the variants have parameters), it is possible to explicitly set the discriminator values to a constant value:</p>
<pre><code>enum Color {
  Red = 0xff0000,
  Green = 0x00ff00,
  Blue = 0x0000ff
}</code></pre>
<p>If an explicit discriminator is not specified for a variant, the value defaults to the value of the previous variant plus one. If the first variant does not have a discriminator, it defaults to 0. For example, the value of <code>North</code> is 0, <code>East</code> is 1, <code>South</code> is 2, and <code>West</code> is 3.</p>
<p>When an enum is C-like, you can apply the <code>as</code> cast operator to convert it to its discriminator value as an <code>int</code>.</p>
<p>For enum types with multiple variants, destructuring is the only way to get at their contents. All variant constructors can be used as patterns, as in this definition of <code>area</code>:</p>
<pre><code># struct Point {x: float, y: float}
# enum Shape { Circle(Point, float), Rectangle(Point, Point) }
fn area(sh: Shape) -&gt; float {
    match sh {
        Circle(_, size) =&gt; float::consts::pi * size * size,
        Rectangle(Point { x, y }, Point { x: x2, y: y2 }) =&gt; (x2 - x) * (y2 - y)
    }
}</code></pre>
<p>You can write a lone <code>_</code> to ignore an individual field, and can ignore all fields of a variant like: <code>Circle(*)</code>. As in their introduction form, nullary enum patterns are written without parentheses.</p>
<pre><code># struct Point { x: float, y: float }
# enum Direction { North, East, South, West }
fn point_from_direction(dir: Direction) -&gt; Point {
    match dir {
        North =&gt; Point { x:  0f, y:  1f },
        East  =&gt; Point { x:  1f, y:  0f },
        South =&gt; Point { x:  0f, y: -1f },
        West  =&gt; Point { x: -1f, y:  0f }
    }
}</code></pre>
<p>Enum variants may also be structs. For example:</p>
<pre><code># use core::float;
# struct Point { x: float, y: float }
# fn square(x: float) -&gt; float { x * x }
enum Shape {
    Circle { center: Point, radius: float },
    Rectangle { top_left: Point, bottom_right: Point }
}
fn area(sh: Shape) -&gt; float {
    match sh {
        Circle { radius: radius, _ } =&gt; float::consts::pi * square(radius),
        Rectangle { top_left: top_left, bottom_right: bottom_right } =&gt; {
            (bottom_right.x - top_left.x) * (bottom_right.y - top_left.y)
        }
    }
}</code></pre>
<h2 id="tuples"><a href="#TOC"><span class="header-section-number">5.3</span> Tuples</a></h2>
<p>Tuples in Rust behave exactly like structs, except that their fields do not have names. Thus, you cannot access their fields with dot notation. Tuples can have any arity except for 0 (though you may consider unit, <code>()</code>, as the empty tuple if you like).</p>
<pre><code>let mytup: (int, int, float) = (10, 20, 30.0);
match mytup {
  (a, b, c) =&gt; info!(a + b + (c as int))
}</code></pre>
<h2 id="tuple-structs"><a href="#TOC"><span class="header-section-number">5.4</span> Tuple structs</a></h2>
<p>Rust also has <em>tuple structs</em>, which behave like both structs and tuples, except that, unlike tuples, tuple structs have names (so <code>Foo(1, 2)</code> has a different type from <code>Bar(1, 2)</code>), and tuple structs' <em>fields</em> do not have names.</p>
<p>For example: ~~~~ struct MyTup(int, int, float); let mytup: MyTup = MyTup(10, 20, 30.0); match mytup { MyTup(a, b, c) =&gt; info!(a + b + (c as int)) } ~~~~</p>
<a name="newtype"></a>
<p>There is a special case for tuple structs with a single field, which are sometimes called &quot;newtypes&quot; (after Haskell's &quot;newtype&quot; feature). These are used to define new types in such a way that the new name is not just a synonym for an existing type but is rather its own distinct type.</p>
<pre><code>struct GizmoId(int);</code></pre>
<p>For convenience, you can extract the contents of such a struct with the dereference (<code>*</code>) unary operator:</p>
<pre><code># struct GizmoId(int);
let my_gizmo_id: GizmoId = GizmoId(10);
let id_int: int = *my_gizmo_id;</code></pre>
<p>Types like this can be useful to differentiate between data that have the same type but must be used in different ways.</p>
<pre><code>struct Inches(int);
struct Centimeters(int);</code></pre>
<p>The above definitions allow for a simple way for programs to avoid confusing numbers that correspond to different units.</p>
<h1 id="functions"><a href="#TOC"><span class="header-section-number">6</span> Functions</a></h1>
<p>We've already seen several function definitions. Like all other static declarations, such as <code>type</code>, functions can be declared both at the top level and inside other functions (or in modules, which we'll come back to <a href="#modules-and-crates">later</a>). The <code>fn</code> keyword introduces a function. A function has an argument list, which is a parenthesized list of <code>expr: type</code> pairs separated by commas. An arrow <code>-&gt;</code> separates the argument list and the function's return type.</p>
<pre><code>fn line(a: int, b: int, x: int) -&gt; int {
    return a * x + b;
}</code></pre>
<p>The <code>return</code> keyword immediately returns from the body of a function. It is optionally followed by an expression to return. A function can also return a value by having its top-level block produce an expression.</p>
<pre><code>fn line(a: int, b: int, x: int) -&gt; int {
    a * x + b
}</code></pre>
<p>It's better Rust style to write a return value this way instead of writing an explicit <code>return</code>. The utility of <code>return</code> comes in when returning early from a function. Functions that do not return a value are said to return nil, <code>()</code>, and both the return type and the return value may be omitted from the definition. The following two functions are equivalent.</p>
<pre><code>fn do_nothing_the_hard_way() -&gt; () { return (); }

fn do_nothing_the_easy_way() { }</code></pre>
<p>Ending the function with a semicolon like so is equivalent to returning <code>()</code>.</p>
<pre><code>fn line(a: int, b: int, x: int) -&gt; int { a * x + b  }
fn oops(a: int, b: int, x: int) -&gt; ()  { a * x + b; }

assert!(8 == line(5, 3, 1));
assert!(() == oops(5, 3, 1));</code></pre>
<p>As with <code>match</code> expressions and <code>let</code> bindings, function arguments support pattern destructuring. Like <code>let</code>, argument patterns must be irrefutable, as in this example that unpacks the first value from a tuple and returns it.</p>
<pre><code>fn first((value, _): (int, float)) -&gt; int { value }</code></pre>
<h1 id="destructors"><a href="#TOC"><span class="header-section-number">7</span> Destructors</a></h1>
<p>A <em>destructor</em> is a function responsible for cleaning up the resources used by an object when it is no longer accessible. Destructors can be defined to handle the release of resources like files, sockets and heap memory.</p>
<p>Objects are never accessible after their destructor has been called, so there are no dynamic failures from accessing freed resources. When a task fails, the destructors of all objects in the task are called.</p>
<p>The <code>~</code> sigil represents a unique handle for a memory allocation on the heap:</p>
<pre><code>{
    // an integer allocated on the heap
    let y = ~10;
}
// the destructor frees the heap memory as soon as `y` goes out of scope</code></pre>
<p>Rust includes syntax for heap memory allocation in the language since it's commonly used, but the same semantics can be implemented by a type with a custom destructor.</p>
<h1 id="ownership"><a href="#TOC"><span class="header-section-number">8</span> Ownership</a></h1>
<p>Rust formalizes the concept of object ownership to delegate management of an object's lifetime to either a variable or a task-local garbage collector. An object's owner is responsible for managing the lifetime of the object by calling the destructor, and the owner determines whether the object is mutable.</p>
<p>Ownership is recursive, so mutability is inherited recursively and a destructor destroys the contained tree of owned objects. Variables are top-level owners and destroy the contained object when they go out of scope. A box managed by the garbage collector starts a new ownership tree, and the destructor is called when it is collected.</p>
<pre><code>// the struct owns the objects contained in the `x` and `y` fields
struct Foo { x: int, y: ~int }

{
    // `a` is the owner of the struct, and thus the owner of the struct&#39;s fields
    let a = Foo { x: 5, y: ~10 };
}
// when `a` goes out of scope, the destructor for the `~int` in the struct&#39;s
// field is called

// `b` is mutable, and the mutability is inherited by the objects it owns
let mut b = Foo { x: 5, y: ~10 };
b.x = 10;</code></pre>
<p>If an object doesn't contain garbage-collected boxes, it consists of a single ownership tree and is given the <code>Owned</code> trait which allows it to be sent between tasks. Custom destructors can only be implemented directly on types that are <code>Owned</code>, but garbage-collected boxes can still <em>contain</em> types with custom destructors.</p>
<h1 id="boxes"><a href="#TOC"><span class="header-section-number">9</span> Boxes</a></h1>
<p>Many modern languages represent values as pointers to heap memory by default. In contrast, Rust, like C and C++, represents such types directly. Another way to say this is that aggregate data in Rust are <em>unboxed</em>. This means that if you <code>let x = Point { x: 1f, y: 1f };</code>, you are creating a struct on the stack. If you then copy it into a data structure, you copy the entire struct, not just a pointer.</p>
<p>For small structs like <code>Point</code>, this is usually more efficient than allocating memory and indirecting through a pointer. But for big structs, or mutable state, it can be useful to have a single copy on the stack or on the heap, and refer to that through a pointer.</p>
<h2 id="owned-boxes"><a href="#TOC"><span class="header-section-number">9.1</span> Owned boxes</a></h2>
<p>An owned box (<code>~</code>) is a uniquely owned allocation on the heap. It inherits the mutability and lifetime of the owner as it would if there was no box:</p>
<pre><code>let x = 5; // immutable
let mut y = 5; // mutable
y += 2;

let x = ~5; // immutable
let mut y = ~5; // mutable
*y += 2; // the * operator is needed to access the contained value</code></pre>
<p>The purpose of an owned box is to add a layer of indirection in order to create recursive data structures or cheaply pass around an object larger than a pointer. Since an owned box has a unique owner, it can only be used to represent a tree data structure.</p>
<p>The following struct won't compile, because the lack of indirection would mean it has an infinite size:</p>
<pre class="xfail-test"><code>struct Foo {
    child: Option&lt;Foo&gt;
}</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> The <code>Option</code> type is an enum that represents an <em>optional</em> value. It's comparable to a nullable pointer in many other languages, but stores the contained value unboxed.</p>
</blockquote>
<p>Adding indirection with an owned pointer allocates the child outside of the struct on the heap, which makes it a finite size and won't result in a compile-time error:</p>
<pre><code>struct Foo {
    child: Option&lt;~Foo&gt;
}</code></pre>
<h2 id="managed-boxes"><a href="#TOC"><span class="header-section-number">9.2</span> Managed boxes</a></h2>
<p>A managed box (<code>@</code>) is a heap allocation with the lifetime managed by a task-local garbage collector. It will be destroyed at some point after there are no references left to the box, no later than the end of the task. Managed boxes lack an owner, so they start a new ownership tree and don't inherit mutability. They do own the contained object, and mutability is defined by the type of the shared box (<code>@</code> or <code>@mut</code>). An object containing a managed box is not <code>Owned</code>, and can't be sent between tasks.</p>
<pre><code>let a = @5; // immutable

let mut b = @5; // mutable variable, immutable box
b = @10;

let c = @mut 5; // immutable variable, mutable box
*c = 10;

let mut d = @mut 5; // mutable variable, mutable box
*d += 5;
d = @mut 15;</code></pre>
<p>A mutable variable and an immutable variable can refer to the same box, given that their types are compatible. Mutability of a box is a property of its type, however, so for example a mutable handle to an immutable box cannot be assigned a reference to a mutable box.</p>
<pre><code>let a = @1;     // immutable box
let b = @mut 2; // mutable box

let mut c : @int;       // declare a variable with type managed immutable int
let mut d : @mut int;   // and one of type managed mutable int

c = a;          // box type is the same, okay
d = b;          // box type is the same, okay</code></pre>
<pre class="xfail-test"><code>// but b cannot be assigned to c, or a to d
c = b;          // error</code></pre>
<h1 id="move-semantics"><a href="#TOC"><span class="header-section-number">10</span> Move semantics</a></h1>
<p>Rust uses a shallow copy for parameter passing, assignment and returning values from functions. A shallow copy is considered a move of ownership if the ownership tree of the copied value includes an owned box or a type with a custom destructor. After a value has been moved, it can no longer be used from the source location and will not be destroyed there.</p>
<pre><code>let x = ~5;
let y = x.clone(); // y is a newly allocated box
let z = x; // no new memory allocated, x can no longer be used</code></pre>
<p>Since in owned boxes mutability is a property of the owner, not the box, mutable boxes may become immutable when they are moved, and vice-versa.</p>
<pre><code>let r = ~13;
let mut s = r; // box becomes mutable
*s += 1;
let t = s; // box becomes immutable</code></pre>
<h1 id="borrowed-pointers"><a href="#TOC"><span class="header-section-number">11</span> Borrowed pointers</a></h1>
<p>Rust's borrowed pointers are a general purpose reference type. In contrast with owned boxes, where the holder of an owned box is the owner of the pointed-to memory, borrowed pointers never imply ownership. A pointer can be borrowed to any object, and the compiler verifies that it cannot outlive the lifetime of the object.</p>
<p>As an example, consider a simple struct type, <code>Point</code>:</p>
<pre><code>struct Point {
    x: float,
    y: float
}</code></pre>
<p>We can use this simple definition to allocate points in many different ways. For example, in this code, each of these three local variables contains a point, but allocated in a different location:</p>
<pre><code># struct Point { x: float, y: float }
let on_the_stack : Point  =  Point { x: 3.0, y: 4.0 };
let managed_box  : @Point = @Point { x: 5.0, y: 1.0 };
let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };</code></pre>
<p>Suppose we wanted to write a procedure that computed the distance between any two points, no matter where they were stored. For example, we might like to compute the distance between <code>on_the_stack</code> and <code>managed_box</code>, or between <code>managed_box</code> and <code>owned_box</code>. One option is to define a function that takes two arguments of type point—that is, it takes the points by value. But this will cause the points to be copied when we call the function. For points, this is probably not so bad, but often copies are expensive or, worse, if there are mutable fields, they can change the semantics of your program. So we’d like to define a function that takes the points by pointer. We can use borrowed pointers to do this:</p>
<pre><code># struct Point { x: float, y: float }
# fn sqrt(f: float) -&gt; float { 0f }
fn compute_distance(p1: &amp;Point, p2: &amp;Point) -&gt; float {
    let x_d = p1.x - p2.x;
    let y_d = p1.y - p2.y;
    sqrt(x_d * x_d + y_d * y_d)
}</code></pre>
<p>Now we can call <code>compute_distance()</code> in various ways:</p>
<pre><code># struct Point{ x: float, y: float };
# let on_the_stack : Point  =  Point { x: 3.0, y: 4.0 };
# let managed_box  : @Point = @Point { x: 5.0, y: 1.0 };
# let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };
# fn compute_distance(p1: &amp;Point, p2: &amp;Point) -&gt; float { 0f }
compute_distance(&amp;on_the_stack, managed_box);
compute_distance(managed_box, owned_box);</code></pre>
<p>Here the <code>&amp;</code> operator is used to take the address of the variable <code>on_the_stack</code>; this is because <code>on_the_stack</code> has the type <code>Point</code> (that is, a struct value) and we have to take its address to get a value. We also call this <em>borrowing</em> the local variable <code>on_the_stack</code>, because we are creating an alias: that is, another route to the same data.</p>
<p>In the case of the boxes <code>managed_box</code> and <code>owned_box</code>, however, no explicit action is necessary. The compiler will automatically convert a box like <code>@point</code> or <code>~point</code> to a borrowed pointer like <code>&amp;point</code>. This is another form of borrowing; in this case, the contents of the managed/owned box are being lent out.</p>
<p>Whenever a value is borrowed, there are some limitations on what you can do with the original. For example, if the contents of a variable have been lent out, you cannot send that variable to another task, nor will you be permitted to take actions that might cause the borrowed value to be freed or to change its type. This rule should make intuitive sense: you must wait for a borrowed value to be returned (that is, for the borrowed pointer to go out of scope) before you can make full use of it again.</p>
<p>For a more in-depth explanation of borrowed pointers, read the <a href="tutorial-borrowed-ptr.html">borrowed pointer tutorial</a>.</p>
<h2 id="freezing"><a href="#TOC"><span class="header-section-number">11.1</span> Freezing</a></h2>
<p>Borrowing an immutable pointer to an object freezes it and prevents mutation. <code>Owned</code> objects have freezing enforced statically at compile-time.</p>
<pre><code>let mut x = 5;
{
    let y = &amp;x; // x is now frozen, it cannot be modified
}
// x is now unfrozen again</code></pre>
<p>Mutable managed boxes handle freezing dynamically when any of their contents are borrowed, and the task will fail if an attempt to modify them is made while they are frozen:</p>
<pre><code>let x = @mut 5;
let y = x;
{
    let z = &amp;*y; // the managed box is now frozen
    // modifying it through x or y will cause a task failure
}
// the box is now unfrozen again</code></pre>
<h1 id="dereferencing-pointers"><a href="#TOC"><span class="header-section-number">12</span> Dereferencing pointers</a></h1>
<p>Rust uses the unary star operator (<code>*</code>) to access the contents of a box or pointer, similarly to C.</p>
<pre><code>let managed = @10;
let owned = ~20;
let borrowed = &amp;30;

let sum = *managed + *owned + *borrowed;</code></pre>
<p>Dereferenced mutable pointers may appear on the left hand side of assignments. Such an assignment modifies the value that the pointer points to.</p>
<pre><code>let managed = @mut 10;
let mut owned = ~20;

let mut value = 30;
let borrowed = &amp;mut value;

*managed = *owned + 10;
*owned = *borrowed + 100;
*borrowed = *managed + 1000;</code></pre>
<p>Pointers have high operator precedence, but lower precedence than the dot operator used for field and method access. This precedence order can sometimes make code awkward and parenthesis-filled.</p>
<pre><code># struct Point { x: float, y: float }
# enum Shape { Rectangle(Point, Point) }
# impl Shape { fn area(&amp;self) -&gt; int { 0 } }
let start = @Point { x: 10f, y: 20f };
let end = ~Point { x: (*start).x + 100f, y: (*start).y + 100f };
let rect = &amp;Rectangle(*start, *end);
let area = (*rect).area();</code></pre>
<p>To combat this ugliness the dot operator applies <em>automatic pointer dereferencing</em> to the receiver (the value on the left-hand side of the dot), so in most cases, explicitly dereferencing the receiver is not necessary.</p>
<pre><code># struct Point { x: float, y: float }
# enum Shape { Rectangle(Point, Point) }
# impl Shape { fn area(&amp;self) -&gt; int { 0 } }
let start = @Point { x: 10f, y: 20f };
let end = ~Point { x: start.x + 100f, y: start.y + 100f };
let rect = &amp;Rectangle(*start, *end);
let area = rect.area();</code></pre>
<p>You can write an expression that dereferences any number of pointers automatically. For example, if you felt inclined, you could write something silly like</p>
<pre><code># struct Point { x: float, y: float }
let point = &amp;@~Point { x: 10f, y: 20f };
io::println(fmt!(&quot;%f&quot;, point.x));</code></pre>
<p>The indexing operator (<code>[]</code>) also auto-dereferences.</p>
<h1 id="vectors-and-strings"><a href="#TOC"><span class="header-section-number">13</span> Vectors and strings</a></h1>
<p>A vector is a contiguous section of memory containing zero or more values of the same type. Like other types in Rust, vectors can be stored on the stack, the local heap, or the exchange heap. Borrowed pointers to vectors are also called 'slices'.</p>
<pre><code># enum Crayon {
#     Almond, AntiqueBrass, Apricot,
#     Aquamarine, Asparagus, AtomicTangerine,
#     BananaMania, Beaver, Bittersweet,
#     Black, BlizzardBlue, Blue
# }
// A fixed-size stack vector
let stack_crayons: [Crayon, ..3] = [Almond, AntiqueBrass, Apricot];

// A borrowed pointer to stack-allocated vector
let stack_crayons: &amp;[Crayon] = &amp;[Aquamarine, Asparagus, AtomicTangerine];

// A local heap (managed) vector of crayons
let local_crayons: @[Crayon] = @[BananaMania, Beaver, Bittersweet];

// An exchange heap (owned) vector of crayons
let exchange_crayons: ~[Crayon] = ~[Black, BlizzardBlue, Blue];</code></pre>
<p>The <code>+</code> operator means concatenation when applied to vector types.</p>
<pre><code># enum Crayon { Almond, AntiqueBrass, Apricot,
#               Aquamarine, Asparagus, AtomicTangerine,
#               BananaMania, Beaver, Bittersweet };

let my_crayons = ~[Almond, AntiqueBrass, Apricot];
let your_crayons = ~[BananaMania, Beaver, Bittersweet];

// Add two vectors to create a new one
let our_crayons = my_crayons + your_crayons;

// += will append to a vector, provided it lives in a mutable slot
let mut my_crayons = my_crayons;
my_crayons += your_crayons;</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> The above examples of vector addition use owned vectors. Some operations on slices and stack vectors are not yet well-supported. Owned vectors are often the most usable.</p>
</blockquote>
<p>Square brackets denote indexing into a vector:</p>
<pre><code># enum Crayon { Almond, AntiqueBrass, Apricot,
#               Aquamarine, Asparagus, AtomicTangerine,
#               BananaMania, Beaver, Bittersweet };
# fn draw_scene(c: Crayon) { }
let crayons: [Crayon, ..3] = [BananaMania, Beaver, Bittersweet];
match crayons[0] {
    Bittersweet =&gt; draw_scene(crayons[0]),
    _ =&gt; ()
}</code></pre>
<p>A vector can be destructured using pattern matching:</p>
<pre><code>let numbers: [int, ..3] = [1, 2, 3];
let score = match numbers {
    [] =&gt; 0,
    [a] =&gt; a * 10,
    [a, b] =&gt; a * 6 + b * 4,
    [a, b, c, ..rest] =&gt; a * 5 + b * 3 + c * 2 + rest.len() as int
};</code></pre>
<p>The elements of a vector <em>inherit the mutability of the vector</em>, and as such, individual elements may not be reassigned when the vector lives in an immutable slot.</p>
<pre class="xfail-test"><code># enum Crayon { Almond, AntiqueBrass, Apricot,
#               Aquamarine, Asparagus, AtomicTangerine,
#               BananaMania, Beaver, Bittersweet };
let crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];

crayons[0] = Apricot; // ERROR: Can&#39;t assign to immutable vector</code></pre>
<p>Moving it into a mutable slot makes the elements assignable.</p>
<pre><code># enum Crayon { Almond, AntiqueBrass, Apricot,
#               Aquamarine, Asparagus, AtomicTangerine,
#               BananaMania, Beaver, Bittersweet };
let crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];

// Put the vector into a mutable slot
let mut mutable_crayons = crayons;

// Now it&#39;s mutable to the bone
mutable_crayons[0] = Apricot;</code></pre>
<p>This is a simple example of Rust's <em>dual-mode data structures</em>, also referred to as <em>freezing and thawing</em>.</p>
<p>Strings are implemented with vectors of <code>u8</code>, though they have a distinct type. They support most of the same allocation options as vectors, though the string literal without a storage sigil (for example, <code>&quot;foo&quot;</code>) is treated differently than a comparable vector (<code>[foo]</code>). Whereas plain vectors are stack-allocated fixed-length vectors, plain strings are borrowed pointers to read-only (static) memory. All strings are immutable.</p>
<pre><code>// A plain string is a slice to read-only (static) memory
let stack_crayons: &amp;str = &quot;Almond, AntiqueBrass, Apricot&quot;;

// The same thing, but with the `&amp;`
let stack_crayons: &amp;str = &amp;&quot;Aquamarine, Asparagus, AtomicTangerine&quot;;

// A local heap (managed) string
let local_crayons: @str = @&quot;BananaMania, Beaver, Bittersweet&quot;;

// An exchange heap (owned) string
let exchange_crayons: ~str = ~&quot;Black, BlizzardBlue, Blue&quot;;</code></pre>
<p>Both vectors and strings support a number of useful <a href="#functions-and-methods">methods</a>, defined in <a href="core/vec.html"><code>core::vec</code></a> and <a href="core/str.html"><code>core::str</code></a>. Here are some examples.</p>
<pre><code># use core::io::println;
# enum Crayon {
#     Almond, AntiqueBrass, Apricot,
#     Aquamarine, Asparagus, AtomicTangerine,
#     BananaMania, Beaver, Bittersweet
# }
# fn unwrap_crayon(c: Crayon) -&gt; int { 0 }
# fn eat_crayon_wax(i: int) { }
# fn store_crayon_in_nasal_cavity(i: uint, c: Crayon) { }
# fn crayon_to_str(c: Crayon) -&gt; &amp;str { &quot;&quot; }

let crayons = [Almond, AntiqueBrass, Apricot];

// Check the length of the vector
assert!(crayons.len() == 3);
assert!(!crayons.is_empty());

// Iterate over a vector, obtaining a pointer to each element
for crayons.each |crayon| {
    let delicious_crayon_wax = unwrap_crayon(*crayon);
    eat_crayon_wax(delicious_crayon_wax);
}

// Map vector elements
let crayon_names = crayons.map(|v| crayon_to_str(*v));
let favorite_crayon_name = crayon_names[0];

// Remove whitespace from before and after the string
let new_favorite_crayon_name = favorite_crayon_name.trim();

if favorite_crayon_name.len() &gt; 5 {
   // Create a substring
   println(favorite_crayon_name.substr(0, 5));
}</code></pre>
<h1 id="closures"><a href="#TOC"><span class="header-section-number">14</span> Closures</a></h1>
<p>Named functions, like those we've seen so far, may not refer to local variables declared outside the function: they do not close over their environment (sometimes referred to as &quot;capturing&quot; variables in their environment). For example, you couldn't write the following:</p>
<pre class="ignore"><code>let foo = 10;

fn bar() -&gt; int {
   return foo; // `bar` cannot refer to `foo`
}</code></pre>
<p>Rust also supports <em>closures</em>, functions that can access variables in the enclosing scope.</p>
<pre><code># use println = core::io::println;
fn call_closure_with_ten(b: &amp;fn(int)) { b(10); }

let captured_var = 20;
let closure = |arg| println(fmt!(&quot;captured_var=%d, arg=%d&quot;, captured_var, arg));

call_closure_with_ten(closure);</code></pre>
<p>Closures begin with the argument list between vertical bars and are followed by a single expression. The types of the arguments are generally omitted, as is the return type, because the compiler can almost always infer them. In the rare case where the compiler needs assistance, though, the arguments and return types may be annotated.</p>
<pre><code>let square = |x: int| -&gt; uint { x * x as uint };</code></pre>
<p>There are several forms of closure, each with its own role. The most common, called a <em>stack closure</em>, has type <code>&amp;fn</code> and can directly access local variables in the enclosing scope.</p>
<pre><code>let mut max = 0;
[1, 2, 3].map(|x| if *x &gt; max { max = *x });</code></pre>
<p>Stack closures are very efficient because their environment is allocated on the call stack and refers by pointer to captured locals. To ensure that stack closures never outlive the local variables to which they refer, stack closures are not first-class. That is, they can only be used in argument position; they cannot be stored in data structures or returned from functions. Despite these limitations, stack closures are used pervasively in Rust code.</p>
<h2 id="managed-closures"><a href="#TOC"><span class="header-section-number">14.1</span> Managed closures</a></h2>
<p>When you need to store a closure in a data structure, a stack closure will not do, since the compiler will refuse to let you store it. For this purpose, Rust provides a type of closure that has an arbitrary lifetime, written <code>@fn</code> (boxed closure, analogous to the <code>@</code> pointer type described earlier). This type of closure <em>is</em> first-class.</p>
<p>A managed closure does not directly access its environment, but merely copies out the values that it closes over into a private data structure. This means that it can not assign to these variables, and cannot observe updates to them.</p>
<p>This code creates a closure that adds a given string to its argument, returns it from a function, and then calls it:</p>
<pre><code># extern mod std;
fn mk_appender(suffix: ~str) -&gt; @fn(~str) -&gt; ~str {
    // The compiler knows that we intend this closure to be of type @fn
    return |s| s + suffix;
}

fn main() {
    let shout = mk_appender(~&quot;!&quot;);
    io::println(shout(~&quot;hey ho, let&#39;s go&quot;));
}</code></pre>
<h2 id="owned-closures"><a href="#TOC"><span class="header-section-number">14.2</span> Owned closures</a></h2>
<p>Owned closures, written <code>~fn</code> in analogy to the <code>~</code> pointer type, hold on to things that can safely be sent between processes. They copy the values they close over, much like managed closures, but they also own them: that is, no other code can access them. Owned closures are used in concurrent code, particularly for spawning <a href="tutorial-tasks.html">tasks</a>.</p>
<h2 id="closure-compatibility"><a href="#TOC"><span class="header-section-number">14.3</span> Closure compatibility</a></h2>
<p>Rust closures have a convenient subtyping property: you can pass any kind of closure (as long as the arguments and return types match) to functions that expect a <code>&amp;fn()</code>. Thus, when writing a higher-order function that only calls its function argument, and does nothing else with it, you should almost always declare the type of that argument as <code>&amp;fn()</code>. That way, callers may pass any kind of closure.</p>
<pre><code>fn call_twice(f: &amp;fn()) { f(); f(); }
let closure = || { &quot;I&#39;m a closure, and it doesn&#39;t matter what type I am&quot;; };
fn function() { &quot;I&#39;m a normal function&quot;; }
call_twice(closure);
call_twice(function);</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> Both the syntax and the semantics will be changing in small ways. At the moment they can be unsound in some scenarios, particularly with non-copyable types.</p>
</blockquote>
<h2 id="do-syntax"><a href="#TOC"><span class="header-section-number">14.4</span> Do syntax</a></h2>
<p>The <code>do</code> expression provides a way to treat higher-order functions (functions that take closures as arguments) as control structures.</p>
<p>Consider this function that iterates over a vector of integers, passing in a pointer to each integer in the vector:</p>
<pre><code>fn each(v: &amp;[int], op: &amp;fn(v: &amp;int)) {
   let mut n = 0;
   while n &lt; v.len() {
       op(&amp;v[n]);
       n += 1;
   }
}</code></pre>
<p>As an aside, the reason we pass in a <em>pointer</em> to an integer rather than the integer itself is that this is how the actual <code>each()</code> function for vectors works. <code>vec::each</code> though is a <a href="#generics">generic</a> function, so must be efficient to use for all types. Passing the elements by pointer avoids copying potentially large objects.</p>
<p>As a caller, if we use a closure to provide the final operator argument, we can write it in a way that has a pleasant, block-like structure.</p>
<pre><code># fn each(v: &amp;[int], op: &amp;fn(v: &amp;int)) { }
# fn do_some_work(i: &amp;int) { }
each([1, 2, 3], |n| {
    do_some_work(n);
});</code></pre>
<p>This is such a useful pattern that Rust has a special form of function call that can be written more like a built-in control structure:</p>
<pre><code># fn each(v: &amp;[int], op: &amp;fn(v: &amp;int)) { }
# fn do_some_work(i: &amp;int) { }
do each([1, 2, 3]) |n| {
    do_some_work(n);
}</code></pre>
<p>The call is prefixed with the keyword <code>do</code> and, instead of writing the final closure inside the argument list, it appears outside of the parentheses, where it looks more like a typical block of code.</p>
<p><code>do</code> is a convenient way to create tasks with the <code>task::spawn</code> function. <code>spawn</code> has the signature <code>spawn(fn: ~fn())</code>. In other words, it is a function that takes an owned closure that takes no arguments.</p>
<pre><code>use core::task::spawn;

do spawn() || {
    debug!(&quot;I&#39;m a task, whatever&quot;);
}</code></pre>
<p>Look at all those bars and parentheses -- that's two empty argument lists back to back. Since that is so unsightly, empty argument lists may be omitted from <code>do</code> expressions.</p>
<pre><code># use core::task::spawn;
do spawn {
   debug!(&quot;Kablam!&quot;);
}</code></pre>
<p>If you want to see the output of <code>debug!</code> statements, you will need to turn on <code>debug!</code> logging. To enable <code>debug!</code> logging, set the RUST_LOG environment variable to the name of your crate, which, for a file named <code>foo.rs</code>, will be <code>foo</code> (e.g., with bash, <code>export RUST_LOG=foo</code>).</p>
<h2 id="for-loops"><a href="#TOC"><span class="header-section-number">14.5</span> For loops</a></h2>
<p>The most common way to express iteration in Rust is with a <code>for</code> loop. Like <code>do</code>, <code>for</code> is a nice syntax for describing control flow with closures. Additionally, within a <code>for</code> loop, <code>break</code>, <code>loop</code>, and <code>return</code> work just as they do with <code>while</code> and <code>loop</code>.</p>
<p>Consider again our <code>each</code> function, this time improved to break early when the iteratee returns <code>false</code>:</p>
<pre><code>fn each(v: &amp;[int], op: &amp;fn(v: &amp;int) -&gt; bool) {
   let mut n = 0;
   while n &lt; v.len() {
       if !op(&amp;v[n]) {
           break;
       }
       n += 1;
   }
}</code></pre>
<p>And using this function to iterate over a vector:</p>
<pre><code># use each = core::vec::each;
# use println = core::io::println;
each([2, 4, 8, 5, 16], |n| {
    if *n % 2 != 0 {
        println(&quot;found odd number!&quot;);
        false
    } else { true }
});</code></pre>
<p>With <code>for</code>, functions like <code>each</code> can be treated more like built-in looping structures. When calling <code>each</code> in a <code>for</code> loop, instead of returning <code>false</code> to break out of the loop, you just write <code>break</code>. To skip ahead to the next iteration, write <code>loop</code>.</p>
<pre><code># use each = core::vec::each;
# use println = core::io::println;
for each([2, 4, 8, 5, 16]) |n| {
    if *n % 2 != 0 {
        println(&quot;found odd number!&quot;);
        break;
    }
}</code></pre>
<p>As an added bonus, you can use the <code>return</code> keyword, which is not normally allowed in closures, in a block that appears as the body of a <code>for</code> loop: the meaning of <code>return</code> in such a block is to return from the enclosing function, not just the loop body.</p>
<pre><code># use each = core::vec::each;
fn contains(v: &amp;[int], elt: int) -&gt; bool {
    for each(v) |x| {
        if (*x == elt) { return true; }
    }
    false
}</code></pre>
<p>Notice that, because <code>each</code> passes each value by borrowed pointer, the iteratee needs to dereference it before using it. In these situations it can be convenient to lean on Rust's argument patterns to bind <code>x</code> to the actual value, not the pointer.</p>
<pre><code># use each = core::vec::each;
# fn contains(v: &amp;[int], elt: int) -&gt; bool {
    for each(v) |&amp;x| {
        if (x == elt) { return true; }
    }
#    false
# }</code></pre>
<p><code>for</code> syntax only works with stack closures.</p>
<blockquote>
<p><strong><em>Note:</em></strong> This is, essentially, a special loop protocol: the keywords <code>break</code>, <code>loop</code>, and <code>return</code> work, in varying degree, with <code>while</code>, <code>loop</code>, <code>do</code>, and <code>for</code> constructs.</p>
</blockquote>
<h1 id="methods"><a href="#TOC"><span class="header-section-number">15</span> Methods</a></h1>
<p>Methods are like functions except that they always begin with a special argument, called <code>self</code>, which has the type of the method's receiver. The <code>self</code> argument is like <code>this</code> in C++ and many other languages. Methods are called with dot notation, as in <code>my_vec.len()</code>.</p>
<p><em>Implementations</em>, written with the <code>impl</code> keyword, can define methods on most Rust types, including structs and enums. As an example, let's define a <code>draw</code> method on our <code>Shape</code> enum.</p>
<pre><code># fn draw_circle(p: Point, f: float) { }
# fn draw_rectangle(p: Point, p: Point) { }
struct Point {
    x: float,
    y: float
}

enum Shape {
    Circle(Point, float),
    Rectangle(Point, Point)
}

impl Shape {
    fn draw(&amp;self) {
        match *self {
            Circle(p, f) =&gt; draw_circle(p, f),
            Rectangle(p1, p2) =&gt; draw_rectangle(p1, p2)
        }
    }
}

let s = Circle(Point { x: 1f, y: 2f }, 3f);
s.draw();</code></pre>
<p>This defines an <em>implementation</em> for <code>Shape</code> containing a single method, <code>draw</code>. In most respects the <code>draw</code> method is defined like any other function, except for the name <code>self</code>.</p>
<p>The type of <code>self</code> is the type on which the method is implemented, or a pointer thereof. As an argument it is written either <code>self</code>, <code>&amp;self</code>, <code>@self</code>, or <code>~self</code>. A caller must in turn have a compatible pointer type to call the method.</p>
<pre><code># fn draw_circle(p: Point, f: float) { }
# fn draw_rectangle(p: Point, p: Point) { }
# struct Point { x: float, y: float }
# enum Shape {
#     Circle(Point, float),
#     Rectangle(Point, Point)
# }
impl Shape {
    fn draw_borrowed(&amp;self) { ... }
    fn draw_managed(@self) { ... }
    fn draw_owned(~self) { ... }
    fn draw_value(self) { ... }
}

let s = Circle(Point { x: 1f, y: 2f }, 3f);

(@s).draw_managed();
(~s).draw_owned();
(&amp;s).draw_borrowed();
s.draw_value();</code></pre>
<p>Methods typically take a borrowed pointer self type, so the compiler will go to great lengths to convert a callee to a borrowed pointer.</p>
<pre><code># fn draw_circle(p: Point, f: float) { }
# fn draw_rectangle(p: Point, p: Point) { }
# struct Point { x: float, y: float }
# enum Shape {
#     Circle(Point, float),
#     Rectangle(Point, Point)
# }
# impl Shape {
#    fn draw_borrowed(&amp;self) { ... }
#    fn draw_managed(@self) { ... }
#    fn draw_owned(~self) { ... }
#    fn draw_value(self) { ... }
# }
# let s = Circle(Point { x: 1f, y: 2f }, 3f);
// As with typical function arguments, managed and unique pointers
// are automatically converted to borrowed pointers

(@s).draw_borrowed();
(~s).draw_borrowed();

// Unlike typical function arguments, the self value will
// automatically be referenced ...
s.draw_borrowed();

// ... and dereferenced
(&amp; &amp;s).draw_borrowed();

// ... and dereferenced and borrowed
(&amp;@~s).draw_borrowed();</code></pre>
<p>Implementations may also define standalone (sometimes called &quot;static&quot;) methods. The absence of a <code>self</code> paramater distinguishes such methods. These methods are the preferred way to define constructor functions.</p>
<pre class="xfail-test"><code>impl Circle {
    fn area(&amp;self) -&gt; float { ... }
    fn new(area: float) -&gt; Circle { ... }
}</code></pre>
<p>To call such a method, just prefix it with the type name and a double colon:</p>
<pre><code># use core::float::consts::pi;
# use core::float::sqrt;
struct Circle { radius: float }
impl Circle {
    fn new(area: float) -&gt; Circle { Circle { radius: sqrt(area / pi) } }
}
let c = Circle::new(42.5);</code></pre>
<h1 id="generics"><a href="#TOC"><span class="header-section-number">16</span> Generics</a></h1>
<p>Throughout this tutorial, we've been defining functions that act only on specific data types. With type parameters we can also define functions whose arguments have generic types, and which can be invoked with a variety of types. Consider a generic <code>map</code> function, which takes a function <code>function</code> and a vector <code>vector</code> and returns a new vector consisting of the result of applying <code>function</code> to each element of <code>vector</code>:</p>
<pre><code>fn map&lt;T, U&gt;(vector: &amp;[T], function: &amp;fn(v: &amp;T) -&gt; U) -&gt; ~[U] {
    let mut accumulator = ~[];
    for vec::each(vector) |element| {
        accumulator.push(function(element));
    }
    return accumulator;
}</code></pre>
<p>When defined with type parameters, as denoted by <code>&lt;T, U&gt;</code>, this function can be applied to any type of vector, as long as the type of <code>function</code>'s argument and the type of the vector's contents agree with each other.</p>
<p>Inside a generic function, the names of the type parameters (capitalized by convention) stand for opaque types. All you can do with instances of these types is pass them around: you can't apply any operations to them or pattern-match on them. Note that instances of generic types are often passed by pointer. For example, the parameter <code>function()</code> is supplied with a pointer to a value of type <code>T</code> and not a value of type <code>T</code> itself. This ensures that the function works with the broadest set of types possible, since some types are expensive or illegal to copy and pass by value.</p>
<p>Generic <code>type</code>, <code>struct</code>, and <code>enum</code> declarations follow the same pattern:</p>
<pre><code># use core::hashmap::HashMap;
type Set&lt;T&gt; = HashMap&lt;T, ()&gt;;

struct Stack&lt;T&gt; {
    elements: ~[T]
}

enum Option&lt;T&gt; {
    Some(T),
    None
}</code></pre>
<p>These declarations can be instantiated to valid types like <code>Set&lt;int&gt;</code>, <code>Stack&lt;int&gt;</code>, and <code>Option&lt;int&gt;</code>.</p>
<p>The last type in that example, <code>Option</code>, appears frequently in Rust code. Because Rust does not have null pointers (except in unsafe code), we need another way to write a function whose result isn't defined on every possible combination of arguments of the appropriate types. The usual way is to write a function that returns <code>Option&lt;T&gt;</code> instead of <code>T</code>.</p>
<pre><code># struct Point { x: float, y: float }
# enum Shape { Circle(Point, float), Rectangle(Point, Point) }
fn radius(shape: Shape) -&gt; Option&lt;float&gt; {
    match shape {
        Circle(_, radius) =&gt; Some(radius),
        Rectangle(*)      =&gt; None
    }
}</code></pre>
<p>The Rust compiler compiles generic functions very efficiently by <em>monomorphizing</em> them. <em>Monomorphization</em> is a fancy name for a simple idea: generate a separate copy of each generic function at each call site, a copy that is specialized to the argument types and can thus be optimized specifically for them. In this respect, Rust's generics have similar performance characteristics to C++ templates.</p>
<h2 id="traits"><a href="#TOC"><span class="header-section-number">16.1</span> Traits</a></h2>
<p>Within a generic function the operations available on generic types are very limited. After all, since the function doesn't know what types it is operating on, it can't safely modify or query their values. This is where <em>traits</em> come into play. Traits are Rust's most powerful tool for writing polymorphic code. Java developers will see them as similar to Java interfaces, and Haskellers will notice their similarities to type classes. Rust's traits are a form of <em>bounded polymorphism</em>: a trait is a way of limiting the set of possible types that a type parameter could refer to.</p>
<p>As motivation, let us consider copying in Rust. The <code>copy</code> operation is not defined for all Rust types. One reason is user-defined destructors: copying a type that has a destructor could result in the destructor running multiple times. Therefore, types with user-defined destructors cannot be copied, either implicitly or explicitly, and neither can types that own other types containing destructors.</p>
<p>This complicates handling of generic functions. If you have a type parameter <code>T</code>, can you copy values of that type? In Rust, you can't, and if you try to run the following code the compiler will complain.</p>
<pre class="xfail-test"><code>// This does not compile
fn head_bad&lt;T&gt;(v: &amp;[T]) -&gt; T {
    v[0] // error: copying a non-copyable value
}</code></pre>
<p>However, we can tell the compiler that the <code>head</code> function is only for copyable types: that is, those that have the <code>Copy</code> trait.</p>
<pre><code>// This does
fn head&lt;T: Copy&gt;(v: &amp;[T]) -&gt; T {
    v[0]
}</code></pre>
<p>This says that we can call <code>head</code> on any type <code>T</code> as long as that type implements the <code>Copy</code> trait. When instantiating a generic function, you can only instantiate it with types that implement the correct trait, so you could not apply <code>head</code> to a type with a destructor. (<code>Copy</code> is a special trait that is built in to the compiler, making it possible for the compiler to enforce this restriction.)</p>
<p>While most traits can be defined and implemented by user code, three traits are automatically derived and implemented for all applicable types by the compiler, and may not be overridden:</p>
<ul>
<li><p><code>Copy</code> - Types that can be copied, either implicitly, or explicitly with the <code>copy</code> operator. All types are copyable unless they have destructors or contain types with destructors.</p></li>
<li><p><code>Owned</code> - Owned types. Types are owned unless they contain managed boxes, managed closures, or borrowed pointers. Owned types may or may not be copyable.</p></li>
<li><p><code>Const</code> - Constant (immutable) types. These are types that do not contain mutable fields.</p></li>
</ul>
<blockquote>
<p><strong><em>Note:</em></strong> These three traits were referred to as 'kinds' in earlier iterations of the language, and often still are.</p>
</blockquote>
<p>Additionally, the <code>Drop</code> trait is used to define destructors. This trait defines one method called <code>finalize</code>, which is automatically called when a value of the type that implements this trait is destroyed, either because the value went out of scope or because the garbage collector reclaimed it.</p>
<pre><code>struct TimeBomb {
    explosivity: uint
}

impl Drop for TimeBomb {
    fn finalize(&amp;self) {
        for old_iter::repeat(self.explosivity) {
            io::println(&quot;blam!&quot;);
        }
    }
}</code></pre>
<p>It is illegal to call <code>finalize</code> directly. Only code inserted by the compiler may call it.</p>
<h2 id="declaring-and-implementing-traits"><a href="#TOC"><span class="header-section-number">16.2</span> Declaring and implementing traits</a></h2>
<p>A trait consists of a set of methods, without bodies, or may be empty, as is the case with <code>Copy</code>, <code>Owned</code>, and <code>Const</code>. For example, we could declare the trait <code>Printable</code> for things that can be printed to the console, with a single method:</p>
<pre><code>trait Printable {
    fn print(&amp;self);
}</code></pre>
<p>Traits may be implemented for specific types with <a href="#functions-and-methods">impls</a>. An impl that implements a trait includes the name of the trait at the start of the definition, as in the following impls of <code>Printable</code> for <code>int</code> and <code>~str</code>.</p>
<pre><code># trait Printable { fn print(&amp;self); }
impl Printable for int {
    fn print(&amp;self) { io::println(fmt!(&quot;%d&quot;, *self)) }
}

impl Printable for ~str {
    fn print(&amp;self) { io::println(*self) }
}

# 1.print();
# (~&quot;foo&quot;).print();</code></pre>
<p>Methods defined in an implementation of a trait may be called just like any other method, using dot notation, as in <code>1.print()</code>. Traits may themselves contain type parameters. A trait for generalized sequence types might look like the following:</p>
<pre><code>trait Seq&lt;T&gt; {
    fn len(&amp;self) -&gt; uint;
    fn iter(&amp;self, b: &amp;fn(v: &amp;T));
}

impl&lt;T&gt; Seq&lt;T&gt; for ~[T] {
    fn len(&amp;self) -&gt; uint { vec::len(*self) }
    fn iter(&amp;self, b: &amp;fn(v: &amp;T)) {
        for vec::each(*self) |elt| { b(elt); }
    }
}</code></pre>
<p>The implementation has to explicitly declare the type parameter that it binds, <code>T</code>, before using it to specify its trait type. Rust requires this declaration because the <code>impl</code> could also, for example, specify an implementation of <code>Seq&lt;int&gt;</code>. The trait type (appearing between <code>impl</code> and <code>for</code>) <em>refers</em> to a type, rather than defining one.</p>
<p>The type parameters bound by a trait are in scope in each of the method declarations. So, re-declaring the type parameter <code>T</code> as an explicit type parameter for <code>len</code>, in either the trait or the impl, would be a compile-time error.</p>
<p>Within a trait definition, <code>Self</code> is a special type that you can think of as a type parameter. An implementation of the trait for any given type <code>T</code> replaces the <code>Self</code> type parameter with <code>T</code>. The following trait describes types that support an equality operation:</p>
<pre><code>// In a trait, `self` refers to the self argument.
// `Self` refers to the type implementing the trait.
trait Eq {
    fn equals(&amp;self, other: &amp;Self) -&gt; bool;
}

// In an impl, `self` refers just to the value of the receiver
impl Eq for int {
    fn equals(&amp;self, other: &amp;int) -&gt; bool { *other == *self }
}</code></pre>
<p>Notice that in the trait definition, <code>equals</code> takes a second parameter of type <code>Self</code>. In contrast, in the <code>impl</code>, <code>equals</code> takes a second parameter of type <code>int</code>, only using <code>self</code> as the name of the receiver.</p>
<p>Just as in type implementations, traits can define standalone (static) methods. These methods are called by prefixing the method name with the trait name and a double colon. The compiler uses type inference to decide which implementation to use.</p>
<pre><code># use core::float::consts::pi;
# use core::float::sqrt;
trait Shape { fn new(area: float) -&gt; Self; }
struct Circle { radius: float }
struct Square { length: float }

impl Shape for Circle {
    fn new(area: float) -&gt; Circle { Circle { radius: sqrt(area / pi) } }
}
impl Shape for Square {
    fn new(area: float) -&gt; Square { Square { length: sqrt(area) } }
}

let area = 42.5;
let c: Circle = Shape::new(area);
let s: Square = Shape::new(area);</code></pre>
<h2 id="bounded-type-parameters-and-static-method-dispatch"><a href="#TOC"><span class="header-section-number">16.3</span> Bounded type parameters and static method dispatch</a></h2>
<p>Traits give us a language for defining predicates on types, or abstract properties that types can have. We can use this language to define <em>bounds</em> on type parameters, so that we can then operate on generic types.</p>
<pre><code># trait Printable { fn print(&amp;self); }
fn print_all&lt;T: Printable&gt;(printable_things: ~[T]) {
    for printable_things.each |thing| {
        thing.print();
    }
}</code></pre>
<p>Declaring <code>T</code> as conforming to the <code>Printable</code> trait (as we earlier did with <code>Copy</code>) makes it possible to call methods from that trait on values of type <code>T</code> inside the function. It will also cause a compile-time error when anyone tries to call <code>print_all</code> on an array whose element type does not have a <code>Printable</code> implementation.</p>
<p>Type parameters can have multiple bounds by separating them with <code>+</code>, as in this version of <code>print_all</code> that copies elements.</p>
<pre><code># trait Printable { fn print(&amp;self); }
fn print_all&lt;T: Printable + Copy&gt;(printable_things: ~[T]) {
    let mut i = 0;
    while i &lt; printable_things.len() {
        let copy_of_thing = printable_things[i];
        copy_of_thing.print();
        i += 1;
    }
}</code></pre>
<p>Method calls to bounded type parameters are <em>statically dispatched</em>, imposing no more overhead than normal function invocation, so are the preferred way to use traits polymorphically.</p>
<p>This usage of traits is similar to Haskell type classes.</p>
<h2 id="trait-objects-and-dynamic-method-dispatch"><a href="#TOC"><span class="header-section-number">16.4</span> Trait objects and dynamic method dispatch</a></h2>
<p>The above allows us to define functions that polymorphically act on values of a single unknown type that conforms to a given trait. However, consider this function:</p>
<pre><code># type Circle = int; type Rectangle = int;
# impl Drawable for int { fn draw(&amp;self) {} }
# fn new_circle() -&gt; int { 1 }
trait Drawable { fn draw(&amp;self); }

fn draw_all&lt;T: Drawable&gt;(shapes: ~[T]) {
    for shapes.each |shape| { shape.draw(); }
}
# let c: Circle = new_circle();
# draw_all(~[c]);</code></pre>
<p>You can call that on an array of circles, or an array of rectangles (assuming those have suitable <code>Drawable</code> traits defined), but not on an array containing both circles and rectangles. When such behavior is needed, a trait name can alternately be used as a type, called an <em>object</em>.</p>
<pre><code># trait Drawable { fn draw(&amp;self); }
fn draw_all(shapes: &amp;[@Drawable]) {
    for shapes.each |shape| { shape.draw(); }
}</code></pre>
<p>In this example, there is no type parameter. Instead, the <code>@Drawable</code> type denotes any managed box value that implements the <code>Drawable</code> trait. To construct such a value, you use the <code>as</code> operator to cast a value to an object:</p>
<pre><code># type Circle = int; type Rectangle = bool;
# trait Drawable { fn draw(&amp;self); }
# fn new_circle() -&gt; Circle { 1 }
# fn new_rectangle() -&gt; Rectangle { true }
# fn draw_all(shapes: &amp;[@Drawable]) {}

impl Drawable for Circle { fn draw(&amp;self) { ... } }
impl Drawable for Rectangle { fn draw(&amp;self) { ... } }

let c: @Circle = @new_circle();
let r: @Rectangle = @new_rectangle();
draw_all([c as @Drawable, r as @Drawable]);</code></pre>
<p>We omit the code for <code>new_circle</code> and <code>new_rectangle</code>; imagine that these just return <code>Circle</code>s and <code>Rectangle</code>s with a default size. Note that, like strings and vectors, objects have dynamic size and may only be referred to via one of the pointer types. Other pointer types work as well. Casts to traits may only be done with compatible pointers so, for example, an <code>@Circle</code> may not be cast to an <code>~Drawable</code>.</p>
<pre><code># type Circle = int; type Rectangle = int;
# trait Drawable { fn draw(&amp;self); }
# impl Drawable for int { fn draw(&amp;self) {} }
# fn new_circle() -&gt; int { 1 }
# fn new_rectangle() -&gt; int { 2 }
// A managed object
let boxy: @Drawable = @new_circle() as @Drawable;
// An owned object
let owny: ~Drawable = ~new_circle() as ~Drawable;
// A borrowed object
let stacky: &amp;Drawable = &amp;new_circle() as &amp;Drawable;</code></pre>
<p>Method calls to trait types are <em>dynamically dispatched</em>. Since the compiler doesn't know specifically which functions to call at compile time, it uses a lookup table (also known as a vtable or dictionary) to select the method to call at runtime.</p>
<p>This usage of traits is similar to Java interfaces.</p>
<h2 id="trait-inheritance"><a href="#TOC"><span class="header-section-number">16.5</span> Trait inheritance</a></h2>
<p>We can write a trait declaration that <em>inherits</em> from other traits, called <em>supertraits</em>. Types that implement a trait must also implement its supertraits. For example, we can define a <code>Circle</code> trait that inherits from <code>Shape</code>.</p>
<pre><code>trait Shape { fn area(&amp;self) -&gt; float; }
trait Circle : Shape { fn radius(&amp;self) -&gt; float; }</code></pre>
<p>Now, we can implement <code>Circle</code> on a type only if we also implement <code>Shape</code>.</p>
<pre><code># use core::float::consts::pi;
# use core::float::sqrt;
# trait Shape { fn area(&amp;self) -&gt; float; }
# trait Circle : Shape { fn radius(&amp;self) -&gt; float; }
# struct Point { x: float, y: float }
# fn square(x: float) -&gt; float { x * x }
struct CircleStruct { center: Point, radius: float }
impl Circle for CircleStruct {
    fn radius(&amp;self) -&gt; float { sqrt(self.area() / pi) }
}
impl Shape for CircleStruct {
    fn area(&amp;self) -&gt; float { pi * square(self.radius) }
}</code></pre>
<p>Notice that methods of <code>Circle</code> can call methods on <code>Shape</code>, as our <code>radius</code> implementation calls the <code>area</code> method. This is a silly way to compute the radius of a circle (since we could just return the <code>radius</code> field), but you get the idea.</p>
<p>In type-parameterized functions, methods of the supertrait may be called on values of subtrait-bound type parameters. Refering to the previous example of <code>trait Circle : Shape</code>:</p>
<pre><code># trait Shape { fn area(&amp;self) -&gt; float; }
# trait Circle : Shape { fn radius(&amp;self) -&gt; float; }
fn radius_times_area&lt;T: Circle&gt;(c: T) -&gt; float {
    // `c` is both a Circle and a Shape
    c.radius() * c.area()
}</code></pre>
<p>Likewise, supertrait methods may also be called on trait objects.</p>
<pre class="xfail-test"><code># use core::float::consts::pi;
# use core::float::sqrt;
# trait Shape { fn area(&amp;self) -&gt; float; }
# trait Circle : Shape { fn radius(&amp;self) -&gt; float; }
# struct Point { x: float, y: float }
# struct CircleStruct { center: Point, radius: float }
# impl Circle for CircleStruct { fn radius(&amp;self) -&gt; float { sqrt(self.area() / pi) } }
# impl Shape for CircleStruct { fn area(&amp;self) -&gt; float { pi * square(self.radius) } }

let concrete = @CircleStruct{center:Point{x:3f,y:4f},radius:5f};
let mycircle: Circle = concrete as @Circle;
let nonsense = mycircle.radius() * mycircle.area();</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> Trait inheritance does not actually work with objects yet</p>
</blockquote>
<h1 id="modules-and-crates"><a href="#TOC"><span class="header-section-number">17</span> Modules and crates</a></h1>
<p>The Rust namespace is arranged in a hierarchy of modules. Each source (.rs) file represents a single module and may in turn contain additional modules.</p>
<pre><code>mod farm {
    pub fn chicken() -&gt; &amp;str { &quot;cluck cluck&quot; }
    pub fn cow() -&gt; &amp;str { &quot;mooo&quot; }
}

fn main() {
    io::println(farm::chicken());
}</code></pre>
<p>The contents of modules can be imported into the current scope with the <code>use</code> keyword, optionally giving it an alias. <code>use</code> may appear at the beginning of crates, <code>mod</code>s, <code>fn</code>s, and other blocks.</p>
<pre><code># mod farm { pub fn chicken() { } }
# fn main() {
// Bring `chicken` into scope
use farm::chicken;

fn chicken_farmer() {
    // The same, but name it `my_chicken`
    use my_chicken = farm::chicken;
    ...
# my_chicken();
}
# chicken();
# }</code></pre>
<p>These farm animal functions have a new keyword, <code>pub</code>, attached to them. The <code>pub</code> keyword modifies an item's visibility, making it visible outside its containing module. An expression with <code>::</code>, like <code>farm::chicken</code>, can name an item outside of its containing module. Items, such as those declared with <code>fn</code>, <code>struct</code>, <code>enum</code>, <code>type</code>, or <code>static</code>, are module-private by default.</p>
<p>Visibility restrictions in Rust exist only at module boundaries. This is quite different from most object-oriented languages that also enforce restrictions on objects themselves. That's not to say that Rust doesn't support encapsulation: both struct fields and methods can be private. But this encapsulation is at the module level, not the struct level. Note that fields and methods are <em>public</em> by default.</p>
<pre><code>pub mod farm {
# pub type Chicken = int;
# type Cow = int;
# struct Human(int);
# impl Human { fn rest(&amp;self) { } }
# pub fn make_me_a_farm() -&gt; Farm { Farm { chickens: ~[], cows: ~[], farmer: Human(0) } }
    pub struct Farm {
        priv chickens: ~[Chicken],
        priv cows: ~[Cow],
        farmer: Human
    }

    impl Farm {
        priv fn feed_chickens(&amp;self) { ... }
        priv fn feed_cows(&amp;self) { ... }
        pub fn add_chicken(&amp;self, c: Chicken) { ... }
    }

    pub fn feed_animals(farm: &amp;Farm) {
        farm.feed_chickens();
        farm.feed_cows();
    }
}

fn main() {
     let f = make_me_a_farm();
     f.add_chicken(make_me_a_chicken());
     farm::feed_animals(&amp;f);
     f.farmer.rest();
}
# fn make_me_a_farm() -&gt; farm::Farm { farm::make_me_a_farm() }
# fn make_me_a_chicken() -&gt; farm::Chicken { 0 }</code></pre>
<h2 id="crates"><a href="#TOC"><span class="header-section-number">17.1</span> Crates</a></h2>
<p>The unit of independent compilation in Rust is the crate: rustc compiles a single crate at a time, from which it produces either a library or an executable.</p>
<p>When compiling a single <code>.rs</code> source file, the file acts as the whole crate. You can compile it with the <code>--lib</code> compiler switch to create a shared library, or without, provided that your file contains a <code>fn main</code> somewhere, to create an executable.</p>
<p>Larger crates typically span multiple files and are, by convention, compiled from a source file with the <code>.rc</code> extension, called a <em>crate file</em>. The crate file extension distinguishes source files that represent crates from those that do not, but otherwise source files and crate files are identical.</p>
<p>A typical crate file declares attributes associated with the crate that may affect how the compiler processes the source. Crate attributes specify metadata used for locating and linking crates, the type of crate (library or executable), and control warning and error behavior, among other things. Crate files additionally declare the external crates they depend on as well as any modules loaded from other files.</p>
<pre class="xfail-test"><code>// Crate linkage metadata
#[link(name = &quot;farm&quot;, vers = &quot;2.5&quot;, author = &quot;mjh&quot;)];

// Make a library (&quot;bin&quot; is the default)
#[crate_type = &quot;lib&quot;];

// Turn on a warning
#[warn(non_camel_case_types)]

// Link to the standard library
extern mod std;

// Load some modules from other files
mod cow;
mod chicken;
mod horse;

fn main() {
    ...
}</code></pre>
<p>Compiling this file will cause <code>rustc</code> to look for files named <code>cow.rs</code>, <code>chicken.rs</code>, and <code>horse.rs</code> in the same directory as the <code>.rc</code> file, compile them all together, and, based on the presence of the <code>crate_type = &quot;lib&quot;</code> attribute, output a shared library or an executable. (If the line <code>#[crate_type = &quot;lib&quot;];</code> was omitted, <code>rustc</code> would create an executable.)</p>
<p>The <code>#[link(...)]</code> attribute provides meta information about the module, which other crates can use to load the right module. More about that later.</p>
<p>To have a nested directory structure for your source files, you can nest mods:</p>
<pre class="ignore"><code>mod poultry {
    mod chicken;
    mod turkey;
}</code></pre>
<p>The compiler will now look for <code>poultry/chicken.rs</code> and <code>poultry/turkey.rs</code>, and export their content in <code>poultry::chicken</code> and <code>poultry::turkey</code>. You can also provide a <code>poultry.rs</code> to add content to the <code>poultry</code> module itself.</p>
<h2 id="using-other-crates"><a href="#TOC"><span class="header-section-number">17.2</span> Using other crates</a></h2>
<p>The <code>extern mod</code> directive lets you use a crate (once it's been compiled into a library) from inside another crate. <code>extern mod</code> can appear at the top of a crate file or at the top of modules. It will cause the compiler to look in the library search path (which you can extend with the <code>-L</code> switch) for a compiled Rust library with the right name, then add a module with that crate's name into the local scope.</p>
<p>For example, <code>extern mod std</code> links the <a href="std/index.html">standard library</a>.</p>
<p>When a comma-separated list of name/value pairs appears after <code>extern mod</code>, the compiler front-end matches these pairs against the attributes provided in the <code>link</code> attribute of the crate file. The front-end will only select this crate for use if the actual pairs match the declared attributes. You can provide a <code>name</code> value to override the name used to search for the crate.</p>
<p>Our example crate declared this set of <code>link</code> attributes:</p>
<pre><code>#[link(name = &quot;farm&quot;, vers = &quot;2.5&quot;, author = &quot;mjh&quot;)];</code></pre>
<p>Which you can then link with any (or all) of the following:</p>
<pre class="xfail-test"><code>extern mod farm;
extern mod my_farm (name = &quot;farm&quot;, vers = &quot;2.5&quot;);
extern mod my_auxiliary_farm (name = &quot;farm&quot;, author = &quot;mjh&quot;);</code></pre>
<p>If any of the requested metadata do not match, then the crate will not be compiled successfully.</p>
<h2 id="a-minimal-example"><a href="#TOC"><span class="header-section-number">17.3</span> A minimal example</a></h2>
<p>Now for something that you can actually compile yourself. We have these two files:</p>
<pre><code>// world.rs
#[link(name = &quot;world&quot;, vers = &quot;1.0&quot;)];
pub fn explore() -&gt; &amp;str { &quot;world&quot; }</code></pre>
<pre class="xfail-test"><code>// main.rs
extern mod world;
fn main() { io::println(~&quot;hello &quot; + world::explore()); }</code></pre>
<p>Now compile and run like this (adjust to your platform if necessary):</p>
<pre class="notrust"><code>&gt; rustc --lib world.rs  # compiles libworld-94839cbfe144198-1.0.so
&gt; rustc main.rs -L .    # compiles main
&gt; ./main
&quot;hello world&quot;</code></pre>
<p>Notice that the library produced contains the version in the filename as well as an inscrutable string of alphanumerics. These are both part of Rust's library versioning scheme. The alphanumerics are a hash representing the crate metadata.</p>
<h2 id="the-core-library"><a href="#TOC"><span class="header-section-number">17.4</span> The core library</a></h2>
<p>The Rust core library provides runtime features required by the language, including the task scheduler and memory allocators, as well as library support for Rust built-in types, platform abstractions, and other commonly used features.</p>
<p><a href="core/index.html"><code>core</code></a> includes modules corresponding to each of the integer types, each of the floating point types, the <a href="core/bool.html"><code>bool</code></a> type, <a href="core/tuple.html">tuples</a>, <a href="core/char.html">characters</a>, <a href="core/str.html">strings</a>, <a href="core/vec.html">vectors</a>, <a href="core/managed.html">managed boxes</a>, <a href="core/owned.html">owned boxes</a>, and unsafe and borrowed <a href="core/ptr.html">pointers</a>. Additionally, <code>core</code> provides some pervasive types (<a href="core/option.html"><code>option</code></a> and <a href="core/result.html"><code>result</code></a>), <a href="core/task.html">task</a> creation and <a href="core/comm.html">communication</a> primitives, platform abstractions (<a href="core/os.html"><code>os</code></a> and <a href="core/path.html"><code>path</code></a>), basic I/O abstractions (<a href="core/io.html"><code>io</code></a>), <a href="core/container.html">containers</a> like <a href="core/hashmap.html"><code>hashmap</code></a>, common traits (<a href="core/kinds.html"><code>kinds</code></a>, <a href="core/ops.html"><code>ops</code></a>, <a href="core/cmp.html"><code>cmp</code></a>, <a href="core/num.html"><code>num</code></a>, <a href="core/to_str.html"><code>to_str</code></a>, <a href="core/clone.html"><code>clone</code></a>), and complete bindings to the C standard library (<a href="core/libc.html"><code>libc</code></a>).</p>
<h3 id="core-injection-and-the-rust-prelude"><a href="#TOC"><span class="header-section-number">17.4.1</span> Core injection and the Rust prelude</a></h3>
<p><code>core</code> is imported at the topmost level of every crate by default, as if the first line of each crate was</p>
<pre><code>extern mod core;</code></pre>
<p>This means that the contents of core can be accessed from from any context with the <code>core::</code> path prefix, as in <code>use core::vec</code>, <code>use core::task::spawn</code>, etc.</p>
<p>Additionally, <code>core</code> contains a <code>prelude</code> module that reexports many of the most common core modules, types and traits. The contents of the prelude are imported into every <em>module</em> by default. Implicitly, all modules behave as if they contained the following prologue:</p>
<pre><code>use core::prelude::*;</code></pre>
<h1 id="what-next"><a href="#TOC"><span class="header-section-number">18</span> What next?</a></h1>
<p>Now that you know the essentials, check out any of the additional tutorials on individual topics.</p>
<ul>
<li><a href="tutorial-borrowed-ptr.html">Borrowed pointers</a></li>
<li><a href="tutorial-tasks.html">Tasks and communication</a></li>
<li><a href="tutorial-macros.html">Macros</a></li>
<li><a href="tutorial-ffi.html">The foreign function interface</a></li>
</ul>
<p>There is further documentation on the <a href="https://github.com/mozilla/rust/wiki/Docs">wiki</a>.</p>
</body>
</html>
