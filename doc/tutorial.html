<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Rust 언어 튜토리얼</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="rust.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Rust 언어 튜토리얼</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#머리말"><span class="toc-section-number">1</span> 머리말</a><ul>
<li><a href="#범위"><span class="toc-section-number">1.1</span> 범위</a></li>
<li><a href="#관습"><span class="toc-section-number">1.2</span> 관습</a></li>
</ul></li>
<li><a href="#시작하기"><span class="toc-section-number">2</span> 시작하기</a><ul>
<li><a href="#자신의-첫-프로그램-컴파일하기"><span class="toc-section-number">2.1</span> 자신의 첫 프로그램 컴파일하기</a></li>
<li><a href="#rust-도구-사용하기"><span class="toc-section-number">2.2</span> rust 도구 사용하기</a></li>
<li><a href="#rust-코드-수정하기"><span class="toc-section-number">2.3</span> Rust 코드 수정하기</a></li>
</ul></li>
<li><a href="#기본-문법"><span class="toc-section-number">3</span> 기본 문법</a><ul>
<li><a href="#표현식과-세미콜론"><span class="toc-section-number">3.1</span> 표현식과 세미콜론</a></li>
<li><a href="#기본-타입과-리터럴"><span class="toc-section-number">3.2</span> 기본 타입과 리터럴</a></li>
<li><a href="#연산자"><span class="toc-section-number">3.3</span> 연산자</a></li>
<li><a href="#문법-확장"><span class="toc-section-number">3.4</span> 문법 확장</a></li>
</ul></li>
<li><a href="#제어-구조"><span class="toc-section-number">4</span> 제어 구조</a><ul>
<li><a href="#조건"><span class="toc-section-number">4.1</span> 조건</a></li>
<li><a href="#패턴-매칭"><span class="toc-section-number">4.2</span> 패턴 매칭</a></li>
<li><a href="#루프"><span class="toc-section-number">4.3</span> 루프</a></li>
</ul></li>
<li><a href="#자료-구조"><span class="toc-section-number">5</span> 자료 구조</a><ul>
<li><a href="#구조체"><span class="toc-section-number">5.1</span> 구조체</a></li>
<li><a href="#열거형"><span class="toc-section-number">5.2</span> 열거형</a></li>
<li><a href="#튜플"><span class="toc-section-number">5.3</span> 튜플</a></li>
<li><a href="#튜플-구조체"><span class="toc-section-number">5.4</span> 튜플 구조체</a></li>
</ul></li>
<li><a href="#함수"><span class="toc-section-number">6</span> 함수</a></li>
<li><a href="#소멸자"><span class="toc-section-number">7</span> 소멸자</a></li>
<li><a href="#소유권"><span class="toc-section-number">8</span> 소유권</a></li>
<li><a href="#박스"><span class="toc-section-number">9</span> 박스</a><ul>
<li><a href="#소유된-박스"><span class="toc-section-number">9.1</span> 소유된 박스</a></li>
<li><a href="#관리되는-박스"><span class="toc-section-number">9.2</span> 관리되는 박스</a></li>
</ul></li>
<li><a href="#move-semantics"><span class="toc-section-number">10</span> Move semantics</a></li>
<li><a href="#borrowed-pointers"><span class="toc-section-number">11</span> Borrowed pointers</a><ul>
<li><a href="#freezing"><span class="toc-section-number">11.1</span> Freezing</a></li>
</ul></li>
<li><a href="#dereferencing-pointers"><span class="toc-section-number">12</span> Dereferencing pointers</a></li>
<li><a href="#vectors-and-strings"><span class="toc-section-number">13</span> Vectors and strings</a></li>
<li><a href="#closures"><span class="toc-section-number">14</span> Closures</a><ul>
<li><a href="#managed-closures"><span class="toc-section-number">14.1</span> Managed closures</a></li>
<li><a href="#owned-closures"><span class="toc-section-number">14.2</span> Owned closures</a></li>
<li><a href="#closure-compatibility"><span class="toc-section-number">14.3</span> Closure compatibility</a></li>
<li><a href="#do-syntax"><span class="toc-section-number">14.4</span> Do syntax</a></li>
<li><a href="#for-loops"><span class="toc-section-number">14.5</span> For loops</a></li>
</ul></li>
<li><a href="#methods"><span class="toc-section-number">15</span> Methods</a></li>
<li><a href="#generics"><span class="toc-section-number">16</span> Generics</a><ul>
<li><a href="#traits"><span class="toc-section-number">16.1</span> Traits</a></li>
<li><a href="#declaring-and-implementing-traits"><span class="toc-section-number">16.2</span> Declaring and implementing traits</a></li>
<li><a href="#bounded-type-parameters-and-static-method-dispatch"><span class="toc-section-number">16.3</span> Bounded type parameters and static method dispatch</a></li>
<li><a href="#trait-objects-and-dynamic-method-dispatch"><span class="toc-section-number">16.4</span> Trait objects and dynamic method dispatch</a></li>
<li><a href="#trait-inheritance"><span class="toc-section-number">16.5</span> Trait inheritance</a></li>
</ul></li>
<li><a href="#modules-and-crates"><span class="toc-section-number">17</span> Modules and crates</a><ul>
<li><a href="#crates"><span class="toc-section-number">17.1</span> Crates</a></li>
<li><a href="#using-other-crates"><span class="toc-section-number">17.2</span> Using other crates</a></li>
<li><a href="#a-minimal-example"><span class="toc-section-number">17.3</span> A minimal example</a></li>
<li><a href="#the-core-library"><span class="toc-section-number">17.4</span> The core library</a><ul>
<li><a href="#core-injection-and-the-rust-prelude"><span class="toc-section-number">17.4.1</span> Core injection and the Rust prelude</a></li>
</ul></li>
</ul></li>
<li><a href="#what-next"><span class="toc-section-number">18</span> What next?</a></li>
</ul>
</div>
<h1 id="머리말"><a href="#머리말"><span class="header-section-number">1</span> 머리말</a></h1>
<p>Rust는 타입 안전성, 메모리 안전성, 동시성 그리고 성능에 초점을 맞춘 프로그래밍 언어이다. 몇 가지로 분류되는 일반적인 에러들로부터 자유로운 대규모, 고성능 소프트웨어를 작성하도록 계획되었다. Rust는 능률적인 데이터 구조를 장려하는 고수준의 메모리 모델과 세그멘테이션 오류를 일으키는 무효한 메모리 접근을 예방하는 안전한 동시성 패턴을 가지고 있다. 컴파일 시간에 타입이 정해진다.</p>
<p>다중 패러다임 언어로서, Rust는 절차형, 함수형 그리고 객체지향 스타일로 작성된 코드를 모두 지원한다. 또한 다음의 고수준의 기능들을 포함한다:</p>
<ul>
<li><strong>타입 추론</strong> 타입을 알려주는 지역 변수 선언은 선택적이다.</li>
<li><strong>안전한 태스크 기반의 동시성</strong> Rust의 가벼운 태스크들은 메모리를 공유하지 않는 대신 메시지를 통해 통신한다.</li>
<li><strong>고차(Higher-order) 함수</strong> 효율적이고 유연한 클로저는 반복과 제어 구조를 분리하여 제공한다.</li>
<li><strong>패턴 매칭과 대수적 자료구조</strong> Rust의 열거형(C의 열거형의 더 강력한 버전, 함수형 언어에서 대수적 자료구조와 비슷)에서 패턴 매칭은 프로그램 논리를 코드화하는 함축적이고 표현적인 방법이다.</li>
<li><strong>다형성</strong> Rust는 타입-인자의 함수와 타입, 타입 클래스 그리고 객체지향 스타일의 인터페이스를 가진다.</li>
</ul>
<h2 id="범위"><a href="#범위"><span class="header-section-number">1.1</span> 범위</a></h2>
<p>이 문서는 Rust 프로그래밍 언어를 소개하는 튜토리얼이다. 문법, the 타입 시스템과 메모리 모델, 제너릭, 모듈을 포함한 언어의 기초를 다룬다. <a href="#what-next">Additional tutorials</a>은 언어에 특화된 기능을 더 깊이 다룬다.</p>
<p>이 튜토리얼은 독자가 하나 이상 의 C 계열의 언어에 이미 친숙하다고 가정한다. 포인터와 일반적인 메모리 관리 기법의 이해가 도움을 줄 것이다.</p>
<h2 id="관습"><a href="#관습"><span class="header-section-number">1.2</span> 관습</a></h2>
<p>튜토리얼을 통해서, 예제 코드에서 정의되는 언어 키워드와 식별자는 <code>코드 글꼴</code>로 표시된다.</p>
<p>코드 조각은 들여쓰여지고, monospaced 글꼴로 보여진다. 모든 코드 조각들이 전체 프로그램을 구성하지는 않는다. 간결함을 위해, 컴파일되지 않는 프로그램의 일부분을 보여줄 것이다. 실행해보기 위해, <code>fn main() { ... }</code> 안에 넣어야할 것이다, 실제로 정의되지 않은 이름을 참조하는 것을 확인해야한다.</p>
<blockquote>
<p><strong><em>경고:</em></strong> Rust 계속 개발중인 언어이다. 언어의 잠재적인 변화, 구현 부족, 그리고 정지에 대해 알고있어야한다.</p>
</blockquote>
<h1 id="시작하기"><a href="#시작하기"><span class="header-section-number">2</span> 시작하기</a></h1>
<p>현재 Rust 컴파일러는 <a href="http://static.rust-lang.org/dist/rust-0.6.tar.gz">tarball</a>로 제작되고, Windows의 경우는 <a href="http://static.rust-lang.org/dist/rust-0.6-install.exe">installer</a> 사용을 추천한다.</p>
<p>컴파일러는 Rust로 작성되었기에, 스스로 미리 컴파일된 &quot;snapshot&quot; 버전으로 만들어진다(개발 초기 단계에). 이처럼, 소스를 빌드하려면 스냅샷을 받아오기 위해 인터넷 연결과 유효한 스냅샷 바이너리를 실행할 수 있는 OS가 필요하다.</p>
<p>현재 스냅샷 바이너리는 아래의 플랫폼들에서 제작되고 테스트된다:</p>
<ul>
<li>Windows (7, Server 2008 R2), x86 only</li>
<li>Linux (various distributions), x86 and x86-64</li>
<li>OSX 10.6 (&quot;Snow Leopard&quot;) or greater, x86 and x86-64</li>
</ul>
<p>다른 플랫폼에서 작동하는 것을 찾을 수도 있지만, 선호되는 빌드 환경을 지원하는 것이 우선의 목표이다.</p>
<blockquote>
<p><strong><em>Note:</em></strong> 윈도우즈 사용자들은 위키에서 세부적인 <a href="https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust">getting started</a> 내용을 읽어야한다. 바이너리 인스톨러를 사용하더라도 윈도우즈에서 빌드하려면 MinGW 설치가 필요하다. 자세한 내용은 여기서 논의하지 않는다. 마지막으로, <code>rustc</code>는 <a href="https://github.com/mozilla/rust/issues/3319">referred to as <code>rustc.exe</code></a>를 알고 있어야한다. 기대에 어긋나는 것이라는 것은 알고있다.</p>
</blockquote>
<p>소스로부터 빌드하려면 사전에 필요한 패키지는 다음과 같다:</p>
<ul>
<li>g++ 4.4 or clang++ 3.x</li>
<li>python 2.6 or later (but not 3.x)</li>
<li>perl 5.0 or later</li>
<li>gnu make 3.81 or later</li>
<li>curl</li>
</ul>
<p>만약 충분히 필요 조건을 만족한다면, 다음의 명령들을 수행하면 된다.</p>
<pre class="notrust"><code>$ curl -O http://static.rust-lang.org/dist/rust-0.6.tar.gz
$ tar -xzf rust-0.6.tar.gz
$ cd rust-0.6
$ ./configure
$ make &amp;&amp; make install</code></pre>
<p>만약 목표 디렉토리를 수정할 권한을 가지고 있지 않다면 <code>sudo make install</code>을 사용해야 할 수도 있다. 설치 장소는 <code>configure</code> 명령의 인자로 <code>--prefix</code>를 전달하여 조정할 수 있다. 다양한 다른 옵션들도 지원되고 <code>--help</code> 인자를 통해 더 자세한 정보를 얻을 수 있습니다.</p>
<p><code>make install</code>이 성공적으로 완료되면 <code>/usr/local/bin</code> 디렉토리 내의 몇가지 프로그램을 볼 수 있을 것이다. <code>rustc</code>는 the Rust 컴파일러, <code>rustdoc</code>는 API-문서 도구, 그리고 <code>rustpkg</code>는 Rust 패키지 관리자 및 빌드 시스템, <code>rusti</code>는 Rust REPL, 그리고 <code>rust</code>는, 위 명령들의 통합된 인터페이스, 몇개의 공통의 명령행 시나리오로 동작하는 도구이다.</p>
<h2 id="자신의-첫-프로그램-컴파일하기"><a href="#자신의-첫-프로그램-컴파일하기"><span class="header-section-number">2.1</span> 자신의 첫 프로그램 컴파일하기</a></h2>
<p>관습적으로 Rust 프로그램 파일은 <code>.rs</code>라는 확장자를 가진다. 아래의 프로그램을 가지는 <code>hello.rs</code> 파일을 만들어보자.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">main</span>() {
    <span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-string">&quot;hello?&quot;</span>);
}
</pre>

<p>만약 Rust 컴파일러가 성공적으로 설치되었다면, <code>rustc hello.rs</code>라고 실행하면 <code>hello</code> 라는 실행파일이 생성되고(윈도우즈에서는 <code>hello.exe</code>), 실행하면 원하는 결과가 정확히 실행될 것이다.</p>
<p>The Rust 컴파일러는 에러가 발생한 경우 유용한 정보를 제공하려고 노력한다. 프로그램에 에러를 넣고(예를 들어, <code>io:println</code> 을 존재하지 않는 함수로 바꿔서) 컴파일을 하면, 아래와 비슷한 에러 메시지를 볼 수 있을 것이다.</p>
<pre class="notrust"><code>hello.rs:2:4: 2:16 error: unresolved name: io::print_with_unicorns
hello.rs:2     io::print_with_unicorns(&quot;hello?&quot;);
               ^~~~~~~~~~~~~~~~~~~~~~~</code></pre>
<p>최대한 단순화하면, Rust 프로그램은 몇 개의 타입과 함수를 가지고 있는 <code>.rs</code> 파일이다. 만약 <code>main</code> 함수를 가지고 있으면, 실행되도록 컴파일 될 수 있다. Rust는 파일의 최상위 레벨에서 선언된 코드를 허용하지 않는다. 모든 구문은 함수 안에 존재해야 한다. Rust 프로그램은 다른 프로그램에 포함되는 라이브러리로서 컴파일 될 수 있다.</p>
<h2 id="rust-도구-사용하기"><a href="#rust-도구-사용하기"><span class="header-section-number">2.2</span> rust 도구 사용하기</a></h2>
<p>실행되는 것을 생성하기 위해 <code>rustc</code>를 직접적으로 사용하고, 수동으로 실행하는 것은 당신의 코드를 테스트하는 완전하고 유효한 방법이지만, 작은 프로젝트이거나 프로토타입이거나 당신이 초보자라면 <code>rust</code> 도구를 사용하는 것이 더 편리할 것이다.</p>
<p><code>rust</code> 도구는 나머지 rust 도구들로의 중앙집중적 접근 뿐만아니라 소스 파일을 바로 실행하기 위해 간편한 단축 명령을 제공한다. 예를 들어, 현재 디렉토리에 <code>foo.rs</code> 파일이 있다면, <code>rust run foo.rs</code> 명령은 컴파일을 시도할 것이고, 성공하면 결과로 생성된 바이너리를 바로 실행한다.</p>
<p>모든 가능한 명령의 목록을 얻으려면, 어떤 인자도 없이 단순히 <code>rust</code>만 호출하면 된다.</p>
<h2 id="rust-코드-수정하기"><a href="#rust-코드-수정하기"><span class="header-section-number">2.3</span> Rust 코드 수정하기</a></h2>
<p>Rust 소스 배포판 <code>src/etc/vim/</code> 하위에 vim 하이라이트와 들여쓰기 스크립트가 있다. <code>src/etc/emacs/</code> 하위에 <code>rust-mode</code>라고 불리는 emacs 모드가 있지만, 디렉토리에 포함된 설명서를 꼭 읽어라. 특히, emacs 24에서 실행한다면, <code>rust-mode</code> 설치를 최신으로 유지하는 가장 쉬운 방법인 emacs 내부 패키지 관리자를 사용해라. 또한 Sublime Text 2를 위한 패키지는 <a href="http://github.com/dbp/sublime-rust">standalone</a>와 <a href="http://wbond.net/sublime_packages/package_control">Sublime Package Control</a>를 통해서 모두 가능하고, Kate를 위한 지원은 <code>src/etc/kate</code> 하위에 있다.</p>
<p><code>src/etc/ctags.rust</code>를 통해 ctags를 지원하지만, 많은 다른 도구들과 편집기들은 아직 지원하지 않는다. 당신이 가장 선호하는 편집기를 위한 Rust 모드가 작성이 완료되면, 우리에게 알려주면 링크를 걸어주겠다.</p>
<h1 id="기본-문법"><a href="#기본-문법"><span class="header-section-number">3</span> 기본 문법</a></h1>
<p>당신이 C계열의 언어(C++, Java, JavaScript, C#, or PHP)로 프로그래밍을 했다고 가정하면, Rust는 비슷하다고 느낄 것이다. 코드는 중괄호로 구분되는 블록들의 나열이다. <code>if</code>와 <code>while</code>과 비슷한 분기나 반복을 위한 제어 구조도 있다. 함수는 <code>myfunc(arg1, args2);</code>라고 호출한다. 연산자도 C와 같고 거의 동일한 우선순위를 가진다. 주석 또한 C와 같다. 모듈 이름은 C++ 처럼 더블 콜론(::)으로 구분된다.</p>
<p>인지되는 주된 표면적 차이는 <code>if</code>와 <code>while</code>과 같은 제어 구조의 머리에 있는 조건이 괄호가 필요없고, 몸통은 <em>무조건</em> 중괄호로 둘러싸야한다. 몸통에 문장이 하나일때, 중괄호를 하지않는 것은 허용되지 않는다.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">main</span>() {
    <span class="cm-comment">/* A simple loop */</span>
    <span class="cm-keyword">loop</span> {
        <span class="cm-comment">// A tricky calculation</span>
        <span class="cm-keyword">if</span> <span class="cm-variable-2">universe::</span><span class="cm-variable">recalibrate</span>() {
            <span class="cm-keyword">return</span>;
        }
    }
}
</pre>

<p><code>let</code> 키워드는 지역 변수를 나타낸다. 변수는 기본적으로 변하지 않는다. 나중에 재할당할 수 있는 지역 변수를 나타내기 위해, <code>let mut</code>를 사용한다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">hi</span> = <span class="cm-string">&quot;hi&quot;</span>;
<span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">count</span> = <span class="cm-number">0</span>;

<span class="cm-keyword">while</span> <span class="cm-variable">count</span> &lt; <span class="cm-number">10</span> {
    <span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-variable">fmt</span>!(<span class="cm-string">&quot;count: %?&quot;</span>, <span class="cm-variable">count</span>));
    <span class="cm-variable">count</span> += <span class="cm-number">1</span>;
}
</pre>

<p>Rust는 지역 변수의 타입을 거의 항상 추론할 수 있지만, 콜론 다음에 타입의 이름을 적어줌으로써 변수의 타입을 명시해줄 수 있다. 반대로, 정적 아이템은 타입 주석이 항상 필요하다.</p>
<pre class="cm-s-default"><span class="cm-variable">static</span> <span class="cm-variable">monster_factor</span>: <span class="cm-variable">float</span> = <span class="cm-number">57.8</span>;
<span class="cm-keyword">let</span> <span class="cm-def">monster_size</span> = <span class="cm-variable">monster_factor</span> * <span class="cm-number">10.0</span>;
<span class="cm-keyword">let</span> <span class="cm-def">monster_size</span>: <span class="cm-keyword">int</span> = <span class="cm-number">50</span>;
</pre>

<p>앞의 예제에서 지역 변수는 shadow earlier 선언이다: 첫번째 <code>monster_size</code>는 <code>float</code>으로, 두번째 <code>monster_size</code>는 <code>int</code>로 선언되었다. 이 예제를 실제로 컴파일하더라도, 컴파일러는 첫번째 <code>monster_size</code>는 사용되지 않는다고 판단하고 경고를 표시할 것이다(이 상황은 프로그래머 오류를 발생시킬 가능성이 있기 때문이다). 사용되지 않는 변수가 의도적인 경우, 경고를 없애기 위해, <code>let _monster_size = 50;</code>처럼 이름을 밑줄로 시작하면 된다.</p>
<p>Rust 식별자는 알파벳 문자나 밑줄로 시작하고 그 이후로 알파벳 문자, 숫자, 밑줄의 나열된다. 선호되는 스타일은 함수, 변수, 그리고 모듈 이름은 가독성에 도움을 주기위해 밑줄이 포함된 소문자로 작성하고, 타입은 camel case로 작성한다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">my_variable</span> = <span class="cm-number">100</span>;
<span class="cm-keyword">type</span> <span class="cm-def">MyType</span> = <span class="cm-keyword">int</span>;     <span class="cm-comment">// 기본 타입은 camel case로 작성하지 않는다.</span>
</pre>

<h2 id="표현식과-세미콜론"><a href="#표현식과-세미콜론"><span class="header-section-number">3.1</span> 표현식과 세미콜론</a></h2>
<p>모든 코드에서 외관상 다르더라도, Rust의 문법과 C와 같은 predecessors 사이에는 근본적인 차이가 있다. C에서 문장인 많은 구조들은 Rust에서는 더 간결한 코드를 허용하는 표현식이다. 예를 들어, 다음과 같은 코드의 일부분을 작성할 수 있다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">price</span>;
<span class="cm-keyword">if</span> <span class="cm-variable">item</span> == <span class="cm-string">&quot;salad&quot;</span> {
    <span class="cm-variable">price</span> = <span class="cm-number">3.50</span>;
} <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> <span class="cm-variable">item</span> == <span class="cm-string">&quot;muffin&quot;</span> {
    <span class="cm-variable">price</span> = <span class="cm-number">2.25</span>;
} <span class="cm-keyword">else</span> {
    <span class="cm-variable">price</span> = <span class="cm-number">2.00</span>;
}
</pre>

<p>그러나, Rust에서는, <code>price</code>라는 이름을 반복할 필요가 없다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">price</span> =
    <span class="cm-keyword">if</span> <span class="cm-variable">item</span> == <span class="cm-string">&quot;salad&quot;</span> {
        <span class="cm-number">3.50</span>
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> <span class="cm-variable">item</span> == <span class="cm-string">&quot;muffin&quot;</span> {
        <span class="cm-number">2.25</span>
    } <span class="cm-keyword">else</span> {
        <span class="cm-number">2.00</span>
    };
</pre>

<p>두 코드의 일부분은 정확히 동일하다. 둘다 주어진 조건에 따라 값을 <code>price</code>에 할당한다. 두번째 코드 조각의 블록안에 세미콜론이 없다는 것을 명심해라. 이것은 중요하다. 중괄호 사이의 블록내의 마지막 문장 뒤에 세미콜론의 누락은 전체 블록에게 마지막 표현식의 값을 준다.</p>
<p>다르게 말하면, Rust에서 세미콜론은 <em>표현식의 값을 무시한다</em>. 그래서 <code>if</code>의 분기가 <code>{ 4; }</code>처럼 되어있다면, 위의 예제는 단순히 <code>price</code>에 <code>()</code> (nil 또는 void)를 할당할 것이다. 그러나 세미콜론이 없으면, 각 분기는 서로 다른 값을 가지고, <code>price</code>는 분기에서 얻은 값을 가진다.</p>
<p>즉, 선언(변수를 위한 <code>let</code>, 함수를 위한 <code>fn</code>, 그리고 <a href="#traits">traits</a>, <a href="#enums">enum types</a>, 그리고 <a href="#constants">constants</a>와 같은 최상위 요소)이 아닌 모든 것(함수 몸통 포함)은 표현식이다.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">is_four</span>(<span class="cm-def">x</span>: <span class="cm-keyword">int</span>) -&gt; <span class="cm-keyword">bool</span> {
   <span class="cm-comment">// No need for a return statement. The result of the expression</span>
   <span class="cm-comment">// is used as the return value.</span>
   <span class="cm-variable">x</span> == <span class="cm-number">4</span>
}
</pre>

<h2 id="기본-타입과-리터럴"><a href="#기본-타입과-리터럴"><span class="header-section-number">3.2</span> 기본 타입과 리터럴</a></h2>
<p>일반적인 부호있는/없는 정수 타입인 <code>int</code>와 <code>uint</code>, 또한 8-, 16-, 32-, 그리고 64-bit 변수인, <code>i8</code>, <code>u16</code> 등이 있다. 정수는 10진수 (<code>144</code>), 16진수 (<code>0x90</code>), 또는 2진수 (<code>0b10010000</code>) 로 작성될 수 있다. 각 정수 타입은 리터럴의 타입을 가리키는데 사용될 수 있는 리터럴 접미사와 대응된다. 예를들어 <code>i</code>는 <code>int</code>, <code>u</code>는 <code>uint</code>, <code>i8</code>는 <code>i8</code> 타입이다.</p>
<p>정수 리터럴 접미사가 없으면, Rust는 근처 코드의 타입 어노테이션과 함수 시그니처에 근거해 정수 타입으로 추론할 것이다. 어떤 타입 정보도 없으면, Rust는 접미사없는 정수 리터럴인 <code>int</code> 타입으로 가정할 것이다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">a</span> = <span class="cm-number">1</span>;       <span class="cm-comment">// a is an int</span>
<span class="cm-keyword">let</span> <span class="cm-def">b</span> = <span class="cm-number">10</span><span class="cm-variable">i</span>;     <span class="cm-comment">// b is an int, due to the 'i' suffix</span>
<span class="cm-keyword">let</span> <span class="cm-def">c</span> = <span class="cm-number">100</span><span class="cm-variable">u</span>;    <span class="cm-comment">// c is a uint</span>
<span class="cm-keyword">let</span> <span class="cm-def">d</span> = <span class="cm-number">1000i32</span>; <span class="cm-comment">// d is an i32</span>
</pre>

<p>Rust는 <code>float</code>, <code>f32</code>, 그리고 <code>f64</code>의 세가지 부동소수점 타입이 있다. 부동소수점 숫자는 <code>0.0</code>, <code>1e6</code>, 또는 <code>2.1e-4</code> 처럼 표현된다. 정수처럼, 부동소수점 리터럴도 타입이 정확하게 추론된다. 명시적 타입의 리터럴인 접미사 <code>f</code>, <code>f32</code>, 그리고 <code>f64</code>으로 생성할 수 있다.</p>
<p>키워드 <code>true</code>와 <code>false</code>은 <code>bool</code> 타입의 리터럴을 생성한다.</p>
<p><code>char</code> 타입인 문자의 리터럴은 <code>'x'</code>와 같이 작은 따옴표 사이에 4 바이트 유니코드 코드포인트를 적는다. C와 동일하게, Rust는 <code>\n</code>, <code>\r</code>, <code>\t</code> 같이 백슬러시 문자를 사용하는 다양한 탈출 문자를 이해한다. 문자열 리터럴은 쌍따옴표 사이에 적고, 동일한 탈출 문자를 허용한다. 문자열에 대해 더 알고싶으면 <a href="#vectors-and-strings">later</a>.</p>
<p><code>()</code>로 적히는 nil 타입은 똑같이 <code>()</code>라고 쓰는 하나의 값만 가진다.</p>
<h2 id="연산자"><a href="#연산자"><span class="header-section-number">3.3</span> 연산자</a></h2>
<p>Rust의 연산자의 세트는 몇가지 놀라움을 가지고 있다. 산술연산은 <code>*</code>, <code>/</code>, <code>%</code>, <code>+</code>, <code>-</code> (곱하기, 나누기, 나머지, 더하기, 빼기)로 구성된다. 또 <code>-</code>는 음수를 표현하는 단항 접미 연산. C와 마찬가지로, the 비트 연산자 <code>&gt;&gt;</code>, <code>&lt;&lt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>도 지원된다.</p>
<p>정수 값에 <code>!</code>를 적용하면, 모든 비트를 뒤집는다는 것을 명심하자(C의 <code>~</code> 처럼).</p>
<p>비교 연산자는 전통적인 <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>,<code>&lt;=</code>, and <code>&gt;=</code> 이다. 단락 회로 (게으른) 논리 연산자는 <code>&amp;&amp;</code> (and) 그리고 <code>||</code> (or)가 있다.</p>
<p>타입 캐스팅을 위해, Rust는 <code>as</code>라는 이항 연산자를 사용한다. 좌측에 표현식은 좌측에, 타입은 우측에 놓고, 의미있는 변환이라면, 표현식의 결과는 주어진 타입으로 변한다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">x</span>: <span class="cm-keyword">float</span> = <span class="cm-number">4.0</span>;
<span class="cm-keyword">let</span> <span class="cm-def">y</span>: <span class="cm-keyword">uint</span> = <span class="cm-variable">x</span> <span class="cm-keyword">as</span> <span class="cm-variable">uint</span>;
<span class="cm-keyword">assert</span>!(<span class="cm-variable">y</span> == <span class="cm-number">4</span><span class="cm-variable">u</span>);
</pre>

<h2 id="문법-확장"><a href="#문법-확장"><span class="header-section-number">3.4</span> 문법 확장</a></h2>
<p><em>문법 확장</em>은 언어 안에 포함되지 않은 특별한 형식이지만, 대신 라이브러리로 제공된다. 어떤 이름이 문법 확장을 가리키는 것을 독자에게 더 명확히 하기위해, 모든 문법 확장의 이름은 <code>!</code>으로 끝난다. 표준 라이브러리는 앞으로 예제에서 종종 보게될 <code>sprintf</code> 스타일의 텍스트 형식지정자인 <code>fmt!</code>와 같이 가장 유용한 몇개의 문법 확장을 정의한다.</p>
<p><code>fmt!</code>는 <a href="http://en.cppreference.com/w/cpp/io/c/fprintf">printf</a>가 지원하는 대부분의 지시자를 지원하지만, printf와 다르게, 지시자의 타입이 인자의 타입과 일치하지 않는 경우 컴파일 시간에 오류를 뱉는다.</p>
<pre class="cm-s-default">
<span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-variable">fmt</span>!(<span class="cm-string">&quot;%s is %d&quot;</span>, <span class="cm-string">&quot;the answer&quot;</span>, <span class="cm-number">43</span>));

<span class="cm-comment">// %? will conveniently print any type</span>
<span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-variable">fmt</span>!(<span class="cm-string">&quot;what is this thing: %?&quot;</span>, <span class="cm-variable">mystery_object</span>));
</pre>

<p>매크로 시스템을 통해 자신만의 문법 확장을 정의할 수 있다. 자세한 사항은 <a href="tutorial-macros.html">macro tutorial</a>를 참고하세요.</p>
<h1 id="제어-구조"><a href="#제어-구조"><span class="header-section-number">4</span> 제어 구조</a></h1>
<h2 id="조건"><a href="#조건"><span class="header-section-number">4.1</span> 조건</a></h2>
<p>우리는 이미 여러번 <code>if</code> 표현식을 보았다. 다시 떠올려보면, 중괄호는 필수적이고, <code>if</code>는 선택적으로 <code>else</code> 절을 가질 수 있고, <code>if</code>/<code>else</code>는 여러번 이을 수 있다:</p>
<pre class="cm-s-default"><span class="cm-keyword">if</span> <span class="cm-atom">false</span> {
    <span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-string">&quot;that's odd&quot;</span>);
} <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> <span class="cm-atom">true</span> {
    <span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-string">&quot;right&quot;</span>);
} <span class="cm-keyword">else</span> {
    <span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-string">&quot;neither true nor false&quot;</span>);
}
</pre>

<p><code>if</code> 구조에 주어진 조건은 <em>무조건</em> <code>bool</code> 타입이어야 한다. (은연중의 변환은 발생하진 않는다). 만약 분기가 값을 가지는 블록이면, 모든 분기에 블록의 끝의 값은 동일한 타입이어야 한다.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">signum</span>(<span class="cm-def">x</span>: <span class="cm-keyword">int</span>) -&gt; <span class="cm-keyword">int</span> {
    <span class="cm-keyword">if</span> <span class="cm-variable">x</span> &lt; <span class="cm-number">0</span> { -<span class="cm-number">1</span> }
    <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> <span class="cm-variable">x</span> &gt; <span class="cm-number">0</span> { <span class="cm-number">1</span> }
    <span class="cm-keyword">else</span> { <span class="cm-keyword">return</span> <span class="cm-number">0</span> }
}
</pre>

<h2 id="패턴-매칭"><a href="#패턴-매칭"><span class="header-section-number">4.2</span> 패턴 매칭</a></h2>
<p>Rust의 <code>match</code> 구조는 C의 <code>switch</code> 구조의 일반화되고, 깔끔한 버전이다. 값과 다수의 <em>분기</em>로 구성되고, 각 분기는 패턴으로 이름지어지고, 코드는 값과 각 패턴을 순서대로 하나라도 일치할 때까지 비교한다. 일치된 패턴은 대응하는 분기를 실행한다.</p>
<pre class="cm-s-default"><span class="cm-keyword">match</span> <span class="cm-variable">my_number</span> {
  <span class="cm-number">0</span>     =&gt; <span class="cm-variable-2">io::</span><span class="cm-def">println</span>(<span class="cm-string">&quot;zero&quot;</span>),
  <span class="cm-number">1</span> | <span class="cm-number">2</span> =&gt; <span class="cm-variable-2">io::</span><span class="cm-def">println</span>(<span class="cm-string">&quot;one or two&quot;</span>),
  <span class="cm-number">3..10</span> =&gt; <span class="cm-variable-2">io::</span><span class="cm-def">println</span>(<span class="cm-string">&quot;three to ten&quot;</span>),
  <span class="cm-def">_</span>     =&gt; <span class="cm-variable-2">io::</span><span class="cm-def">println</span>(<span class="cm-string">&quot;something else&quot;</span>)
}
</pre>

<p>C와는 다르게, 분기 사이에 &quot;내려가기(falling through)&quot;가 없다. 단지 하나의 분기만 실행하고, 분기가 끝났을 때 명시적으로 <code>break</code>를 이용해 구조를 빠져나갈 필요가 없다.</p>
<p>A <code>match</code> 분기는 <em>패턴</em>, 화살표 <code>=&gt;</code>, <em>액션</em> (표현식)순으로 구성된다. 리터럴은 유효한 패턴이고, 자신의 값만 일치한다. 모든 패턴이 동일한 변수의 집합과 결합한다면 하나의 분기는 파이프 연산자 (<code>|</code>)로 결합하여 다수의 서로 다른 패턴과 대응할 수도 있다. 숫자 리터럴 범위 패턴은 <code>M..N</code>처럼 두개의 점을 이용해 표현한다. 밑줄(<code>_</code>)은 어떠한 하나의 값에 대응하는 와일드카드 패턴이다. 별표(<code>*</code>)는 <code>enum</code> variant 에서 하나 혹은 여러 필드와 일치하는 독특한 와일드카드이다.</p>
<p>매칭된 분기에 있는 패턴 뒤에 두꺼운 화살표 <code>=&gt;</code>가 따라오고, 그 다음은 평가되는 표현식이다. 각 케이스는 쉼표로 구분된다. 쉼표는 선택적이고, 각 케이스에 대해 블록 표현식을 사용하는 것보다 종종 편리하다.</p>
<pre class="cm-s-default"><span class="cm-keyword">match</span> <span class="cm-variable">my_number</span> {
  <span class="cm-number">0</span> =&gt; { <span class="cm-variable-2">io::</span><span class="cm-def">println</span>(<span class="cm-string">&quot;zero&quot;</span>) }
  <span class="cm-def">_</span> =&gt; { <span class="cm-variable-2">io::</span><span class="cm-def">println</span>(<span class="cm-string">&quot;something else&quot;</span>) }
}
</pre>

<p><code>match</code> 구조는 <em>소모적(모든 가능한 경우를 다루는 분기를 가지고 있음)</em> 이어야 한다. 예를 들어, 와일드카드 패턴을 가지고 있는 분기가 생략되었다면 타입 판별기는 앞의 예제를 거부할 것이다.</p>
<p>패턴 매칭의 강력한 응용은 <em>디스트럭처링</em>이다. 이름을 데이터 타입의 내용에 대응하기위해 매칭하는 것.</p>
<blockquote>
<p><strong><em>노트:</em></strong> 다음의 코드는 섹션 5.3에서 설명되는 튜플(<code>(float, float)</code>)을 사용한다. 이제 아이템의 목록으로서의 튜플을 떠올릴 수 있다.</p>
</blockquote>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">angle</span>(<span class="cm-def">vector</span>: (<span class="cm-keyword">float</span>, <span class="cm-keyword">float</span>)) -&gt; <span class="cm-keyword">float</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">pi</span> = <span class="cm-variable-2">float::consts::</span><span class="cm-variable">pi</span>;
    <span class="cm-keyword">match</span> <span class="cm-variable">vector</span> {
      (<span class="cm-number">0</span><span class="cm-variable">f</span>, <span class="cm-def">y</span>) <span class="cm-keyword">if</span> <span class="cm-def">y</span> &lt; <span class="cm-number">0</span><span class="cm-def">f</span> =&gt; <span class="cm-number">1.5</span> * <span class="cm-def">pi</span>,
      (<span class="cm-number">0</span><span class="cm-variable">f</span>, <span class="cm-def">y</span>) =&gt; <span class="cm-number">0.5</span> * <span class="cm-def">pi</span>,
      (<span class="cm-def">x</span>, <span class="cm-def">y</span>) =&gt; <span class="cm-variable-2">float::</span><span class="cm-def">atan</span>(<span class="cm-def">y</span> <span class="cm-variable">/</span> <span class="cm-variable">x</span>)
    }
}
</pre>

<p>A 패턴에서 변할 수 있는 이름은 어떤 값과 일치하고, 그리고 분기의 행동 내부의 매치된 값의 값으로 대응된다. 그래서, <code>(0f, y)</code> matches 첫번째 요소는 0이고 두번째 요소로 <code>y</code>와 엮이는 어떤 튜플과 일치한다. <code>(x, y)</code>는 두 요소를 가진 어떤 튜플과 일치하고, 두 요소는 변수와 엮인다.</p>
<p><code>match</code> 분기는 패턴과 일치하는 것을 찾은 뒤, 분기를 수행할지 말지 결정하는 <code>bool</code> 타입의 표현식인 <em>패턴 가드</em>라는 이름의 가드 구문(<code>if EXPR</code>라고 적히는)을 가질 수 있다. 패턴에 엮인 변수의 범위는 이 가드 표현식 안에 있다. <code>angle</code> 예제의 첫번째 분기는 패턴 가드의 예를 보여준다.</p>
<p>앞서 단순 <code>let</code> 바인딩을 이미 보았지만, <code>let</code>는 당신이 생각하는 것보다 더 근사하다. 또한 디스트럭처링 패턴을 지원한다. 예를 들어, 튜플로부터 필드의 두 변수 <code>a</code>와 <code>b</code> 를 한번에 추출하기위해 다음처럼 쓸 수 있다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> (<span class="cm-def">a</span>, <span class="cm-def">b</span>) = <span class="cm-variable">get_tuple_of_two_ints</span>();
</pre>

<p>Let 바인딩은 단지 <em>반박할 수 없는</em> 패턴만으로 동작한다. 즉, 매칭에 실패할 수 없는 패턴이다. 이것은 일치한 리터럴과 대부분의 <code>enum</code> 변형으로부터 <code>let</code>을 제외한다.</p>
<h2 id="루프"><a href="#루프"><span class="header-section-number">4.3</span> 루프</a></h2>
<p><code>while</code>은 주어진 조건(<code>bool</code> 타입이어야함)이 <code>true</code>로 평가되는 동안 반복하는 루프를 의미한다. 루프 내에, 키워드 <code>break</code>는 루프를 중지하고, <code>loop</code>는 현재의 반복을 중지하고 다음 반복을 계속한다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">cake_amount</span> = <span class="cm-number">8</span>;
<span class="cm-keyword">while</span> <span class="cm-variable">cake_amount</span> &gt; <span class="cm-number">0</span> {
    <span class="cm-variable">cake_amount</span> -= <span class="cm-number">1</span>;
}
</pre>

<p><code>loop</code>는 무한 루프를 의미하고, <code>while true</code>라고 적는것보다 선호되는 방법이다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">x</span> = <span class="cm-number">5</span>;
<span class="cm-keyword">loop</span> {
    <span class="cm-variable">x</span> += <span class="cm-variable">x</span> - <span class="cm-number">3</span>;
    <span class="cm-keyword">if</span> <span class="cm-variable">x</span> % <span class="cm-number">5</span> == <span class="cm-number">0</span> { <span class="cm-keyword">break</span>; }
    <span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-variable-2">int::</span><span class="cm-variable">to_str</span>(<span class="cm-variable">x</span>));
}
</pre>

<p>이 코드는 기묘한 수열을 출력하고 5로 나뉠 수 있는 수를 찾자마자 멈춘다.</p>
<p>Rust에서 컬렉션의 요소를 하나하나 세는 등의 반복은 <a href="#closures">higher-order functions</a>를 사용한다.</p>
<h1 id="자료-구조"><a href="#자료-구조"><span class="header-section-number">5</span> 자료 구조</a></h1>
<h2 id="구조체"><a href="#구조체"><span class="header-section-number">5.1</span> 구조체</a></h2>
<p>Rust의 구조체 타입은 <code>struct</code> 예약어를 사용한 뒤에 선언된다: <code>struct Name { field1: T1, field2: T2 [, ...] }</code>, 에서 <code>T1</code>, <code>T2</code>, ... 는 타입을 의미한다. 구조체를 만들기위해, 동일한 문법을 사용해야하나, <code>struct</code> 예약어를 제거해도 된다. 예를 들어 <code>Point { x: 1.0, y: 2.0 }</code>.</p>
<p>구조체는 C의 구조체와 아주 비슷하고 메모리에 같은 방식으로 적재된다.(그래서 C에서 Rust의 구조체를 읽을 수 있고, 반대의 경우도 가능하다.). <code>mypoint.x</code> 처럼 구조체 필드에 접근하기 위해 마침표 연산자를 사용한다.</p>
<pre class="cm-s-default"><span class="cm-keyword">struct</span> <span class="cm-variable">Point</span> {
    <span class="cm-variable">x</span>: <span class="cm-variable">float</span>,
    <span class="cm-variable">y</span>: <span class="cm-variable">float</span>
}
</pre>

<p>상속된 변화성은 만약 구조체가 변할 수 있는 슬롯에 있다면 (또는 구조체의 필드가 변할 수 있는 슬롯에 있던지 등) 구조체의 어떤 필드 하나라도 값이 변할 수 있다는 것을 뜻한다.</p>
<p>(<code>mypoint</code>를 보면) 변할 수 있는 위치에서는 타입의 값, <code>mypoint.y += 1.0</code>을 할 수 있다. 그러나 변할 수 없는 위치에서는, 상속된 변화성이 없는 구조체의 할당은 타입 오류를 일으킨다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">mypoint</span> = <span class="cm-variable">Point</span> { <span class="cm-variable">x</span>: <span class="cm-number">1.0</span>, <span class="cm-variable">y</span>: <span class="cm-number">1.0</span> };
<span class="cm-keyword">let</span> <span class="cm-def">origin</span> = <span class="cm-variable">Point</span> { <span class="cm-variable">x</span>: <span class="cm-number">0.0</span>, <span class="cm-variable">y</span>: <span class="cm-number">0.0</span> };

<span class="cm-variable">mypoint</span>.<span class="cm-variable">y</span> += <span class="cm-number">1.0</span>; <span class="cm-comment">// mypoint is mutable, and its fields as well</span>
<span class="cm-variable">origin</span>.<span class="cm-variable">y</span> += <span class="cm-number">1.0</span>; <span class="cm-comment">// ERROR: assigning to immutable field</span>
</pre>

<p><code>match</code> 패턴은 구조체의 구조를 파괴한다. 기본 문법은 <code>Name { fieldname: pattern, ... }</code>이다.</p>
<pre class="cm-s-default"><span class="cm-keyword">match</span> <span class="cm-variable">mypoint</span> {
    <span class="cm-def">Point</span> { <span class="cm-variable">x</span>: <span class="cm-number">0.0</span>, <span class="cm-variable">y</span>: <span class="cm-variable">yy</span> } =&gt; { <span class="cm-variable-2">io::</span><span class="cm-def">println</span>(<span class="cm-variable">yy</span>.<span class="cm-variable">to_str</span>());                     }
    <span class="cm-def">Point</span> { <span class="cm-variable">x</span>: <span class="cm-variable">xx</span>,  <span class="cm-variable">y</span>: <span class="cm-variable">yy</span> } =&gt; { <span class="cm-variable-2">io::</span><span class="cm-def">println</span>(<span class="cm-variable">xx</span>.<span class="cm-variable">to_str</span>() + <span class="cm-string">&quot; &quot;</span> + <span class="cm-variable">yy</span>.<span class="cm-variable">to_str</span>()); }
}
</pre>

<p>일반적으로, 구조체의 필드 이름은 같은 순서로 나타날 필요가 없다. 구조체의 모든 필드에 관심이 없으면, 구조체 패턴은 다른 모든 필드를 무시하는 것을 가리키기위해 <code>, _</code>(<code>Name { field1, _ }</code>처럼)로 끝낼 수 있다. 추가적으로, 구조체 필드는 단순히 필드 이름을 바인딩 이름으로 재사용하는 축약 매칭 형식을 가진다.</p>
<pre class="cm-s-default"><span class="cm-keyword">match</span> <span class="cm-variable">mypoint</span> {
    <span class="cm-def">Point</span> { <span class="cm-variable">x</span>, <span class="cm-variable">_</span> } =&gt; { <span class="cm-variable-2">io::</span><span class="cm-def">println</span>(<span class="cm-variable">x</span>.<span class="cm-variable">to_str</span>()) }
}
</pre>

<h2 id="열거형"><a href="#열거형"><span class="header-section-number">5.2</span> 열거형</a></h2>
<p>열거형은 몇가지 대표값을 갖는 데이터 타입이다. 예를들어, 앞서 봤던 타입을 보자.</p>
<pre class="cm-s-default"><span class="cm-keyword">enum</span> <span class="cm-def">Shape</span> {
    <span class="cm-def">Circle</span>(<span class="cm-variable-3">Point</span>, <span class="cm-keyword">float</span>),
    <span class="cm-def">Rectangle</span>(<span class="cm-variable-3">Point</span>, <span class="cm-variable-3">Point</span>)
}
</pre>

<p>이 타입의 값은 하나의 <code>Point</code> 구조체와 하나의 부동소수점을 포함하는 <code>Circle</code>, 또는 두 개의 <code>Point</code> 구조체를 갖는 <code>Rectangle</code> 이다. 실행시간 중의 특정 대표값은 C의 &quot;tagged union&quot; 패턴처럼 타입이 가지고 있는 실제 형식의 식별자를 포함하지만, 더 정적인 보증을 한다.</p>
<p>위 선언은 특정 모양을 가리킬 수 있는 <code>Shape</code> 타입을 정의할 것이고, 두 개의 함수 <code>Circle</code>과 <code>Rectangle</code>은 (명시된 타입의 인자가 취해지는)타입의 값을 구성하는데 사용될 수 있다. 그래서 <code>Circle(Point { x: 0f, y: 0f }, 10f)</code>은 새로운 원 모양을 생성하는 방법이다.</p>
<p>열거형 값들은 파라미터를 가질 필요가 없다. 예를 들어, 다음의 <code>enum</code> 선언은 C의 열거형과 동일하다.</p>
<pre class="cm-s-default"><span class="cm-keyword">enum</span> <span class="cm-def">Direction</span> {
    <span class="cm-def">North</span>,
    <span class="cm-def">East</span>,
    <span class="cm-def">South</span>,
    <span class="cm-def">West</span>
}
</pre>

<p>이 선언에서 상수로 정의된 <code>North</code>, <code>East</code>, <code>South</code>, 그리고 <code>West</code>는<code>Direction</code> 타입을 가진다.</p>
<p>C 스타일의 열거형이라면(즉, 파라미터를 가지는 열거형 값이 없는 경우), 식별 값을 상수 값으로 명시적으로 설정하는 것이 가능하다.</p>
<pre class="cm-s-default"><span class="cm-keyword">enum</span> <span class="cm-def">Color</span> {
  <span class="cm-def">Red</span> = <span class="cm-def">0xff0000</span>,
  <span class="cm-def">Green</span> = <span class="cm-def">0x00ff00</span>,
  <span class="cm-def">Blue</span> = <span class="cm-def">0x0000ff</span>
}
</pre>

<p>만약 열거형 값에 식별값이 명시되어 있지 않으면, 기본 값은 앞의 열거형 값에 1을 더한 값이 된다. 만약 첫번째 열거형 값에 식별 값이 없다면, 기본 값은 0이다. 예를 들어, <code>North</code>의 값은 0, <code>East</code>는 1, <code>South</code>는 2, 그리고 <code>West</code>는 3이다.</p>
<p>C와 비슷한 열거형이면, <code>int</code>의 식별값으로 변환하기 위해 <code>as</code> 형변환 연산자를 적용할 수 있다.</p>
<p>복수의 열거값을 가지는 열거형 타입에 대해, 구조파괴는 내용을 얻기위한 유일한 방법이다. <code>area</code>의 정의에서 모든 열거값 생성자는 패턴으로 사용될 수 있다.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">area</span>(<span class="cm-def">sh</span>: <span class="cm-variable-3">Shape</span>) -&gt; <span class="cm-keyword">float</span> {
    <span class="cm-keyword">match</span> <span class="cm-variable">sh</span> {
        <span class="cm-def">Circle</span>(<span class="cm-def">_</span>, <span class="cm-def">size</span>) =&gt; <span class="cm-variable-2">float::consts::</span><span class="cm-def">pi</span> * <span class="cm-def">size</span> * <span class="cm-def">size</span>,
        <span class="cm-def">Rectangle</span>(<span class="cm-def">Point</span> { <span class="cm-variable">x</span>, <span class="cm-def">y</span> }, <span class="cm-def">Point</span> { <span class="cm-variable">x</span>: <span class="cm-variable">x2</span>, <span class="cm-def">y</span>: <span class="cm-variable">y2</span> }) =&gt; (<span class="cm-def">x2</span> - <span class="cm-variable">x</span>) * (<span class="cm-def">y2</span> - <span class="cm-variable">y</span>)
    }
}
</pre>

<p>개별의 필드를 무시하기 위해 <code>_</code> 하나를 적을 수 있고, <code>Circle(*)</code> 처럼 열거값의 모든 필드를 무시할 수 있다. 간략 형식으로, null의 열거형 패턴은 중괄호없이 적는다.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">point_from_direction</span>(<span class="cm-def">dir</span>: <span class="cm-variable-3">Direction</span>) -&gt; <span class="cm-variable-3">Point</span> {
    <span class="cm-keyword">match</span> <span class="cm-variable">dir</span> {
        <span class="cm-def">North</span> =&gt; <span class="cm-def">Point</span> { <span class="cm-variable">x</span>:  <span class="cm-number">0</span><span class="cm-variable">f</span>, <span class="cm-variable">y</span>:  <span class="cm-number">1</span><span class="cm-variable">f</span> },
        <span class="cm-def">East</span>  =&gt; <span class="cm-def">Point</span> { <span class="cm-variable">x</span>:  <span class="cm-number">1</span><span class="cm-variable">f</span>, <span class="cm-variable">y</span>:  <span class="cm-number">0</span><span class="cm-variable">f</span> },
        <span class="cm-def">South</span> =&gt; <span class="cm-def">Point</span> { <span class="cm-variable">x</span>:  <span class="cm-number">0</span><span class="cm-variable">f</span>, <span class="cm-variable">y</span>: -<span class="cm-number">1</span><span class="cm-variable">f</span> },
        <span class="cm-def">West</span>  =&gt; <span class="cm-def">Point</span> { <span class="cm-variable">x</span>: -<span class="cm-number">1</span><span class="cm-variable">f</span>, <span class="cm-variable">y</span>:  <span class="cm-number">0</span><span class="cm-variable">f</span> }
    }
}
</pre>

<p>열거값은 구조체가 될 수 있다. 다음을 살펴보자.</p>
<pre class="cm-s-default"><span class="cm-keyword">enum</span> <span class="cm-def">Shape</span> {
    <span class="cm-def">Circle</span> { <span class="cm-def">center</span>: <span class="cm-def">Point</span>, <span class="cm-def">radius</span>: <span class="cm-def">float</span> },
    <span class="cm-variable">Rectangle</span> { <span class="cm-variable">top_left</span>: <span class="cm-variable">Point</span>, <span class="cm-variable">bottom_right</span>: <span class="cm-variable">Point</span> }
}
<span class="cm-keyword">fn</span> <span class="cm-def">area</span>(<span class="cm-def">sh</span>: <span class="cm-variable-3">Shape</span>) -&gt; <span class="cm-keyword">float</span> {
    <span class="cm-keyword">match</span> <span class="cm-variable">sh</span> {
        <span class="cm-def">Circle</span> { <span class="cm-variable">radius</span>: <span class="cm-variable">radius</span>, <span class="cm-variable">_</span> } =&gt; <span class="cm-variable-2">float::consts::</span><span class="cm-def">pi</span> * <span class="cm-def">square</span>(<span class="cm-def">radius</span>),
        <span class="cm-def">Rectangle</span> { <span class="cm-variable">top_left</span>: <span class="cm-variable">top_left</span>, <span class="cm-variable">bottom_right</span>: <span class="cm-variable">bottom_right</span> } =&gt; {
            (<span class="cm-def">bottom_right</span>.<span class="cm-variable">x</span> - <span class="cm-variable">top_left</span>.<span class="cm-variable">x</span>) * (<span class="cm-variable">bottom_right</span>.<span class="cm-variable">y</span> - <span class="cm-variable">top_left</span>.<span class="cm-variable">y</span>)
        }
    }
}
</pre>

<h2 id="튜플"><a href="#튜플"><span class="header-section-number">5.3</span> 튜플</a></h2>
<p>Rust에서 튜플은 필드가 이름을 갖지 않는 것만 제외하면 정확히 구조체처럼 행동한다. 그래서, 점 표기로 필드에 접근할 수 없다. 튜플은 0을 제외한 어떤 숫자라도 인자로 받을 수 있다. (n개를 생각하더라도, 원한다면 빈 튜플 <code>()</code>로도 만들 수 있다).</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">mytup</span>: (<span class="cm-keyword">int</span>, <span class="cm-keyword">int</span>, <span class="cm-keyword">float</span>) = (<span class="cm-number">10</span>, <span class="cm-number">20</span>, <span class="cm-number">30.0</span>);
<span class="cm-keyword">match</span> <span class="cm-variable">mytup</span> {
  (<span class="cm-def">a</span>, <span class="cm-def">b</span>, <span class="cm-def">c</span>) =&gt; <span class="cm-def">info</span>!(<span class="cm-def">a</span> + <span class="cm-variable">b</span> + (<span class="cm-variable">c</span> <span class="cm-keyword">as</span> <span class="cm-variable">int</span>))
}
</pre>

<h2 id="튜플-구조체"><a href="#튜플-구조체"><span class="header-section-number">5.4</span> 튜플 구조체</a></h2>
<p>또한 Rust는 구조체와 튜플로 행동하는 <em>tuple structs</em>를 가진다, except that, 튜플과 다르게, 튜플 구조체는 이름을 가지고(그래서 <code>Foo(1, 2)</code>는 <code>Bar(1, 2)</code>와 서로 다른 타입이다.), 튜플 구조체의 <em>필드</em>는 이름을 가지지 않는다.</p>
<pre class="cm-s-default"><span class="cm-keyword">struct</span> <span class="cm-variable">MyTup</span>(<span class="cm-variable">int</span>, <span class="cm-variable">int</span>, <span class="cm-variable">float</span>);
<span class="cm-keyword">let</span> <span class="cm-def">mytup</span>: <span class="cm-variable-3">MyTup</span> = <span class="cm-variable">MyTup</span>(<span class="cm-number">10</span>, <span class="cm-number">20</span>, <span class="cm-number">30.0</span>);
<span class="cm-keyword">match</span> <span class="cm-variable">mytup</span> {
  <span class="cm-def">MyTup</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>, <span class="cm-def">c</span>) =&gt; <span class="cm-def">info</span>!(<span class="cm-def">a</span> + <span class="cm-variable">b</span> + (<span class="cm-variable">c</span> <span class="cm-keyword">as</span> <span class="cm-variable">int</span>))
}
</pre>

<p><a name="newtype"></a></p>
<p>때때로 &quot;newtypes&quot;라고 불리는 하나의 필드를 가지는 튜플 구조체를 위한 특수한 경우가 있다. (Haskell의 &quot;newtype&quot; 기능에서 영향을 받음). 새로운 이름은 기존 타입의 동의어뿐만 아니라 오히려 자신의 독특한 타입을 가지는 방식으로 새로운 타입을 정의하곤 했다.</p>
<pre class="cm-s-default"><span class="cm-keyword">struct</span> <span class="cm-variable">GizmoId</span>(<span class="cm-variable">int</span>);
</pre>

<p>편의상, 역참조 (<code>*</code>) 단항 연산자를 이용해 구조체의 내용을 추출할 수 있다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">my_gizmo_id</span>: <span class="cm-variable-3">GizmoId</span> = <span class="cm-variable">GizmoId</span>(<span class="cm-number">10</span>);
<span class="cm-keyword">let</span> <span class="cm-def">id_int</span>: <span class="cm-keyword">int</span> = *<span class="cm-variable">my_gizmo_id</span>;
</pre>

<p>이와같은 타입은 동일한 타입을 가지는 데이터 사이를 구분하기 유용할 수 있지만, 다른 방법이 사용되어야 한다.</p>
<pre class="cm-s-default"><span class="cm-keyword">struct</span> <span class="cm-variable">Inches</span>(<span class="cm-variable">int</span>);
<span class="cm-keyword">struct</span> <span class="cm-variable">Centimeters</span>(<span class="cm-variable">int</span>);
</pre>

<p>위의 정의는 프로그램에서 다른 단위에 해당하는 혼란스러운 숫자를 피하도록 허용하는 단순한 방법이다.</p>
<h1 id="함수"><a href="#함수"><span class="header-section-number">6</span> 함수</a></h1>
<p>우리는 이미 몇가지 함수 정의를 보았다. <code>type</code>과 같이 다른 모든 정적인 선언처럼, 함수는 최상위와 다른 함수 내부 (또는 모듈 내부, <a href="#modules-and-crates">뒤에서</a> 살펴볼 것임)에서 선언될 수 있다. <code>fn</code> 키워드는 함수를 뜻한다. 함수는 괄호 안에 쉼표로 구분된 <code>expr: type</code> 쌍의 인자 목록을 가진다. 화살표 <code>-&gt;</code>는 인자 목록과 함수의 반환 타입을 구분한다.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">line</span>(<span class="cm-def">a</span>: <span class="cm-keyword">int</span>, <span class="cm-def">b</span>: <span class="cm-keyword">int</span>, <span class="cm-def">x</span>: <span class="cm-keyword">int</span>) -&gt; <span class="cm-keyword">int</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable">a</span> * <span class="cm-variable">x</span> + <span class="cm-variable">b</span>;
}
</pre>

<p><code>return</code> 키워드는 함수의 몸통에서 즉시 반환한다. 선택적으로 반환하기 위한 표현식이 따라온다. 함수는 표현식을 생성하는 함수의 최상위 블록을 가짐으로써 값을 반환할 수 있다.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">line</span>(<span class="cm-def">a</span>: <span class="cm-keyword">int</span>, <span class="cm-def">b</span>: <span class="cm-keyword">int</span>, <span class="cm-def">x</span>: <span class="cm-keyword">int</span>) -&gt; <span class="cm-keyword">int</span> {
    <span class="cm-variable">a</span> * <span class="cm-variable">x</span> + <span class="cm-variable">b</span>
}
</pre>

<p>반환값을 적기위한 방식으로는 명식적으로 <code>return</code>이라고 적는 것보다 Rust 스타일이 더 낫다. <code>return</code>은 함수에서 일찍 반환할때 활용된다. 값을 반환하지 않는 함수는 nil <code>()</code>이 반환된다고 하고, 반환 타입과 반환 값 둘다 정의에서 생략될 수 있다. 다음의 두 함수는 동일하다.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">do_nothing_the_hard_way</span>() -&gt; () { <span class="cm-keyword">return</span> (); }

<span class="cm-keyword">fn</span> <span class="cm-def">do_nothing_the_easy_way</span>() { }
</pre>

<p>함수의 끝에 있는 세미콜론은 <code>()</code>을 반환하는 것과 같다.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">line</span>(<span class="cm-def">a</span>: <span class="cm-keyword">int</span>, <span class="cm-def">b</span>: <span class="cm-keyword">int</span>, <span class="cm-def">x</span>: <span class="cm-keyword">int</span>) -&gt; <span class="cm-keyword">int</span> { <span class="cm-variable">a</span> * <span class="cm-variable">x</span> + <span class="cm-variable">b</span>  }
<span class="cm-keyword">fn</span> <span class="cm-def">oops</span>(<span class="cm-def">a</span>: <span class="cm-keyword">int</span>, <span class="cm-def">b</span>: <span class="cm-keyword">int</span>, <span class="cm-def">x</span>: <span class="cm-keyword">int</span>) -&gt; ()  { <span class="cm-variable">a</span> * <span class="cm-variable">x</span> + <span class="cm-variable">b</span>; }

<span class="cm-keyword">assert</span>!(<span class="cm-number">8</span> == <span class="cm-variable">line</span>(<span class="cm-number">5</span>, <span class="cm-number">3</span>, <span class="cm-number">1</span>));
<span class="cm-keyword">assert</span>!(() == <span class="cm-variable">oops</span>(<span class="cm-number">5</span>, <span class="cm-number">3</span>, <span class="cm-number">1</span>));
</pre>

<p><code>match</code> 표현식과 <code>let</code> 바인딩으로, 함수 인자는 구조파괴 패턴을 지원한다. 튜플로부터 처음 값을 풀고 반환하는 이 예제를 보면 <code>let</code>처럼, 인자 패턴은 반박될 수 없다.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">first</span>((<span class="cm-variable">value</span>, <span class="cm-def">_</span>): (<span class="cm-def">int</span>, <span class="cm-def">float</span>)) -&gt; <span class="cm-keyword">int</span> { <span class="cm-variable">value</span> }
</pre>

<h1 id="소멸자"><a href="#소멸자"><span class="header-section-number">7</span> 소멸자</a></h1>
<p><em>소멸자</em>는 객체에 더 이상 접근할 수 없을때, 객체에서 사용된 자원을 정리하는 것을 담당하는 함수이다. 소멸자는 파일, 소켓 그리고 힙 메모리와 같은 자원의 해제를 처리하는 내용이 정의될 수 있다.</p>
<p>객체는 자신의 소멸자가 호출된 이후에는 접근할 수 없기 때문에, 해제된 자원에 접근하는 동적인 실패가 없다. 작업이 실패했을 때, 태스크 내부의 모든 객체의 소멸자가 호출된다.</p>
<p><code>~</code>는 힙에서 메모리 할당을 위한 유일한 처리를 나타낸다.</p>
<pre class="cm-s-default">{
    <span class="cm-comment">// an integer allocated on the heap</span>
    <span class="cm-keyword">let</span> <span class="cm-def">y</span> = <span class="cm-variable">~10</span>;
}
<span class="cm-comment">// the destructor frees the heap memory as soon as `y` goes out of scope</span>
</pre>

<p>흔하게 사용되기 때문에 Rust는 언어 차원에서 힙 메모리 할당을 위한 문법을 포함하지만, 동일한 의미로 타입에 따른 맞춤 소멸자가 구현될 수 있다.</p>
<h1 id="소유권"><a href="#소유권"><span class="header-section-number">8</span> 소유권</a></h1>
<p>Rust는 변수나 태스크에 국한된 가비지 컬렉터에 대한 객체의 생명주기의 관리를 위임하는 객체 소유권의 개념을 형식화한다. 객체의 소유자는 소멸자를 호출하여 객체의 생명주기를 관리하고, 객체가 변할 수 있는지 판단할 책임이 있다.</p>
<p>소유권은 재귀적이기 때문에, 변화성은 재귀적으로 상속되고 소멸자는 소유된 객체 트리가 가지고 있는 것들을 파괴한다. 변수는 최상위 소유자이고 포함된 객체가 스코프를 벗어낫을 때 파괴된다. 가비지 컬렉터에 의해 관리되는 박스는 새로운 소유권 트리를 시작하고, 소멸자는 수집될 때 호출된다.</p>
<pre class="cm-s-default"><span class="cm-comment">// 구조체는 `x`와 `y` 필드에 포함된 객체를 소유한다.</span>
<span class="cm-keyword">struct</span> <span class="cm-variable">Foo</span> { <span class="cm-variable">x</span>: <span class="cm-variable">int</span>, <span class="cm-variable">y</span>: <span class="cm-variable">~int</span> }

{
    <span class="cm-comment">// `a`는 구조체의 소유자이고, 그래서 구조체의 필드의 소유자이다.</span>
    <span class="cm-keyword">let</span> <span class="cm-def">a</span> = <span class="cm-variable">Foo</span> { <span class="cm-variable">x</span>: <span class="cm-number">5</span>, <span class="cm-variable">y</span>: <span class="cm-variable">~10</span> };
}
<span class="cm-comment">// `a`가 스코프를 벗어나면, 구조체 필드의 `~int` 소멸자가 호출된다.</span>

<span class="cm-comment">// `b`는 값이 변경될 수 있고, 값의 변경성은 객체의 소유권에 따라 상속된다.</span>
<span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">b</span> = <span class="cm-variable">Foo</span> { <span class="cm-variable">x</span>: <span class="cm-number">5</span>, <span class="cm-variable">y</span>: <span class="cm-variable">~10</span> };
<span class="cm-variable">b</span>.<span class="cm-variable">x</span> = <span class="cm-number">10</span>;
</pre>

<p>객체가 쓰레기가 수집된 박스를 가지지 않으면, 객체는 하나의 소유권 트리로 구성되고 태스크 사이로 전달되는 것을 허용하는 <code>Owned</code> 특징이 주어진다. 맞춤 소멸자는 <code>Owned</code> 타입에만 직접적으로 구현될 수 있으나, 쓰레기 수집된 박스는 맞춤 소멸자를 갖는 타입을 여전히 <em>포함</em>할 수 있다.</p>
<h1 id="박스"><a href="#박스"><span class="header-section-number">9</span> 박스</a></h1>
<p>기본적으로 많은 현대의 언어들은 값을 힙 메모리를 가리키는 포인터로 나타낸다. 대조적으로, Rust는 C와 C++처럼 직접적으로 해당 타입을 나타낸다. 달리 말하자면 Rust에서 데이터를 모으는 것은 <em>unboxed</em>라고 한다. 이는 <code>let x = Point { x: 1f, y: 1f };</code>라고 하면, 스택상에 구조체를 생성함을 뜻한다. 자료 구조로 복사한다면, 포인터가 아닌 구조체 전체를 복사한다.</p>
<p>일반적으로 <code>Point</code>와 같은 작은 구조체에서는 메모리에 할당하는 것과 포인터를 통해 간접적으로 가리키는것 보다 더 호율적이다. 그러나 큰 구조체나 변경될 수 있는 상태에서는, 스택이나 힙 상에서 단일 복사하고, 포인터를 통해 가리키는 것이 유용할 수 있다.</p>
<h2 id="소유된-박스"><a href="#소유된-박스"><span class="header-section-number">9.1</span> 소유된 박스</a></h2>
<p>소유된 박스(<code>~</code>)는 힙 상에서 유일하게 소유된 할당이다. 박스가 없으면 변경가능성과 소유자의 생명주기를 상속받는다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">x</span> = <span class="cm-number">5</span>; <span class="cm-comment">// 변경 불가능</span>
<span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">y</span> = <span class="cm-number">5</span>; <span class="cm-comment">// 변경 가능</span>
<span class="cm-variable">y</span> += <span class="cm-number">2</span>;

<span class="cm-keyword">let</span> <span class="cm-def">x</span> = <span class="cm-variable">~5</span>; <span class="cm-comment">// 변경 불가능</span>
<span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">y</span> = <span class="cm-variable">~5</span>; <span class="cm-comment">// 변경 가능</span>
*<span class="cm-variable">y</span> += <span class="cm-number">2</span>; <span class="cm-comment">// * 연산자는 가지고 있는 값에 접근하기 위해 필요하다.</span>
</pre>

<p>소유된 박스의 목적은 재귀적인 자료 구조를 생성하거나 포인터보다 더 큰 객체를 싸게 전달하기 위해 간접 층을 추가하는 것이다. 소유된 box는 유일한 소유주를 갖기 때문에, 트리 자료 구조로 나타내어질 수 있었다.</p>
<p>다음의 구조체는 컴파일되지 않을것이다. 왜냐하면 간접의 누락은 구조체가 무한 크기를 갖는다는 것을 의미할 것이기 때문이다.</p>
<pre class="cm-s-default"><span class="cm-keyword">struct</span> <span class="cm-variable">Foo</span> {
    <span class="cm-variable">child</span>: <span class="cm-variable">Option</span>&lt;<span class="cm-variable">Foo</span>&gt;
}
</pre>

<blockquote>
<p><strong><em>노트:</em></strong> <code>Option</code> 타입은 <em>선택적</em> 값을 나타내는 열거형이다. 이는 많은 다른 언어에서의 null이 가능한 포인터와 비교되지만, contained value unboxed 를 저장한다.</p>
</blockquote>
<p>간접이 포함된 소유된 포인터는 힙 상에서 구조체의 외부에 자식을 할당한다, which 유한한 크기를 가지고 컴파일 타임에 오류가 발생하지 않는:</p>
<pre class="cm-s-default"><span class="cm-keyword">struct</span> <span class="cm-variable">Foo</span> {
    <span class="cm-variable">child</span>: <span class="cm-variable">Option</span>&lt;<span class="cm-variable">~Foo</span>&gt;
}
</pre>

<h2 id="관리되는-박스"><a href="#관리되는-박스"><span class="header-section-number">9.2</span> 관리되는 박스</a></h2>
<p>관리되는 박스(<code>@</code>)는 태스크 로컬 쓰레기 수집기에 의해 관리되는 생명주기를 포함한 힙 할당이다. 태스크가 끝나기 전에 박스로 남은 참조가 없으면 어떤 포인터는 소멸될 것이다. 관리되는 박스는 소유자가 없고, 그래서 새로운 소유권 트리를 시작하고 변경가능성을 상속하지 않는다. 관리되는 박스는 포함된 객체를 소유하고, 변경가능성은 공유되는 박스(<code>@</code> 또는 <code>@mut</code>)의 타입에 의해 정의된다. 관리되는 박스에 포함된 객체는 <code>Owned</code>가 아니고, 태스크 간에 전송될 수 없다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">a</span> = @<span class="cm-number">5</span>; <span class="cm-comment">// 변경 불가</span>

<span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">b</span> = @<span class="cm-number">5</span>; <span class="cm-comment">// 변경 가능한 변수, 변경 불가능한 박스</span>
<span class="cm-variable">b</span> = @<span class="cm-number">10</span>;

<span class="cm-keyword">let</span> <span class="cm-def">c</span> = @<span class="cm-variable">mut</span> <span class="cm-number">5</span>; <span class="cm-comment">// 변경 불가능한 변수, 변경 가능한 박스</span>
*<span class="cm-variable">c</span> = <span class="cm-number">10</span>;

<span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">d</span> = @<span class="cm-variable">mut</span> <span class="cm-number">5</span>; <span class="cm-comment">// 변경 가능한 변수, 변경 가능한 박스</span>
*<span class="cm-variable">d</span> += <span class="cm-number">5</span>;
<span class="cm-variable">d</span> = @<span class="cm-variable">mut</span> <span class="cm-number">15</span>;
</pre>

<p>변경가능한 변수와 변경불가능한 변수는 타입이 호환된다면 같은 박스를 가리킬 수 있다. 박스의 변경가능성은 그 타입의 속성이지만, 가변의 핸들 예제에서 불변의 박스가 가변의 박스로의 참조는 할당될 수 없다.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">a</span> = @<span class="cm-number">1</span>;     <span class="cm-comment">// 불변 박스</span>
<span class="cm-keyword">let</span> <span class="cm-def">b</span> = @<span class="cm-variable">mut</span> <span class="cm-number">2</span>; <span class="cm-comment">// 가변 박스</span>

<span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">c</span> : @<span class="cm-keyword">int</span>;       <span class="cm-comment">// declare a variable with type managed immutable int</span>
<span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">d</span> : @<span class="cm-variable-3">mut</span> <span class="cm-keyword">int</span>;   <span class="cm-comment">// and one of type managed mutable int</span>

<span class="cm-variable">c</span> = <span class="cm-variable">a</span>;          <span class="cm-comment">// box type is the same, okay</span>
<span class="cm-variable">d</span> = <span class="cm-variable">b</span>;          <span class="cm-comment">// box type is the same, okay</span>
</pre>

<pre class="cm-s-default"><span class="cm-comment">// but b cannot be assigned to c, or a to d</span>
<span class="cm-variable">c</span> = <span class="cm-variable">b</span>;          <span class="cm-comment">// error</span>
</pre>

<h1 id="move-semantics"><a href="#move-semantics"><span class="header-section-number">10</span> Move semantics</a></h1>
<p>Rust uses a shallow copy for parameter passing, assignment and returning values from functions. A shallow copy is considered a move of ownership if the ownership tree of the copied value includes an owned box or a type with a custom destructor. After a value has been moved, it can no longer be used from the source location and will not be destroyed there.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">x</span> = <span class="cm-variable">~5</span>;
<span class="cm-keyword">let</span> <span class="cm-def">y</span> = <span class="cm-variable">x</span>.<span class="cm-variable">clone</span>(); <span class="cm-comment">// y is a newly allocated box</span>
<span class="cm-keyword">let</span> <span class="cm-def">z</span> = <span class="cm-variable">x</span>; <span class="cm-comment">// no new memory allocated, x can no longer be used</span>
</pre>

<p>Since in owned boxes mutability is a property of the owner, not the box, mutable boxes may become immutable when they are moved, and vice-versa.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">r</span> = <span class="cm-variable">~13</span>;
<span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">s</span> = <span class="cm-variable">r</span>; <span class="cm-comment">// box becomes mutable</span>
*<span class="cm-variable">s</span> += <span class="cm-number">1</span>;
<span class="cm-keyword">let</span> <span class="cm-def">t</span> = <span class="cm-variable">s</span>; <span class="cm-comment">// box becomes immutable</span>
</pre>

<h1 id="borrowed-pointers"><a href="#borrowed-pointers"><span class="header-section-number">11</span> Borrowed pointers</a></h1>
<p>Rust's borrowed pointers are a general purpose reference type. In contrast with owned boxes, where the holder of an owned box is the owner of the pointed-to memory, borrowed pointers never imply ownership. A pointer can be borrowed to any object, and the compiler verifies that it cannot outlive the lifetime of the object.</p>
<p>As an example, consider a simple struct type, <code>Point</code>:</p>
<pre class="cm-s-default"><span class="cm-keyword">struct</span> <span class="cm-variable">Point</span> {
    <span class="cm-variable">x</span>: <span class="cm-variable">float</span>,
    <span class="cm-variable">y</span>: <span class="cm-variable">float</span>
}
</pre>

<p>We can use this simple definition to allocate points in many different ways. For example, in this code, each of these three local variables contains a point, but allocated in a different location:</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">on_the_stack</span> : <span class="cm-variable-3">Point</span>  =  <span class="cm-variable">Point</span> { <span class="cm-variable">x</span>: <span class="cm-number">3.0</span>, <span class="cm-variable">y</span>: <span class="cm-number">4.0</span> };
<span class="cm-keyword">let</span> <span class="cm-def">managed_box</span>  : @<span class="cm-variable-3">Point</span> = @<span class="cm-variable">Point</span> { <span class="cm-variable">x</span>: <span class="cm-number">5.0</span>, <span class="cm-variable">y</span>: <span class="cm-number">1.0</span> };
<span class="cm-keyword">let</span> <span class="cm-def">owned_box</span>    : <span class="cm-variable-3">~Point</span> = <span class="cm-variable">~Point</span> { <span class="cm-variable">x</span>: <span class="cm-number">7.0</span>, <span class="cm-variable">y</span>: <span class="cm-number">9.0</span> };
</pre>

<p>Suppose we wanted to write a procedure that computed the distance between any two points, no matter where they were stored. For example, we might like to compute the distance between <code>on_the_stack</code> and <code>managed_box</code>, or between <code>managed_box</code> and <code>owned_box</code>. One option is to define a function that takes two arguments of type point—that is, it takes the points by value. But this will cause the points to be copied when we call the function. For points, this is probably not so bad, but often copies are expensive or, worse, if there are mutable fields, they can change the semantics of your program. So we’d like to define a function that takes the points by pointer. We can use borrowed pointers to do this:</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">compute_distance</span>(<span class="cm-def">p1</span>: &amp;<span class="cm-variable-3">Point</span>, <span class="cm-def">p2</span>: &amp;<span class="cm-variable-3">Point</span>) -&gt; <span class="cm-keyword">float</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">x_d</span> = <span class="cm-variable">p1</span>.<span class="cm-variable">x</span> - <span class="cm-variable">p2</span>.<span class="cm-variable">x</span>;
    <span class="cm-keyword">let</span> <span class="cm-def">y_d</span> = <span class="cm-variable">p1</span>.<span class="cm-variable">y</span> - <span class="cm-variable">p2</span>.<span class="cm-variable">y</span>;
    <span class="cm-variable">sqrt</span>(<span class="cm-variable">x_d</span> * <span class="cm-variable">x_d</span> + <span class="cm-variable">y_d</span> * <span class="cm-variable">y_d</span>)
}
</pre>

<p>Now we can call <code>compute_distance()</code> in various ways:</p>
<pre class="cm-s-default"><span class="cm-variable">compute_distance</span>(&amp;<span class="cm-variable">on_the_stack</span>, <span class="cm-variable">managed_box</span>);
<span class="cm-variable">compute_distance</span>(<span class="cm-variable">managed_box</span>, <span class="cm-variable">owned_box</span>);
</pre>

<p>Here the <code>&amp;</code> operator is used to take the address of the variable <code>on_the_stack</code>; this is because <code>on_the_stack</code> has the type <code>Point</code> (that is, a struct value) and we have to take its address to get a value. We also call this <em>borrowing</em> the local variable <code>on_the_stack</code>, because we are creating an alias: that is, another route to the same data.</p>
<p>In the case of the boxes <code>managed_box</code> and <code>owned_box</code>, however, no explicit action is necessary. The compiler will automatically convert a box like <code>@point</code> or <code>~point</code> to a borrowed pointer like <code>&amp;point</code>. This is another form of borrowing; in this case, the contents of the managed/owned box are being lent out.</p>
<p>Whenever a value is borrowed, there are some limitations on what you can do with the original. For example, if the contents of a variable have been lent out, you cannot send that variable to another task, nor will you be permitted to take actions that might cause the borrowed value to be freed or to change its type. This rule should make intuitive sense: you must wait for a borrowed value to be returned (that is, for the borrowed pointer to go out of scope) before you can make full use of it again.</p>
<p>For a more in-depth explanation of borrowed pointers, read the <a href="tutorial-borrowed-ptr.html">borrowed pointer tutorial</a>.</p>
<h2 id="freezing"><a href="#freezing"><span class="header-section-number">11.1</span> Freezing</a></h2>
<p>Borrowing an immutable pointer to an object freezes it and prevents mutation. <code>Owned</code> objects have freezing enforced statically at compile-time.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">x</span> = <span class="cm-number">5</span>;
{
    <span class="cm-keyword">let</span> <span class="cm-def">y</span> = &amp;<span class="cm-variable">x</span>; <span class="cm-comment">// x is now frozen, it cannot be modified</span>
}
<span class="cm-comment">// x is now unfrozen again</span>
</pre>

<p>Mutable managed boxes handle freezing dynamically when any of their contents are borrowed, and the task will fail if an attempt to modify them is made while they are frozen:</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">x</span> = @<span class="cm-variable">mut</span> <span class="cm-number">5</span>;
<span class="cm-keyword">let</span> <span class="cm-def">y</span> = <span class="cm-variable">x</span>;
{
    <span class="cm-keyword">let</span> <span class="cm-def">z</span> = &amp;*<span class="cm-variable">y</span>; <span class="cm-comment">// the managed box is now frozen</span>
    <span class="cm-comment">// modifying it through x or y will cause a task failure</span>
}
<span class="cm-comment">// the box is now unfrozen again</span>
</pre>

<h1 id="dereferencing-pointers"><a href="#dereferencing-pointers"><span class="header-section-number">12</span> Dereferencing pointers</a></h1>
<p>Rust uses the unary star operator (<code>*</code>) to access the contents of a box or pointer, similarly to C.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">managed</span> = @<span class="cm-number">10</span>;
<span class="cm-keyword">let</span> <span class="cm-def">owned</span> = <span class="cm-variable">~20</span>;
<span class="cm-keyword">let</span> <span class="cm-def">borrowed</span> = &amp;<span class="cm-number">30</span>;

<span class="cm-keyword">let</span> <span class="cm-def">sum</span> = *<span class="cm-variable">managed</span> + *<span class="cm-variable">owned</span> + *<span class="cm-variable">borrowed</span>;
</pre>

<p>Dereferenced mutable pointers may appear on the left hand side of assignments. Such an assignment modifies the value that the pointer points to.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">managed</span> = @<span class="cm-variable">mut</span> <span class="cm-number">10</span>;
<span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">owned</span> = <span class="cm-variable">~20</span>;

<span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">value</span> = <span class="cm-number">30</span>;
<span class="cm-keyword">let</span> <span class="cm-def">borrowed</span> = &amp;<span class="cm-variable">mut</span> <span class="cm-variable">value</span>;

*<span class="cm-variable">managed</span> = *<span class="cm-variable">owned</span> + <span class="cm-number">10</span>;
*<span class="cm-variable">owned</span> = *<span class="cm-variable">borrowed</span> + <span class="cm-number">100</span>;
*<span class="cm-variable">borrowed</span> = *<span class="cm-variable">managed</span> + <span class="cm-number">1000</span>;
</pre>

<p>Pointers have high operator precedence, but lower precedence than the dot operator used for field and method access. This precedence order can sometimes make code awkward and parenthesis-filled.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">start</span> = @<span class="cm-variable">Point</span> { <span class="cm-variable">x</span>: <span class="cm-number">10</span><span class="cm-variable">f</span>, <span class="cm-variable">y</span>: <span class="cm-number">20</span><span class="cm-variable">f</span> };
<span class="cm-keyword">let</span> <span class="cm-def">end</span> = <span class="cm-variable">~Point</span> { <span class="cm-variable">x</span>: (*<span class="cm-variable">start</span>).<span class="cm-variable">x</span> + <span class="cm-variable">100f</span>, <span class="cm-variable">y</span>: (*<span class="cm-variable">start</span>).<span class="cm-variable">y</span> + <span class="cm-variable">100f</span> };
<span class="cm-keyword">let</span> <span class="cm-def">rect</span> = &amp;<span class="cm-variable">Rectangle</span>(*<span class="cm-variable">start</span>, *<span class="cm-variable">end</span>);
<span class="cm-keyword">let</span> <span class="cm-def">area</span> = (*<span class="cm-variable">rect</span>).<span class="cm-variable">area</span>();
</pre>

<p>To combat this ugliness the dot operator applies <em>automatic pointer dereferencing</em> to the receiver (the value on the left-hand side of the dot), so in most cases, explicitly dereferencing the receiver is not necessary.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">start</span> = @<span class="cm-variable">Point</span> { <span class="cm-variable">x</span>: <span class="cm-number">10</span><span class="cm-variable">f</span>, <span class="cm-variable">y</span>: <span class="cm-number">20</span><span class="cm-variable">f</span> };
<span class="cm-keyword">let</span> <span class="cm-def">end</span> = <span class="cm-variable">~Point</span> { <span class="cm-variable">x</span>: <span class="cm-variable">start</span>.<span class="cm-variable">x</span> + <span class="cm-number">100</span><span class="cm-variable">f</span>, <span class="cm-variable">y</span>: <span class="cm-variable">start</span>.<span class="cm-variable">y</span> + <span class="cm-number">100</span><span class="cm-variable">f</span> };
<span class="cm-keyword">let</span> <span class="cm-def">rect</span> = &amp;<span class="cm-variable">Rectangle</span>(*<span class="cm-variable">start</span>, *<span class="cm-variable">end</span>);
<span class="cm-keyword">let</span> <span class="cm-def">area</span> = <span class="cm-variable">rect</span>.<span class="cm-variable">area</span>();
</pre>

<p>You can write an expression that dereferences any number of pointers automatically. For example, if you felt inclined, you could write something silly like</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">point</span> = &amp;@<span class="cm-variable">~Point</span> { <span class="cm-variable">x</span>: <span class="cm-number">10</span><span class="cm-variable">f</span>, <span class="cm-variable">y</span>: <span class="cm-number">20</span><span class="cm-variable">f</span> };
<span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-variable">fmt</span>!(<span class="cm-string">&quot;%f&quot;</span>, <span class="cm-variable">point</span>.<span class="cm-variable">x</span>));
</pre>

<p>The indexing operator (<code>[]</code>) also auto-dereferences.</p>
<h1 id="vectors-and-strings"><a href="#vectors-and-strings"><span class="header-section-number">13</span> Vectors and strings</a></h1>
<p>A vector is a contiguous section of memory containing zero or more values of the same type. Like other types in Rust, vectors can be stored on the stack, the local heap, or the exchange heap. Borrowed pointers to vectors are also called 'slices'.</p>
<pre class="cm-s-default"><span class="cm-comment">// A fixed-size stack vector</span>
<span class="cm-keyword">let</span> <span class="cm-def">stack_crayons</span>: [<span class="cm-variable-3">Crayon</span>, ..<span class="cm-number">3</span>] = [<span class="cm-variable">Almond</span>, <span class="cm-variable">AntiqueBrass</span>, <span class="cm-variable">Apricot</span>];

<span class="cm-comment">// A borrowed pointer to stack-allocated vector</span>
<span class="cm-keyword">let</span> <span class="cm-def">stack_crayons</span>: &amp;[<span class="cm-variable-3">Crayon</span>] = &amp;[<span class="cm-variable">Aquamarine</span>, <span class="cm-variable">Asparagus</span>, <span class="cm-variable">AtomicTangerine</span>];

<span class="cm-comment">// A local heap (managed) vector of crayons</span>
<span class="cm-keyword">let</span> <span class="cm-def">local_crayons</span>: @[<span class="cm-variable-3">Crayon</span>] = @[<span class="cm-variable">BananaMania</span>, <span class="cm-variable">Beaver</span>, <span class="cm-variable">Bittersweet</span>];

<span class="cm-comment">// An exchange heap (owned) vector of crayons</span>
<span class="cm-keyword">let</span> <span class="cm-def">exchange_crayons</span>: <span class="cm-variable-3">~</span>[<span class="cm-def">Crayon</span>] = <span class="cm-variable">~</span>[<span class="cm-variable">Black</span>, <span class="cm-variable">BlizzardBlue</span>, <span class="cm-variable">Blue</span>];
</pre>

<p>The <code>+</code> operator means concatenation when applied to vector types.</p>
<pre class="cm-s-default">
<span class="cm-keyword">let</span> <span class="cm-def">my_crayons</span> = <span class="cm-variable">~</span>[<span class="cm-variable">Almond</span>, <span class="cm-variable">AntiqueBrass</span>, <span class="cm-variable">Apricot</span>];
<span class="cm-keyword">let</span> <span class="cm-def">your_crayons</span> = <span class="cm-variable">~</span>[<span class="cm-variable">BananaMania</span>, <span class="cm-variable">Beaver</span>, <span class="cm-variable">Bittersweet</span>];

<span class="cm-comment">// Add two vectors to create a new one</span>
<span class="cm-keyword">let</span> <span class="cm-def">our_crayons</span> = <span class="cm-variable">my_crayons</span> + <span class="cm-variable">your_crayons</span>;

<span class="cm-comment">// += will append to a vector, provided it lives in a mutable slot</span>
<span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">my_crayons</span> = <span class="cm-variable">my_crayons</span>;
<span class="cm-variable">my_crayons</span> += <span class="cm-variable">your_crayons</span>;
</pre>

<blockquote>
<p><strong><em>Note:</em></strong> The above examples of vector addition use owned vectors. Some operations on slices and stack vectors are not yet well-supported. Owned vectors are often the most usable.</p>
</blockquote>
<p>Square brackets denote indexing into a vector:</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">crayons</span>: [<span class="cm-variable-3">Crayon</span>, ..<span class="cm-number">3</span>] = [<span class="cm-variable">BananaMania</span>, <span class="cm-variable">Beaver</span>, <span class="cm-variable">Bittersweet</span>];
<span class="cm-keyword">match</span> <span class="cm-variable">crayons</span>[<span class="cm-number">0</span>] {
    <span class="cm-def">Bittersweet</span> =&gt; <span class="cm-def">draw_scene</span>(<span class="cm-def">crayons</span>[<span class="cm-number">0</span>]),
    <span class="cm-def">_</span> =&gt; ()
}
</pre>

<p>A vector can be destructured using pattern matching:</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">numbers</span>: [<span class="cm-keyword">int</span>, ..<span class="cm-number">3</span>] = [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>];
<span class="cm-keyword">let</span> <span class="cm-def">score</span> = <span class="cm-keyword">match</span> <span class="cm-variable">numbers</span> {
    [] =&gt; <span class="cm-number">0</span>,
    [<span class="cm-def">a</span>] =&gt; <span class="cm-def">a</span> * <span class="cm-number">10</span>,
    [<span class="cm-def">a</span>, <span class="cm-def">b</span>] =&gt; <span class="cm-def">a</span> * <span class="cm-number">6</span> + <span class="cm-def">b</span> * <span class="cm-number">4</span>,
    [<span class="cm-def">a</span>, <span class="cm-def">b</span>, <span class="cm-def">c</span>, ..<span class="cm-def">rest</span>] =&gt; <span class="cm-def">a</span> * <span class="cm-number">5</span> + <span class="cm-def">b</span> * <span class="cm-number">3</span> + <span class="cm-def">c</span> * <span class="cm-number">2</span> + <span class="cm-def">rest</span>.<span class="cm-def">len</span>() <span class="cm-keyword">as</span> <span class="cm-def">int</span>
};
</pre>

<p>The elements of a vector <em>inherit the mutability of the vector</em>, and as such, individual elements may not be reassigned when the vector lives in an immutable slot.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">crayons</span>: <span class="cm-variable-3">~</span>[<span class="cm-def">Crayon</span>] = <span class="cm-variable">~</span>[<span class="cm-variable">BananaMania</span>, <span class="cm-variable">Beaver</span>, <span class="cm-variable">Bittersweet</span>];

<span class="cm-variable">crayons</span>[<span class="cm-number">0</span>] = <span class="cm-variable">Apricot</span>; <span class="cm-comment">// ERROR: Can't assign to immutable vector</span>
</pre>

<p>Moving it into a mutable slot makes the elements assignable.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">crayons</span>: <span class="cm-variable-3">~</span>[<span class="cm-def">Crayon</span>] = <span class="cm-variable">~</span>[<span class="cm-variable">BananaMania</span>, <span class="cm-variable">Beaver</span>, <span class="cm-variable">Bittersweet</span>];

<span class="cm-comment">// Put the vector into a mutable slot</span>
<span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">mutable_crayons</span> = <span class="cm-variable">crayons</span>;

<span class="cm-comment">// Now it's mutable to the bone</span>
<span class="cm-variable">mutable_crayons</span>[<span class="cm-number">0</span>] = <span class="cm-variable">Apricot</span>;
</pre>

<p>This is a simple example of Rust's <em>dual-mode data structures</em>, also referred to as <em>freezing and thawing</em>.</p>
<p>Strings are implemented with vectors of <code>u8</code>, though they have a distinct type. They support most of the same allocation options as vectors, though the string literal without a storage sigil (for example, <code>&quot;foo&quot;</code>) is treated differently than a comparable vector (<code>[foo]</code>). Whereas plain vectors are stack-allocated fixed-length vectors, plain strings are borrowed pointers to read-only (static) memory. All strings are immutable.</p>
<pre class="cm-s-default"><span class="cm-comment">// A plain string is a slice to read-only (static) memory</span>
<span class="cm-keyword">let</span> <span class="cm-def">stack_crayons</span>: &amp;<span class="cm-keyword">str</span> = <span class="cm-string">&quot;Almond, AntiqueBrass, Apricot&quot;</span>;

<span class="cm-comment">// The same thing, but with the `&amp;`</span>
<span class="cm-keyword">let</span> <span class="cm-def">stack_crayons</span>: &amp;<span class="cm-keyword">str</span> = &amp;<span class="cm-string">&quot;Aquamarine, Asparagus, AtomicTangerine&quot;</span>;

<span class="cm-comment">// A local heap (managed) string</span>
<span class="cm-keyword">let</span> <span class="cm-def">local_crayons</span>: @<span class="cm-keyword">str</span> = @<span class="cm-string">&quot;BananaMania, Beaver, Bittersweet&quot;</span>;

<span class="cm-comment">// An exchange heap (owned) string</span>
<span class="cm-keyword">let</span> <span class="cm-def">exchange_crayons</span>: <span class="cm-variable-3">~str</span> = <span class="cm-variable">~</span><span class="cm-string">&quot;Black, BlizzardBlue, Blue&quot;</span>;
</pre>

<p>Both vectors and strings support a number of useful <a href="#functions-and-methods">methods</a>, defined in <a href="core/vec.html"><code>core::vec</code></a> and <a href="core/str.html"><code>core::str</code></a>. Here are some examples.</p>
<pre class="cm-s-default">
<span class="cm-keyword">let</span> <span class="cm-def">crayons</span> = [<span class="cm-variable">Almond</span>, <span class="cm-variable">AntiqueBrass</span>, <span class="cm-variable">Apricot</span>];

<span class="cm-comment">// Check the length of the vector</span>
<span class="cm-keyword">assert</span>!(<span class="cm-variable">crayons</span>.<span class="cm-variable">len</span>() == <span class="cm-number">3</span>);
<span class="cm-keyword">assert</span>!(!<span class="cm-variable">crayons</span>.<span class="cm-variable">is_empty</span>());

<span class="cm-comment">// Iterate over a vector, obtaining a pointer to each element</span>
<span class="cm-keyword">for</span> <span class="cm-def">crayons</span>.<span class="cm-variable">each</span> |<span class="cm-variable">crayon</span>| {
    <span class="cm-keyword">let</span> <span class="cm-def">delicious_crayon_wax</span> = <span class="cm-variable">unwrap_crayon</span>(*<span class="cm-variable">crayon</span>);
    <span class="cm-variable">eat_crayon_wax</span>(<span class="cm-variable">delicious_crayon_wax</span>);
}

<span class="cm-comment">// Map vector elements</span>
<span class="cm-keyword">let</span> <span class="cm-variable">crayon_names</span> = <span class="cm-variable">crayons</span>.<span class="cm-variable">map</span>(|<span class="cm-variable">v</span>| <span class="cm-variable">crayon_to_str</span>(*<span class="cm-variable">v</span>));
<span class="cm-keyword">let</span> <span class="cm-def">favorite_crayon_name</span> = <span class="cm-variable">crayon_names</span>[<span class="cm-number">0</span>];

<span class="cm-comment">// Remove whitespace from before and after the string</span>
<span class="cm-keyword">let</span> <span class="cm-def">new_favorite_crayon_name</span> = <span class="cm-variable">favorite_crayon_name</span>.<span class="cm-variable">trim</span>();

<span class="cm-keyword">if</span> <span class="cm-variable">favorite_crayon_name</span>.<span class="cm-variable">len</span>() &gt; <span class="cm-number">5</span> {
   <span class="cm-comment">// Create a substring</span>
   <span class="cm-variable">println</span>(<span class="cm-variable">favorite_crayon_name</span>.<span class="cm-variable">substr</span>(<span class="cm-number">0</span>, <span class="cm-number">5</span>));
}
</pre>

<h1 id="closures"><a href="#closures"><span class="header-section-number">14</span> Closures</a></h1>
<p>Named functions, like those we've seen so far, may not refer to local variables declared outside the function: they do not close over their environment (sometimes referred to as &quot;capturing&quot; variables in their environment). For example, you couldn't write the following:</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">foo</span> = <span class="cm-number">10</span>;

<span class="cm-keyword">fn</span> <span class="cm-def">bar</span>() -&gt; <span class="cm-keyword">int</span> {
   <span class="cm-keyword">return</span> <span class="cm-variable">foo</span>; <span class="cm-comment">// `bar` cannot refer to `foo`</span>
}
</pre>

<p>Rust also supports <em>closures</em>, functions that can access variables in the enclosing scope.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">call_closure_with_ten</span>(<span class="cm-def">b</span>: &amp;<span class="cm-keyword">fn</span>(<span class="cm-keyword">int</span>)) { <span class="cm-variable">b</span>(<span class="cm-number">10</span>); }

<span class="cm-keyword">let</span> <span class="cm-def">captured_var</span> = <span class="cm-number">20</span>;
<span class="cm-keyword">let</span> <span class="cm-def">closure</span> = |<span class="cm-variable">arg</span>| <span class="cm-variable">println</span>(<span class="cm-variable">fmt</span>!(<span class="cm-string">&quot;captured_var=%d, arg=%d&quot;</span>, <span class="cm-variable">captured_var</span>, <span class="cm-variable">arg</span>));

<span class="cm-variable">call_closure_with_ten</span>(<span class="cm-variable">closure</span>);
</pre>

<p>Closures begin with the argument list between vertical bars and are followed by a single expression. The types of the arguments are generally omitted, as is the return type, because the compiler can almost always infer them. In the rare case where the compiler needs assistance, though, the arguments and return types may be annotated.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">square</span> = |<span class="cm-variable">x</span>: <span class="cm-variable">int</span>| -&gt; <span class="cm-variable">uint</span> { <span class="cm-variable">x</span> * <span class="cm-variable">x</span> <span class="cm-keyword">as</span> <span class="cm-variable">uint</span> };
</pre>

<p>There are several forms of closure, each with its own role. The most common, called a <em>stack closure</em>, has type <code>&amp;fn</code> and can directly access local variables in the enclosing scope.</p>
<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">max</span> = <span class="cm-number">0</span>;
[<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>].<span class="cm-variable">map</span>(|<span class="cm-variable">x</span>| <span class="cm-keyword">if</span> *<span class="cm-variable">x</span> &gt; <span class="cm-variable">max</span> { <span class="cm-variable">max</span> = *<span class="cm-variable">x</span> });
</pre>

<p>Stack closures are very efficient because their environment is allocated on the call stack and refers by pointer to captured locals. To ensure that stack closures never outlive the local variables to which they refer, stack closures are not first-class. That is, they can only be used in argument position; they cannot be stored in data structures or returned from functions. Despite these limitations, stack closures are used pervasively in Rust code.</p>
<h2 id="managed-closures"><a href="#managed-closures"><span class="header-section-number">14.1</span> Managed closures</a></h2>
<p>When you need to store a closure in a data structure, a stack closure will not do, since the compiler will refuse to let you store it. For this purpose, Rust provides a type of closure that has an arbitrary lifetime, written <code>@fn</code> (boxed closure, analogous to the <code>@</code> pointer type described earlier). This type of closure <em>is</em> first-class.</p>
<p>A managed closure does not directly access its environment, but merely copies out the values that it closes over into a private data structure. This means that it can not assign to these variables, and cannot observe updates to them.</p>
<p>This code creates a closure that adds a given string to its argument, returns it from a function, and then calls it:</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">mk_appender</span>(<span class="cm-def">suffix</span>: <span class="cm-variable-3">~str</span>) -&gt; @<span class="cm-keyword">fn</span>(<span class="cm-variable-3">~str</span>) -&gt; <span class="cm-variable-3">~str</span> {
    <span class="cm-comment">// The compiler knows that we intend this closure to be of type @fn</span>
    <span class="cm-keyword">return</span> |<span class="cm-variable">s</span>| <span class="cm-variable">s</span> + <span class="cm-variable">suffix</span>;
}

<span class="cm-keyword">fn</span> <span class="cm-def">main</span>() {
    <span class="cm-keyword">let</span> <span class="cm-def">shout</span> = <span class="cm-variable">mk_appender</span>(<span class="cm-variable">~</span><span class="cm-string">&quot;!&quot;</span>);
    <span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-variable">shout</span>(<span class="cm-variable">~</span><span class="cm-string">&quot;hey ho, let's go&quot;</span>));
}
</pre>

<h2 id="owned-closures"><a href="#owned-closures"><span class="header-section-number">14.2</span> Owned closures</a></h2>
<p>Owned closures, written <code>~fn</code> in analogy to the <code>~</code> pointer type, hold on to things that can safely be sent between processes. They copy the values they close over, much like managed closures, but they also own them: that is, no other code can access them. Owned closures are used in concurrent code, particularly for spawning <a href="tutorial-tasks.html">tasks</a>.</p>
<h2 id="closure-compatibility"><a href="#closure-compatibility"><span class="header-section-number">14.3</span> Closure compatibility</a></h2>
<p>Rust closures have a convenient subtyping property: you can pass any kind of closure (as long as the arguments and return types match) to functions that expect a <code>&amp;fn()</code>. Thus, when writing a higher-order function that only calls its function argument, and does nothing else with it, you should almost always declare the type of that argument as <code>&amp;fn()</code>. That way, callers may pass any kind of closure.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">call_twice</span>(<span class="cm-def">f</span>: &amp;<span class="cm-keyword">fn</span>()) { <span class="cm-variable">f</span>(); <span class="cm-variable">f</span>(); }
<span class="cm-keyword">let</span> <span class="cm-def">closure</span> = || { <span class="cm-string">&quot;I'm a closure, and it doesn't matter what type I am&quot;</span>; };
<span class="cm-keyword">fn</span> <span class="cm-def">function</span>() { <span class="cm-string">&quot;I'm a normal function&quot;</span>; }
<span class="cm-variable">call_twice</span>(<span class="cm-variable">closure</span>);
<span class="cm-variable">call_twice</span>(<span class="cm-variable">function</span>);
</pre>

<blockquote>
<p><strong><em>Note:</em></strong> Both the syntax and the semantics will be changing in small ways. At the moment they can be unsound in some scenarios, particularly with non-copyable types.</p>
</blockquote>
<h2 id="do-syntax"><a href="#do-syntax"><span class="header-section-number">14.4</span> Do syntax</a></h2>
<p>The <code>do</code> expression provides a way to treat higher-order functions (functions that take closures as arguments) as control structures.</p>
<p>Consider this function that iterates over a vector of integers, passing in a pointer to each integer in the vector:</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">each</span>(<span class="cm-def">v</span>: &amp;[<span class="cm-keyword">int</span>], <span class="cm-def">op</span>: &amp;<span class="cm-keyword">fn</span>(<span class="cm-variable-3">v</span>: &amp;<span class="cm-keyword">int</span>)) {
   <span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">n</span> = <span class="cm-number">0</span>;
   <span class="cm-keyword">while</span> <span class="cm-variable">n</span> &lt; <span class="cm-variable">v</span>.<span class="cm-variable">len</span>() {
       <span class="cm-variable">op</span>(&amp;<span class="cm-variable">v</span>[<span class="cm-variable">n</span>]);
       <span class="cm-variable">n</span> += <span class="cm-number">1</span>;
   }
}
</pre>

<p>As an aside, the reason we pass in a <em>pointer</em> to an integer rather than the integer itself is that this is how the actual <code>each()</code> function for vectors works. <code>vec::each</code> though is a <a href="#generics">generic</a> function, so must be efficient to use for all types. Passing the elements by pointer avoids copying potentially large objects.</p>
<p>As a caller, if we use a closure to provide the final operator argument, we can write it in a way that has a pleasant, block-like structure.</p>
<pre class="cm-s-default"><span class="cm-variable">each</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>], |<span class="cm-variable">n</span>| {
    <span class="cm-variable">do_some_work</span>(<span class="cm-variable">n</span>);
});
</pre>

<p>This is such a useful pattern that Rust has a special form of function call that can be written more like a built-in control structure:</p>
<pre class="cm-s-default"><span class="cm-keyword">do</span> <span class="cm-variable">each</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>]) |<span class="cm-variable">n</span>| {
    <span class="cm-variable">do_some_work</span>(<span class="cm-variable">n</span>);
}
</pre>

<p>The call is prefixed with the keyword <code>do</code> and, instead of writing the final closure inside the argument list, it appears outside of the parentheses, where it looks more like a typical block of code.</p>
<p><code>do</code> is a convenient way to create tasks with the <code>task::spawn</code> function. <code>spawn</code> has the signature <code>spawn(fn: ~fn())</code>. In other words, it is a function that takes an owned closure that takes no arguments.</p>
<pre class="cm-s-default"><span class="cm-keyword">use</span> <span class="cm-variable-2">core::task::</span><span class="cm-variable">spawn</span>;

<span class="cm-keyword">do</span> <span class="cm-variable">spawn</span>() || {
    <span class="cm-variable">debug</span>!(<span class="cm-string">&quot;I'm a task, whatever&quot;</span>);
}
</pre>

<p>Look at all those bars and parentheses -- that's two empty argument lists back to back. Since that is so unsightly, empty argument lists may be omitted from <code>do</code> expressions.</p>
<pre class="cm-s-default"><span class="cm-keyword">do</span> <span class="cm-variable">spawn</span> {
   <span class="cm-variable">debug</span>!(<span class="cm-string">&quot;Kablam!&quot;</span>);
}
</pre>

<p>If you want to see the output of <code>debug!</code> statements, you will need to turn on <code>debug!</code> logging. To enable <code>debug!</code> logging, set the RUST_LOG environment variable to the name of your crate, which, for a file named <code>foo.rs</code>, will be <code>foo</code> (e.g., with bash, <code>export RUST_LOG=foo</code>).</p>
<h2 id="for-loops"><a href="#for-loops"><span class="header-section-number">14.5</span> For loops</a></h2>
<p>The most common way to express iteration in Rust is with a <code>for</code> loop. Like <code>do</code>, <code>for</code> is a nice syntax for describing control flow with closures. Additionally, within a <code>for</code> loop, <code>break</code>, <code>loop</code>, and <code>return</code> work just as they do with <code>while</code> and <code>loop</code>.</p>
<p>Consider again our <code>each</code> function, this time improved to break early when the iteratee returns <code>false</code>:</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">each</span>(<span class="cm-def">v</span>: &amp;[<span class="cm-keyword">int</span>], <span class="cm-def">op</span>: &amp;<span class="cm-keyword">fn</span>(<span class="cm-variable-3">v</span>: &amp;<span class="cm-keyword">int</span>) -&gt; <span class="cm-keyword">bool</span>) {
   <span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">n</span> = <span class="cm-number">0</span>;
   <span class="cm-keyword">while</span> <span class="cm-variable">n</span> &lt; <span class="cm-variable">v</span>.<span class="cm-variable">len</span>() {
       <span class="cm-keyword">if</span> !<span class="cm-variable">op</span>(&amp;<span class="cm-variable">v</span>[<span class="cm-variable">n</span>]) {
           <span class="cm-keyword">break</span>;
       }
       <span class="cm-variable">n</span> += <span class="cm-number">1</span>;
   }
}
</pre>

<p>And using this function to iterate over a vector:</p>
<pre class="cm-s-default"><span class="cm-variable">each</span>([<span class="cm-number">2</span>, <span class="cm-number">4</span>, <span class="cm-number">8</span>, <span class="cm-number">5</span>, <span class="cm-number">16</span>], |<span class="cm-variable">n</span>| {
    <span class="cm-keyword">if</span> *<span class="cm-variable">n</span> % <span class="cm-number">2</span> != <span class="cm-number">0</span> {
        <span class="cm-variable">println</span>(<span class="cm-string">&quot;found odd number!&quot;</span>);
        <span class="cm-atom">false</span>
    } <span class="cm-keyword">else</span> { <span class="cm-atom">true</span> }
});
</pre>

<p>With <code>for</code>, functions like <code>each</code> can be treated more like built-in looping structures. When calling <code>each</code> in a <code>for</code> loop, instead of returning <code>false</code> to break out of the loop, you just write <code>break</code>. To skip ahead to the next iteration, write <code>loop</code>.</p>
<pre class="cm-s-default"><span class="cm-keyword">for</span> <span class="cm-def">each</span>([<span class="cm-number">2</span>, <span class="cm-number">4</span>, <span class="cm-number">8</span>, <span class="cm-number">5</span>, <span class="cm-number">16</span>]) |<span class="cm-variable">n</span>| {
    <span class="cm-keyword">if</span> *<span class="cm-variable">n</span> % <span class="cm-number">2</span> != <span class="cm-number">0</span> {
        <span class="cm-variable">println</span>(<span class="cm-string">&quot;found odd number!&quot;</span>);
        <span class="cm-keyword">break</span>;
    }
}
</pre>

<p>As an added bonus, you can use the <code>return</code> keyword, which is not normally allowed in closures, in a block that appears as the body of a <code>for</code> loop: the meaning of <code>return</code> in such a block is to return from the enclosing function, not just the loop body.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">contains</span>(<span class="cm-def">v</span>: &amp;[<span class="cm-keyword">int</span>], <span class="cm-def">elt</span>: <span class="cm-keyword">int</span>) -&gt; <span class="cm-keyword">bool</span> {
    <span class="cm-keyword">for</span> <span class="cm-def">each</span>(<span class="cm-variable">v</span>) |<span class="cm-variable">x</span>| {
        <span class="cm-keyword">if</span> (*<span class="cm-variable">x</span> == <span class="cm-variable">elt</span>) { <span class="cm-keyword">return</span> <span class="cm-atom">true</span>; }
    }
    <span class="cm-atom">false</span>
}
</pre>

<p>Notice that, because <code>each</code> passes each value by borrowed pointer, the iteratee needs to dereference it before using it. In these situations it can be convenient to lean on Rust's argument patterns to bind <code>x</code> to the actual value, not the pointer.</p>
<pre class="cm-s-default">    <span class="cm-keyword">for</span> <span class="cm-def">each</span>(<span class="cm-variable">v</span>) |&amp;<span class="cm-variable">x</span>| {
        <span class="cm-keyword">if</span> (<span class="cm-variable">x</span> == <span class="cm-variable">elt</span>) { <span class="cm-keyword">return</span> <span class="cm-atom">true</span>; }
    }
</pre>

<p><code>for</code> syntax only works with stack closures.</p>
<blockquote>
<p><strong><em>Note:</em></strong> This is, essentially, a special loop protocol: the keywords <code>break</code>, <code>loop</code>, and <code>return</code> work, in varying degree, with <code>while</code>, <code>loop</code>, <code>do</code>, and <code>for</code> constructs.</p>
</blockquote>
<h1 id="methods"><a href="#methods"><span class="header-section-number">15</span> Methods</a></h1>
<p>Methods are like functions except that they always begin with a special argument, called <code>self</code>, which has the type of the method's receiver. The <code>self</code> argument is like <code>this</code> in C++ and many other languages. Methods are called with dot notation, as in <code>my_vec.len()</code>.</p>
<p><em>Implementations</em>, written with the <code>impl</code> keyword, can define methods on most Rust types, including structs and enums. As an example, let's define a <code>draw</code> method on our <code>Shape</code> enum.</p>
<pre class="cm-s-default"><span class="cm-keyword">struct</span> <span class="cm-variable">Point</span> {
    <span class="cm-variable">x</span>: <span class="cm-variable">float</span>,
    <span class="cm-variable">y</span>: <span class="cm-variable">float</span>
}

<span class="cm-keyword">enum</span> <span class="cm-def">Shape</span> {
    <span class="cm-def">Circle</span>(<span class="cm-variable-3">Point</span>, <span class="cm-keyword">float</span>),
    <span class="cm-def">Rectangle</span>(<span class="cm-variable-3">Point</span>, <span class="cm-variable-3">Point</span>)
}

<span class="cm-keyword">impl</span> <span class="cm-def">Shape</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">draw</span>(&amp;<span class="cm-keyword">self</span>) {
        <span class="cm-keyword">match</span> *<span class="cm-keyword">self</span> {
            <span class="cm-def">Circle</span>(<span class="cm-def">p</span>, <span class="cm-def">f</span>) =&gt; <span class="cm-def">draw_circle</span>(<span class="cm-def">p</span>, <span class="cm-def">f</span>),
            <span class="cm-def">Rectangle</span>(<span class="cm-def">p1</span>, <span class="cm-def">p2</span>) =&gt; <span class="cm-def">draw_rectangle</span>(<span class="cm-def">p1</span>, <span class="cm-def">p2</span>)
        }
    }
}

<span class="cm-keyword">let</span> <span class="cm-def">s</span> = <span class="cm-variable">Circle</span>(<span class="cm-variable">Point</span> { <span class="cm-variable">x</span>: <span class="cm-number">1</span><span class="cm-variable">f</span>, <span class="cm-variable">y</span>: <span class="cm-number">2</span><span class="cm-variable">f</span> }, <span class="cm-number">3</span><span class="cm-variable">f</span>);
<span class="cm-variable">s</span>.<span class="cm-variable">draw</span>();
</pre>

<p>This defines an <em>implementation</em> for <code>Shape</code> containing a single method, <code>draw</code>. In most respects the <code>draw</code> method is defined like any other function, except for the name <code>self</code>.</p>
<p>The type of <code>self</code> is the type on which the method is implemented, or a pointer thereof. As an argument it is written either <code>self</code>, <code>&amp;self</code>, <code>@self</code>, or <code>~self</code>. A caller must in turn have a compatible pointer type to call the method.</p>
<pre class="cm-s-default"><span class="cm-keyword">impl</span> <span class="cm-def">Shape</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">draw_borrowed</span>(&amp;<span class="cm-keyword">self</span>) { ... }
    <span class="cm-keyword">fn</span> <span class="cm-def">draw_managed</span>(@<span class="cm-keyword">self</span>) { ... }
    <span class="cm-keyword">fn</span> <span class="cm-def">draw_owned</span>(<span class="cm-def">~self</span>) { ... }
    <span class="cm-keyword">fn</span> <span class="cm-def">draw_value</span>(<span class="cm-keyword">self</span>) { ... }
}

<span class="cm-keyword">let</span> <span class="cm-def">s</span> = <span class="cm-variable">Circle</span>(<span class="cm-variable">Point</span> { <span class="cm-variable">x</span>: <span class="cm-number">1</span><span class="cm-variable">f</span>, <span class="cm-variable">y</span>: <span class="cm-number">2</span><span class="cm-variable">f</span> }, <span class="cm-number">3</span><span class="cm-variable">f</span>);

(@<span class="cm-variable">s</span>).<span class="cm-variable">draw_managed</span>();
(<span class="cm-variable">~s</span>).<span class="cm-variable">draw_owned</span>();
(&amp;<span class="cm-variable">s</span>).<span class="cm-variable">draw_borrowed</span>();
<span class="cm-variable">s</span>.<span class="cm-variable">draw_value</span>();
</pre>

<p>Methods typically take a borrowed pointer self type, so the compiler will go to great lengths to convert a callee to a borrowed pointer.</p>
<pre class="cm-s-default"><span class="cm-comment">// As with typical function arguments, managed and unique pointers</span>
<span class="cm-comment">// are automatically converted to borrowed pointers</span>

(@<span class="cm-variable">s</span>).<span class="cm-variable">draw_borrowed</span>();
(<span class="cm-variable">~s</span>).<span class="cm-variable">draw_borrowed</span>();

<span class="cm-comment">// Unlike typical function arguments, the self value will</span>
<span class="cm-comment">// automatically be referenced ...</span>
<span class="cm-variable">s</span>.<span class="cm-variable">draw_borrowed</span>();

<span class="cm-comment">// ... and dereferenced</span>
(&amp; &amp;<span class="cm-variable">s</span>).<span class="cm-variable">draw_borrowed</span>();

<span class="cm-comment">// ... and dereferenced and borrowed</span>
(&amp;@<span class="cm-variable">~s</span>).<span class="cm-variable">draw_borrowed</span>();
</pre>

<p>Implementations may also define standalone (sometimes called &quot;static&quot;) methods. The absence of a <code>self</code> paramater distinguishes such methods. These methods are the preferred way to define constructor functions.</p>
<pre class="cm-s-default"><span class="cm-keyword">impl</span> <span class="cm-def">Circle</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">area</span>(&amp;<span class="cm-keyword">self</span>) -&gt; <span class="cm-keyword">float</span> { ... }
    <span class="cm-keyword">fn</span> <span class="cm-def">new</span>(<span class="cm-def">area</span>: <span class="cm-keyword">float</span>) -&gt; <span class="cm-variable-3">Circle</span> { ... }
}
</pre>

<p>To call such a method, just prefix it with the type name and a double colon:</p>
<pre class="cm-s-default"><span class="cm-keyword">struct</span> <span class="cm-variable">Circle</span> { <span class="cm-variable">radius</span>: <span class="cm-variable">float</span> }
<span class="cm-keyword">impl</span> <span class="cm-def">Circle</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">new</span>(<span class="cm-def">area</span>: <span class="cm-keyword">float</span>) -&gt; <span class="cm-variable-3">Circle</span> { <span class="cm-variable">Circle</span> { <span class="cm-variable">radius</span>: <span class="cm-variable">sqrt</span>(<span class="cm-variable">area</span> <span class="cm-variable">/</span> <span class="cm-variable">pi</span>) } }
}
<span class="cm-keyword">let</span> <span class="cm-def">c</span> = <span class="cm-variable-2">Circle::</span><span class="cm-variable">new</span>(<span class="cm-number">42.5</span>);
</pre>

<h1 id="generics"><a href="#generics"><span class="header-section-number">16</span> Generics</a></h1>
<p>Throughout this tutorial, we've been defining functions that act only on specific data types. With type parameters we can also define functions whose arguments have generic types, and which can be invoked with a variety of types. Consider a generic <code>map</code> function, which takes a function <code>function</code> and a vector <code>vector</code> and returns a new vector consisting of the result of applying <code>function</code> to each element of <code>vector</code>:</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">map</span>&lt;<span class="cm-variable-3">T</span>, <span class="cm-variable-3">U</span>&gt;(<span class="cm-def">vector</span>: &amp;[<span class="cm-variable-3">T</span>], <span class="cm-def">function</span>: &amp;<span class="cm-keyword">fn</span>(<span class="cm-variable-3">v</span>: &amp;<span class="cm-variable">T</span>) -&gt; <span class="cm-variable-3">U</span>) -&gt; <span class="cm-variable-3">~</span>[<span class="cm-def">U</span>] {
    <span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">accumulator</span> = <span class="cm-variable">~</span>[];
    <span class="cm-keyword">for</span> <span class="cm-variable-2">vec::</span><span class="cm-def">each</span>(<span class="cm-variable">vector</span>) |<span class="cm-variable">element</span>| {
        <span class="cm-variable">accumulator</span>.<span class="cm-variable">push</span>(<span class="cm-variable">function</span>(<span class="cm-variable">element</span>));
    }
    <span class="cm-keyword">return</span> <span class="cm-variable">accumulator</span>;
}
</pre>

<p>When defined with type parameters, as denoted by <code>&lt;T, U&gt;</code>, this function can be applied to any type of vector, as long as the type of <code>function</code>'s argument and the type of the vector's contents agree with each other.</p>
<p>Inside a generic function, the names of the type parameters (capitalized by convention) stand for opaque types. All you can do with instances of these types is pass them around: you can't apply any operations to them or pattern-match on them. Note that instances of generic types are often passed by pointer. For example, the parameter <code>function()</code> is supplied with a pointer to a value of type <code>T</code> and not a value of type <code>T</code> itself. This ensures that the function works with the broadest set of types possible, since some types are expensive or illegal to copy and pass by value.</p>
<p>Generic <code>type</code>, <code>struct</code>, and <code>enum</code> declarations follow the same pattern:</p>
<pre class="cm-s-default"><span class="cm-keyword">type</span> <span class="cm-def">Set</span>&lt;<span class="cm-variable-3">T</span>&gt; = <span class="cm-variable-3">HashMap</span>&lt;<span class="cm-variable-3">T</span>, ()&gt;;

<span class="cm-keyword">struct</span> <span class="cm-variable">Stack</span>&lt;<span class="cm-variable">T</span>&gt; {
    <span class="cm-variable">elements</span>: <span class="cm-variable">~</span>[<span class="cm-variable">T</span>]
}

<span class="cm-keyword">enum</span> <span class="cm-def">Option</span>&lt;<span class="cm-variable-3">T</span>&gt; {
    <span class="cm-def">Some</span>(<span class="cm-variable-3">T</span>),
    <span class="cm-def">None</span>
}
</pre>

<p>These declarations can be instantiated to valid types like <code>Set&lt;int&gt;</code>, <code>Stack&lt;int&gt;</code>, and <code>Option&lt;int&gt;</code>.</p>
<p>The last type in that example, <code>Option</code>, appears frequently in Rust code. Because Rust does not have null pointers (except in unsafe code), we need another way to write a function whose result isn't defined on every possible combination of arguments of the appropriate types. The usual way is to write a function that returns <code>Option&lt;T&gt;</code> instead of <code>T</code>.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">radius</span>(<span class="cm-def">shape</span>: <span class="cm-variable-3">Shape</span>) -&gt; <span class="cm-variable-3">Option</span>&lt;<span class="cm-keyword">float</span>&gt; {
    <span class="cm-keyword">match</span> <span class="cm-variable">shape</span> {
        <span class="cm-def">Circle</span>(<span class="cm-def">_</span>, <span class="cm-def">radius</span>) =&gt; <span class="cm-def">Some</span>(<span class="cm-def">radius</span>),
        <span class="cm-def">Rectangle</span>(*)      =&gt; <span class="cm-def">None</span>
    }
}
</pre>

<p>The Rust compiler compiles generic functions very efficiently by <em>monomorphizing</em> them. <em>Monomorphization</em> is a fancy name for a simple idea: generate a separate copy of each generic function at each call site, a copy that is specialized to the argument types and can thus be optimized specifically for them. In this respect, Rust's generics have similar performance characteristics to C++ templates.</p>
<h2 id="traits"><a href="#traits"><span class="header-section-number">16.1</span> Traits</a></h2>
<p>Within a generic function the operations available on generic types are very limited. After all, since the function doesn't know what types it is operating on, it can't safely modify or query their values. This is where <em>traits</em> come into play. Traits are Rust's most powerful tool for writing polymorphic code. Java developers will see them as similar to Java interfaces, and Haskellers will notice their similarities to type classes. Rust's traits are a form of <em>bounded polymorphism</em>: a trait is a way of limiting the set of possible types that a type parameter could refer to.</p>
<p>As motivation, let us consider copying in Rust. The <code>copy</code> operation is not defined for all Rust types. One reason is user-defined destructors: copying a type that has a destructor could result in the destructor running multiple times. Therefore, types with user-defined destructors cannot be copied, either implicitly or explicitly, and neither can types that own other types containing destructors.</p>
<p>This complicates handling of generic functions. If you have a type parameter <code>T</code>, can you copy values of that type? In Rust, you can't, and if you try to run the following code the compiler will complain.</p>
<pre class="cm-s-default"><span class="cm-comment">// This does not compile</span>
<span class="cm-keyword">fn</span> <span class="cm-def">head_bad</span>&lt;<span class="cm-variable-3">T</span>&gt;(<span class="cm-def">v</span>: &amp;[<span class="cm-variable-3">T</span>]) -&gt; <span class="cm-variable-3">T</span> {
    <span class="cm-variable">v</span>[<span class="cm-number">0</span>] <span class="cm-comment">// error: copying a non-copyable value</span>
}
</pre>

<p>However, we can tell the compiler that the <code>head</code> function is only for copyable types: that is, those that have the <code>Copy</code> trait.</p>
<pre class="cm-s-default"><span class="cm-comment">// This does</span>
<span class="cm-keyword">fn</span> <span class="cm-def">head</span>&lt;<span class="cm-variable-3">T</span>: <span class="cm-variable-3">Copy</span>&gt;(<span class="cm-def">v</span>: &amp;[<span class="cm-variable-3">T</span>]) -&gt; <span class="cm-variable-3">T</span> {
    <span class="cm-variable">v</span>[<span class="cm-number">0</span>]
}
</pre>

<p>This says that we can call <code>head</code> on any type <code>T</code> as long as that type implements the <code>Copy</code> trait. When instantiating a generic function, you can only instantiate it with types that implement the correct trait, so you could not apply <code>head</code> to a type with a destructor. (<code>Copy</code> is a special trait that is built in to the compiler, making it possible for the compiler to enforce this restriction.)</p>
<p>While most traits can be defined and implemented by user code, three traits are automatically derived and implemented for all applicable types by the compiler, and may not be overridden:</p>
<ul>
<li><p><code>Copy</code> - Types that can be copied, either implicitly, or explicitly with the <code>copy</code> operator. All types are copyable unless they have destructors or contain types with destructors.</p></li>
<li><p><code>Owned</code> - Owned types. Types are owned unless they contain managed boxes, managed closures, or borrowed pointers. Owned types may or may not be copyable.</p></li>
<li><p><code>Const</code> - Constant (immutable) types. These are types that do not contain mutable fields.</p></li>
</ul>
<blockquote>
<p><strong><em>Note:</em></strong> These three traits were referred to as 'kinds' in earlier iterations of the language, and often still are.</p>
</blockquote>
<p>Additionally, the <code>Drop</code> trait is used to define destructors. This trait defines one method called <code>finalize</code>, which is automatically called when a value of the type that implements this trait is destroyed, either because the value went out of scope or because the garbage collector reclaimed it.</p>
<pre class="cm-s-default"><span class="cm-keyword">struct</span> <span class="cm-variable">TimeBomb</span> {
    <span class="cm-variable">explosivity</span>: <span class="cm-variable">uint</span>
}

<span class="cm-keyword">impl</span> <span class="cm-def">Drop</span> <span class="cm-keyword">for</span> <span class="cm-variable-3">TimeBomb</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">finalize</span>(&amp;<span class="cm-keyword">self</span>) {
        <span class="cm-keyword">for</span> <span class="cm-variable-2">old_iter::</span><span class="cm-def">repeat</span>(<span class="cm-keyword">self</span>.<span class="cm-variable">explosivity</span>) {
            <span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-string">&quot;blam!&quot;</span>);
        }
    }
}
</pre>

<p>It is illegal to call <code>finalize</code> directly. Only code inserted by the compiler may call it.</p>
<h2 id="declaring-and-implementing-traits"><a href="#declaring-and-implementing-traits"><span class="header-section-number">16.2</span> Declaring and implementing traits</a></h2>
<p>A trait consists of a set of methods, without bodies, or may be empty, as is the case with <code>Copy</code>, <code>Owned</code>, and <code>Const</code>. For example, we could declare the trait <code>Printable</code> for things that can be printed to the console, with a single method:</p>
<pre class="cm-s-default"><span class="cm-keyword">trait</span> <span class="cm-def">Printable</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">print</span>(&amp;<span class="cm-keyword">self</span>);
}
</pre>

<p>Traits may be implemented for specific types with <a href="#functions-and-methods">impls</a>. An impl that implements a trait includes the name of the trait at the start of the definition, as in the following impls of <code>Printable</code> for <code>int</code> and <code>~str</code>.</p>
<pre class="cm-s-default"><span class="cm-keyword">impl</span> <span class="cm-def">Printable</span> <span class="cm-keyword">for</span> <span class="cm-variable-3">int</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">print</span>(&amp;<span class="cm-keyword">self</span>) { <span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-variable">fmt</span>!(<span class="cm-string">&quot;%d&quot;</span>, *<span class="cm-keyword">self</span>)) }
}

<span class="cm-keyword">impl</span> <span class="cm-def">Printable</span> <span class="cm-keyword">for</span> <span class="cm-variable-3">~str</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">print</span>(&amp;<span class="cm-keyword">self</span>) { <span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(*<span class="cm-keyword">self</span>) }
}

</pre>

<p>Methods defined in an implementation of a trait may be called just like any other method, using dot notation, as in <code>1.print()</code>. Traits may themselves contain type parameters. A trait for generalized sequence types might look like the following:</p>
<pre class="cm-s-default"><span class="cm-keyword">trait</span> <span class="cm-def">Seq</span>&lt;<span class="cm-variable-3">T</span>&gt; {
    <span class="cm-keyword">fn</span> <span class="cm-def">len</span>(&amp;<span class="cm-keyword">self</span>) -&gt; <span class="cm-keyword">uint</span>;
    <span class="cm-keyword">fn</span> <span class="cm-def">iter</span>(&amp;<span class="cm-keyword">self</span>, <span class="cm-def">b</span>: &amp;<span class="cm-keyword">fn</span>(<span class="cm-variable-3">v</span>: &amp;<span class="cm-variable">T</span>));
}

<span class="cm-keyword">impl</span>&lt;<span class="cm-variable-3">T</span>&gt; <span class="cm-def">Seq</span>&lt;<span class="cm-variable-3">T</span>&gt; <span class="cm-keyword">for</span> <span class="cm-variable-3">~</span>[<span class="cm-variable">T</span>] {
    <span class="cm-keyword">fn</span> <span class="cm-def">len</span>(&amp;<span class="cm-keyword">self</span>) -&gt; <span class="cm-keyword">uint</span> { <span class="cm-variable-2">vec::</span><span class="cm-variable">len</span>(*<span class="cm-keyword">self</span>) }
    <span class="cm-keyword">fn</span> <span class="cm-def">iter</span>(&amp;<span class="cm-keyword">self</span>, <span class="cm-def">b</span>: &amp;<span class="cm-keyword">fn</span>(<span class="cm-variable-3">v</span>: &amp;<span class="cm-variable">T</span>)) {
        <span class="cm-keyword">for</span> <span class="cm-variable-2">vec::</span><span class="cm-def">each</span>(*<span class="cm-keyword">self</span>) |<span class="cm-variable">elt</span>| { <span class="cm-variable">b</span>(<span class="cm-variable">elt</span>); }
    }
}
</pre>

<p>The implementation has to explicitly declare the type parameter that it binds, <code>T</code>, before using it to specify its trait type. Rust requires this declaration because the <code>impl</code> could also, for example, specify an implementation of <code>Seq&lt;int&gt;</code>. The trait type (appearing between <code>impl</code> and <code>for</code>) <em>refers</em> to a type, rather than defining one.</p>
<p>The type parameters bound by a trait are in scope in each of the method declarations. So, re-declaring the type parameter <code>T</code> as an explicit type parameter for <code>len</code>, in either the trait or the impl, would be a compile-time error.</p>
<p>Within a trait definition, <code>Self</code> is a special type that you can think of as a type parameter. An implementation of the trait for any given type <code>T</code> replaces the <code>Self</code> type parameter with <code>T</code>. The following trait describes types that support an equality operation:</p>
<pre class="cm-s-default"><span class="cm-comment">// In a trait, `self` refers to the self argument.</span>
<span class="cm-comment">// `Self` refers to the type implementing the trait.</span>
<span class="cm-keyword">trait</span> <span class="cm-def">Eq</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">equals</span>(&amp;<span class="cm-keyword">self</span>, <span class="cm-def">other</span>: &amp;<span class="cm-variable-3">Self</span>) -&gt; <span class="cm-keyword">bool</span>;
}

<span class="cm-comment">// In an impl, `self` refers just to the value of the receiver</span>
<span class="cm-keyword">impl</span> <span class="cm-def">Eq</span> <span class="cm-keyword">for</span> <span class="cm-variable-3">int</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">equals</span>(&amp;<span class="cm-keyword">self</span>, <span class="cm-def">other</span>: &amp;<span class="cm-keyword">int</span>) -&gt; <span class="cm-keyword">bool</span> { *<span class="cm-variable">other</span> == *<span class="cm-keyword">self</span> }
}
</pre>

<p>Notice that in the trait definition, <code>equals</code> takes a second parameter of type <code>Self</code>. In contrast, in the <code>impl</code>, <code>equals</code> takes a second parameter of type <code>int</code>, only using <code>self</code> as the name of the receiver.</p>
<p>Just as in type implementations, traits can define standalone (static) methods. These methods are called by prefixing the method name with the trait name and a double colon. The compiler uses type inference to decide which implementation to use.</p>
<pre class="cm-s-default"><span class="cm-keyword">trait</span> <span class="cm-def">Shape</span> { <span class="cm-keyword">fn</span> <span class="cm-def">new</span>(<span class="cm-def">area</span>: <span class="cm-keyword">float</span>) -&gt; <span class="cm-variable-3">Self</span>; }
<span class="cm-keyword">struct</span> <span class="cm-variable">Circle</span> { <span class="cm-variable">radius</span>: <span class="cm-variable">float</span> }
<span class="cm-keyword">struct</span> <span class="cm-variable">Square</span> { <span class="cm-variable">length</span>: <span class="cm-variable">float</span> }

<span class="cm-keyword">impl</span> <span class="cm-def">Shape</span> <span class="cm-keyword">for</span> <span class="cm-variable-3">Circle</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">new</span>(<span class="cm-def">area</span>: <span class="cm-keyword">float</span>) -&gt; <span class="cm-variable-3">Circle</span> { <span class="cm-variable">Circle</span> { <span class="cm-variable">radius</span>: <span class="cm-variable">sqrt</span>(<span class="cm-variable">area</span> <span class="cm-variable">/</span> <span class="cm-variable">pi</span>) } }
}
<span class="cm-keyword">impl</span> <span class="cm-def">Shape</span> <span class="cm-keyword">for</span> <span class="cm-variable-3">Square</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">new</span>(<span class="cm-def">area</span>: <span class="cm-keyword">float</span>) -&gt; <span class="cm-variable-3">Square</span> { <span class="cm-variable">Square</span> { <span class="cm-variable">length</span>: <span class="cm-variable">sqrt</span>(<span class="cm-variable">area</span>) } }
}

<span class="cm-keyword">let</span> <span class="cm-def">area</span> = <span class="cm-number">42.5</span>;
<span class="cm-keyword">let</span> <span class="cm-def">c</span>: <span class="cm-variable-3">Circle</span> = <span class="cm-variable-2">Shape::</span><span class="cm-variable">new</span>(<span class="cm-variable">area</span>);
<span class="cm-keyword">let</span> <span class="cm-def">s</span>: <span class="cm-variable-3">Square</span> = <span class="cm-variable-2">Shape::</span><span class="cm-variable">new</span>(<span class="cm-variable">area</span>);
</pre>

<h2 id="bounded-type-parameters-and-static-method-dispatch"><a href="#bounded-type-parameters-and-static-method-dispatch"><span class="header-section-number">16.3</span> Bounded type parameters and static method dispatch</a></h2>
<p>Traits give us a language for defining predicates on types, or abstract properties that types can have. We can use this language to define <em>bounds</em> on type parameters, so that we can then operate on generic types.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">print_all</span>&lt;<span class="cm-variable-3">T</span>: <span class="cm-variable-3">Printable</span>&gt;(<span class="cm-def">printable_things</span>: <span class="cm-variable-3">~</span>[<span class="cm-variable">T</span>]) {
    <span class="cm-keyword">for</span> <span class="cm-def">printable_things</span>.<span class="cm-variable">each</span> |<span class="cm-variable">thing</span>| {
        <span class="cm-variable">thing</span>.<span class="cm-variable">print</span>();
    }
}
</pre>

<p>Declaring <code>T</code> as conforming to the <code>Printable</code> trait (as we earlier did with <code>Copy</code>) makes it possible to call methods from that trait on values of type <code>T</code> inside the function. It will also cause a compile-time error when anyone tries to call <code>print_all</code> on an array whose element type does not have a <code>Printable</code> implementation.</p>
<p>Type parameters can have multiple bounds by separating them with <code>+</code>, as in this version of <code>print_all</code> that copies elements.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">print_all</span>&lt;<span class="cm-variable-3">T</span>: <span class="cm-variable-3">Printable</span> + <span class="cm-variable-3">Copy</span>&gt;(<span class="cm-def">printable_things</span>: <span class="cm-variable-3">~</span>[<span class="cm-variable">T</span>]) {
    <span class="cm-keyword">let</span> <span class="cm-def">mut</span> <span class="cm-def">i</span> = <span class="cm-number">0</span>;
    <span class="cm-keyword">while</span> <span class="cm-variable">i</span> &lt; <span class="cm-variable">printable_things</span>.<span class="cm-variable">len</span>() {
        <span class="cm-keyword">let</span> <span class="cm-def">copy_of_thing</span> = <span class="cm-variable">printable_things</span>[<span class="cm-variable">i</span>];
        <span class="cm-variable">copy_of_thing</span>.<span class="cm-variable">print</span>();
        <span class="cm-variable">i</span> += <span class="cm-number">1</span>;
    }
}
</pre>

<p>Method calls to bounded type parameters are <em>statically dispatched</em>, imposing no more overhead than normal function invocation, so are the preferred way to use traits polymorphically.</p>
<p>This usage of traits is similar to Haskell type classes.</p>
<h2 id="trait-objects-and-dynamic-method-dispatch"><a href="#trait-objects-and-dynamic-method-dispatch"><span class="header-section-number">16.4</span> Trait objects and dynamic method dispatch</a></h2>
<p>The above allows us to define functions that polymorphically act on values of a single unknown type that conforms to a given trait. However, consider this function:</p>
<pre class="cm-s-default"><span class="cm-keyword">trait</span> <span class="cm-def">Drawable</span> { <span class="cm-keyword">fn</span> <span class="cm-def">draw</span>(&amp;<span class="cm-keyword">self</span>); }

<span class="cm-keyword">fn</span> <span class="cm-def">draw_all</span>&lt;<span class="cm-variable-3">T</span>: <span class="cm-variable-3">Drawable</span>&gt;(<span class="cm-def">shapes</span>: <span class="cm-variable-3">~</span>[<span class="cm-variable">T</span>]) {
    <span class="cm-keyword">for</span> <span class="cm-def">shapes</span>.<span class="cm-variable">each</span> |<span class="cm-variable">shape</span>| { <span class="cm-variable">shape</span>.<span class="cm-variable">draw</span>(); }
}
</pre>

<p>You can call that on an array of circles, or an array of rectangles (assuming those have suitable <code>Drawable</code> traits defined), but not on an array containing both circles and rectangles. When such behavior is needed, a trait name can alternately be used as a type, called an <em>object</em>.</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">draw_all</span>(<span class="cm-def">shapes</span>: &amp;[@<span class="cm-variable-3">Drawable</span>]) {
    <span class="cm-keyword">for</span> <span class="cm-def">shapes</span>.<span class="cm-variable">each</span> |<span class="cm-variable">shape</span>| { <span class="cm-variable">shape</span>.<span class="cm-variable">draw</span>(); }
}
</pre>

<p>In this example, there is no type parameter. Instead, the <code>@Drawable</code> type denotes any managed box value that implements the <code>Drawable</code> trait. To construct such a value, you use the <code>as</code> operator to cast a value to an object:</p>
<pre class="cm-s-default">
<span class="cm-keyword">impl</span> <span class="cm-def">Drawable</span> <span class="cm-keyword">for</span> <span class="cm-variable-3">Circle</span> { <span class="cm-keyword">fn</span> <span class="cm-def">draw</span>(&amp;<span class="cm-keyword">self</span>) { ... } }
<span class="cm-keyword">impl</span> <span class="cm-def">Drawable</span> <span class="cm-keyword">for</span> <span class="cm-variable-3">Rectangle</span> { <span class="cm-keyword">fn</span> <span class="cm-def">draw</span>(&amp;<span class="cm-keyword">self</span>) { ... } }

<span class="cm-keyword">let</span> <span class="cm-def">c</span>: @<span class="cm-variable-3">Circle</span> = @<span class="cm-variable">new_circle</span>();
<span class="cm-keyword">let</span> <span class="cm-def">r</span>: @<span class="cm-variable-3">Rectangle</span> = @<span class="cm-variable">new_rectangle</span>();
<span class="cm-variable">draw_all</span>([<span class="cm-variable">c</span> <span class="cm-keyword">as</span> @<span class="cm-variable">Drawable</span>, <span class="cm-variable">r</span> <span class="cm-keyword">as</span> @<span class="cm-variable">Drawable</span>]);
</pre>

<p>We omit the code for <code>new_circle</code> and <code>new_rectangle</code>; imagine that these just return <code>Circle</code>s and <code>Rectangle</code>s with a default size. Note that, like strings and vectors, objects have dynamic size and may only be referred to via one of the pointer types. Other pointer types work as well. Casts to traits may only be done with compatible pointers so, for example, an <code>@Circle</code> may not be cast to an <code>~Drawable</code>.</p>
<pre class="cm-s-default"><span class="cm-comment">// A managed object</span>
<span class="cm-keyword">let</span> <span class="cm-def">boxy</span>: @<span class="cm-variable-3">Drawable</span> = @<span class="cm-variable">new_circle</span>() <span class="cm-keyword">as</span> @<span class="cm-variable">Drawable</span>;
<span class="cm-comment">// An owned object</span>
<span class="cm-keyword">let</span> <span class="cm-def">owny</span>: <span class="cm-variable-3">~Drawable</span> = <span class="cm-variable">~new_circle</span>() <span class="cm-keyword">as</span> <span class="cm-variable">~Drawable</span>;
<span class="cm-comment">// A borrowed object</span>
<span class="cm-keyword">let</span> <span class="cm-def">stacky</span>: &amp;<span class="cm-variable-3">Drawable</span> = &amp;<span class="cm-variable">new_circle</span>() <span class="cm-keyword">as</span> &amp;<span class="cm-variable">Drawable</span>;
</pre>

<p>Method calls to trait types are <em>dynamically dispatched</em>. Since the compiler doesn't know specifically which functions to call at compile time, it uses a lookup table (also known as a vtable or dictionary) to select the method to call at runtime.</p>
<p>This usage of traits is similar to Java interfaces.</p>
<h2 id="trait-inheritance"><a href="#trait-inheritance"><span class="header-section-number">16.5</span> Trait inheritance</a></h2>
<p>We can write a trait declaration that <em>inherits</em> from other traits, called <em>supertraits</em>. Types that implement a trait must also implement its supertraits. For example, we can define a <code>Circle</code> trait that inherits from <code>Shape</code>.</p>
<pre class="cm-s-default"><span class="cm-keyword">trait</span> <span class="cm-def">Shape</span> { <span class="cm-keyword">fn</span> <span class="cm-def">area</span>(&amp;<span class="cm-keyword">self</span>) -&gt; <span class="cm-keyword">float</span>; }
<span class="cm-keyword">trait</span> <span class="cm-def">Circle</span> : <span class="cm-variable">Shape</span> { <span class="cm-keyword">fn</span> <span class="cm-def">radius</span>(&amp;<span class="cm-keyword">self</span>) -&gt; <span class="cm-keyword">float</span>; }
</pre>

<p>Now, we can implement <code>Circle</code> on a type only if we also implement <code>Shape</code>.</p>
<pre class="cm-s-default"><span class="cm-keyword">struct</span> <span class="cm-variable">CircleStruct</span> { <span class="cm-variable">center</span>: <span class="cm-variable">Point</span>, <span class="cm-variable">radius</span>: <span class="cm-variable">float</span> }
<span class="cm-keyword">impl</span> <span class="cm-def">Circle</span> <span class="cm-keyword">for</span> <span class="cm-variable-3">CircleStruct</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">radius</span>(&amp;<span class="cm-keyword">self</span>) -&gt; <span class="cm-keyword">float</span> { <span class="cm-variable">sqrt</span>(<span class="cm-keyword">self</span>.<span class="cm-variable">area</span>() <span class="cm-variable">/</span> <span class="cm-variable">pi</span>) }
}
<span class="cm-keyword">impl</span> <span class="cm-def">Shape</span> <span class="cm-keyword">for</span> <span class="cm-variable-3">CircleStruct</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">area</span>(&amp;<span class="cm-keyword">self</span>) -&gt; <span class="cm-keyword">float</span> { <span class="cm-variable">pi</span> * <span class="cm-variable">square</span>(<span class="cm-keyword">self</span>.<span class="cm-variable">radius</span>) }
}
</pre>

<p>Notice that methods of <code>Circle</code> can call methods on <code>Shape</code>, as our <code>radius</code> implementation calls the <code>area</code> method. This is a silly way to compute the radius of a circle (since we could just return the <code>radius</code> field), but you get the idea.</p>
<p>In type-parameterized functions, methods of the supertrait may be called on values of subtrait-bound type parameters. Refering to the previous example of <code>trait Circle : Shape</code>:</p>
<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">radius_times_area</span>&lt;<span class="cm-variable-3">T</span>: <span class="cm-variable-3">Circle</span>&gt;(<span class="cm-def">c</span>: <span class="cm-variable-3">T</span>) -&gt; <span class="cm-keyword">float</span> {
    <span class="cm-comment">// `c` is both a Circle and a Shape</span>
    <span class="cm-variable">c</span>.<span class="cm-variable">radius</span>() * <span class="cm-variable">c</span>.<span class="cm-variable">area</span>()
}
</pre>

<p>Likewise, supertrait methods may also be called on trait objects.</p>
<pre class="cm-s-default">
<span class="cm-keyword">let</span> <span class="cm-def">concrete</span> = @<span class="cm-variable">CircleStruct</span>{<span class="cm-variable">center</span>:<span class="cm-variable">Point</span>{<span class="cm-variable">x</span>:<span class="cm-number">3</span><span class="cm-variable">f</span>,<span class="cm-variable">y</span>:<span class="cm-number">4</span><span class="cm-variable">f</span>},<span class="cm-def">radius</span>:<span class="cm-number">5</span><span class="cm-def">f</span>};
<span class="cm-keyword">let</span> <span class="cm-def">mycircle</span>: <span class="cm-variable-3">Circle</span> = <span class="cm-variable">concrete</span> <span class="cm-keyword">as</span> @<span class="cm-variable">Circle</span>;
<span class="cm-keyword">let</span> <span class="cm-def">nonsense</span> = <span class="cm-variable">mycircle</span>.<span class="cm-variable">radius</span>() * <span class="cm-variable">mycircle</span>.<span class="cm-variable">area</span>();
</pre>

<blockquote>
<p><strong><em>Note:</em></strong> Trait inheritance does not actually work with objects yet</p>
</blockquote>
<h1 id="modules-and-crates"><a href="#modules-and-crates"><span class="header-section-number">17</span> Modules and crates</a></h1>
<p>The Rust namespace is arranged in a hierarchy of modules. Each source (.rs) file represents a single module and may in turn contain additional modules.</p>
<pre class="cm-s-default"><span class="cm-keyword">mod</span> <span class="cm-def">farm</span> {
    <span class="cm-keyword">pub</span> <span class="cm-keyword">fn</span> <span class="cm-def">chicken</span>() -&gt; &amp;<span class="cm-keyword">str</span> { <span class="cm-string">&quot;cluck cluck&quot;</span> }
    <span class="cm-keyword">pub</span> <span class="cm-keyword">fn</span> <span class="cm-def">cow</span>() -&gt; &amp;<span class="cm-keyword">str</span> { <span class="cm-string">&quot;mooo&quot;</span> }
}

<span class="cm-keyword">fn</span> <span class="cm-def">main</span>() {
    <span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-variable-2">farm::</span><span class="cm-variable">chicken</span>());
}
</pre>

<p>The contents of modules can be imported into the current scope with the <code>use</code> keyword, optionally giving it an alias. <code>use</code> may appear at the beginning of crates, <code>mod</code>s, <code>fn</code>s, and other blocks.</p>
<pre class="cm-s-default"><span class="cm-comment">// Bring `chicken` into scope</span>
<span class="cm-keyword">use</span> <span class="cm-variable-2">farm::</span><span class="cm-variable">chicken</span>;

<span class="cm-keyword">fn</span> <span class="cm-def">chicken_farmer</span>() {
    <span class="cm-comment">// The same, but name it `my_chicken`</span>
    <span class="cm-keyword">use</span> <span class="cm-variable">my_chicken</span> = <span class="cm-variable-2">farm::</span><span class="cm-variable">chicken</span>;
    ...
}
</pre>

<p>These farm animal functions have a new keyword, <code>pub</code>, attached to them. The <code>pub</code> keyword modifies an item's visibility, making it visible outside its containing module. An expression with <code>::</code>, like <code>farm::chicken</code>, can name an item outside of its containing module. Items, such as those declared with <code>fn</code>, <code>struct</code>, <code>enum</code>, <code>type</code>, or <code>static</code>, are module-private by default.</p>
<p>Visibility restrictions in Rust exist only at module boundaries. This is quite different from most object-oriented languages that also enforce restrictions on objects themselves. That's not to say that Rust doesn't support encapsulation: both struct fields and methods can be private. But this encapsulation is at the module level, not the struct level. Note that fields and methods are <em>public</em> by default.</p>
<pre class="cm-s-default"><span class="cm-keyword">pub</span> <span class="cm-keyword">mod</span> <span class="cm-def">farm</span> {
    <span class="cm-keyword">pub</span> <span class="cm-keyword">struct</span> <span class="cm-variable">Farm</span> {
        <span class="cm-keyword">priv</span> <span class="cm-variable">chickens</span>: <span class="cm-variable">~</span>[<span class="cm-variable">Chicken</span>],
        <span class="cm-keyword">priv</span> <span class="cm-variable">cows</span>: <span class="cm-variable">~</span>[<span class="cm-variable">Cow</span>],
        <span class="cm-variable">farmer</span>: <span class="cm-variable">Human</span>
    }

    <span class="cm-keyword">impl</span> <span class="cm-def">Farm</span> {
        <span class="cm-keyword">priv</span> <span class="cm-keyword">fn</span> <span class="cm-def">feed_chickens</span>(&amp;<span class="cm-keyword">self</span>) { ... }
        <span class="cm-keyword">priv</span> <span class="cm-keyword">fn</span> <span class="cm-def">feed_cows</span>(&amp;<span class="cm-keyword">self</span>) { ... }
        <span class="cm-keyword">pub</span> <span class="cm-keyword">fn</span> <span class="cm-def">add_chicken</span>(&amp;<span class="cm-keyword">self</span>, <span class="cm-def">c</span>: <span class="cm-variable-3">Chicken</span>) { ... }
    }

    <span class="cm-keyword">pub</span> <span class="cm-keyword">fn</span> <span class="cm-def">feed_animals</span>(<span class="cm-def">farm</span>: &amp;<span class="cm-variable-3">Farm</span>) {
        <span class="cm-variable">farm</span>.<span class="cm-variable">feed_chickens</span>();
        <span class="cm-variable">farm</span>.<span class="cm-variable">feed_cows</span>();
    }
}

<span class="cm-keyword">fn</span> <span class="cm-def">main</span>() {
     <span class="cm-keyword">let</span> <span class="cm-def">f</span> = <span class="cm-variable">make_me_a_farm</span>();
     <span class="cm-variable">f</span>.<span class="cm-variable">add_chicken</span>(<span class="cm-variable">make_me_a_chicken</span>());
     <span class="cm-variable-2">farm::</span><span class="cm-variable">feed_animals</span>(&amp;<span class="cm-variable">f</span>);
     <span class="cm-variable">f</span>.<span class="cm-variable">farmer</span>.<span class="cm-variable">rest</span>();
}
</pre>

<h2 id="crates"><a href="#crates"><span class="header-section-number">17.1</span> Crates</a></h2>
<p>The unit of independent compilation in Rust is the crate: rustc compiles a single crate at a time, from which it produces either a library or an executable.</p>
<p>When compiling a single <code>.rs</code> source file, the file acts as the whole crate. You can compile it with the <code>--lib</code> compiler switch to create a shared library, or without, provided that your file contains a <code>fn main</code> somewhere, to create an executable.</p>
<p>Larger crates typically span multiple files and are, by convention, compiled from a source file with the <code>.rc</code> extension, called a <em>crate file</em>. The crate file extension distinguishes source files that represent crates from those that do not, but otherwise source files and crate files are identical.</p>
<p>A typical crate file declares attributes associated with the crate that may affect how the compiler processes the source. Crate attributes specify metadata used for locating and linking crates, the type of crate (library or executable), and control warning and error behavior, among other things. Crate files additionally declare the external crates they depend on as well as any modules loaded from other files.</p>
<pre class="cm-s-default"><span class="cm-comment">// Crate linkage metadata</span>
#[<span class="cm-variable">link</span>(<span class="cm-variable">name</span> = <span class="cm-string">&quot;farm&quot;</span>, <span class="cm-variable">vers</span> = <span class="cm-string">&quot;2.5&quot;</span>, <span class="cm-variable">author</span> = <span class="cm-string">&quot;mjh&quot;</span>)];

<span class="cm-comment">// Make a library (&quot;bin&quot; is the default)</span>
#[<span class="cm-variable">crate_type</span> = <span class="cm-string">&quot;lib&quot;</span>];

<span class="cm-comment">// Turn on a warning</span>
#[<span class="cm-variable">warn</span>(<span class="cm-variable">non_camel_case_types</span>)]

<span class="cm-comment">// Link to the standard library</span>
<span class="cm-keyword">extern</span> <span class="cm-keyword">mod</span> <span class="cm-def">std</span>;

<span class="cm-comment">// Load some modules from other files</span>
<span class="cm-keyword">mod</span> <span class="cm-def">cow</span>;
<span class="cm-keyword">mod</span> <span class="cm-def">chicken</span>;
<span class="cm-keyword">mod</span> <span class="cm-def">horse</span>;

<span class="cm-keyword">fn</span> <span class="cm-def">main</span>() {
    ...
}
</pre>

<p>Compiling this file will cause <code>rustc</code> to look for files named <code>cow.rs</code>, <code>chicken.rs</code>, and <code>horse.rs</code> in the same directory as the <code>.rc</code> file, compile them all together, and, based on the presence of the <code>crate_type = &quot;lib&quot;</code> attribute, output a shared library or an executable. (If the line <code>#[crate_type = &quot;lib&quot;];</code> was omitted, <code>rustc</code> would create an executable.)</p>
<p>The <code>#[link(...)]</code> attribute provides meta information about the module, which other crates can use to load the right module. More about that later.</p>
<p>To have a nested directory structure for your source files, you can nest mods:</p>
<pre class="cm-s-default"><span class="cm-keyword">mod</span> <span class="cm-def">poultry</span> {
    <span class="cm-keyword">mod</span> <span class="cm-def">chicken</span>;
    <span class="cm-keyword">mod</span> <span class="cm-def">turkey</span>;
}
</pre>

<p>The compiler will now look for <code>poultry/chicken.rs</code> and <code>poultry/turkey.rs</code>, and export their content in <code>poultry::chicken</code> and <code>poultry::turkey</code>. You can also provide a <code>poultry.rs</code> to add content to the <code>poultry</code> module itself.</p>
<h2 id="using-other-crates"><a href="#using-other-crates"><span class="header-section-number">17.2</span> Using other crates</a></h2>
<p>The <code>extern mod</code> directive lets you use a crate (once it's been compiled into a library) from inside another crate. <code>extern mod</code> can appear at the top of a crate file or at the top of modules. It will cause the compiler to look in the library search path (which you can extend with the <code>-L</code> switch) for a compiled Rust library with the right name, then add a module with that crate's name into the local scope.</p>
<p>For example, <code>extern mod std</code> links the <a href="std/index.html">standard library</a>.</p>
<p>When a comma-separated list of name/value pairs appears after <code>extern mod</code>, the compiler front-end matches these pairs against the attributes provided in the <code>link</code> attribute of the crate file. The front-end will only select this crate for use if the actual pairs match the declared attributes. You can provide a <code>name</code> value to override the name used to search for the crate.</p>
<p>Our example crate declared this set of <code>link</code> attributes:</p>
<pre class="cm-s-default">#[<span class="cm-variable">link</span>(<span class="cm-variable">name</span> = <span class="cm-string">&quot;farm&quot;</span>, <span class="cm-variable">vers</span> = <span class="cm-string">&quot;2.5&quot;</span>, <span class="cm-variable">author</span> = <span class="cm-string">&quot;mjh&quot;</span>)];
</pre>

<p>Which you can then link with any (or all) of the following:</p>
<pre class="cm-s-default"><span class="cm-keyword">extern</span> <span class="cm-keyword">mod</span> <span class="cm-def">farm</span>;
<span class="cm-keyword">extern</span> <span class="cm-keyword">mod</span> <span class="cm-def">my_farm</span> (<span class="cm-variable">name</span> = <span class="cm-string">&quot;farm&quot;</span>, <span class="cm-variable">vers</span> = <span class="cm-string">&quot;2.5&quot;</span>);
<span class="cm-keyword">extern</span> <span class="cm-keyword">mod</span> <span class="cm-def">my_auxiliary_farm</span> (<span class="cm-variable">name</span> = <span class="cm-string">&quot;farm&quot;</span>, <span class="cm-variable">author</span> = <span class="cm-string">&quot;mjh&quot;</span>);
</pre>

<p>If any of the requested metadata do not match, then the crate will not be compiled successfully.</p>
<h2 id="a-minimal-example"><a href="#a-minimal-example"><span class="header-section-number">17.3</span> A minimal example</a></h2>
<p>Now for something that you can actually compile yourself. We have these two files:</p>
<pre class="cm-s-default"><span class="cm-comment">// world.rs</span>
#[<span class="cm-variable">link</span>(<span class="cm-variable">name</span> = <span class="cm-string">&quot;world&quot;</span>, <span class="cm-variable">vers</span> = <span class="cm-string">&quot;1.0&quot;</span>)];
<span class="cm-keyword">pub</span> <span class="cm-keyword">fn</span> <span class="cm-def">explore</span>() -&gt; &amp;<span class="cm-keyword">str</span> { <span class="cm-string">&quot;world&quot;</span> }
</pre>

<pre class="cm-s-default"><span class="cm-comment">// main.rs</span>
<span class="cm-keyword">extern</span> <span class="cm-keyword">mod</span> <span class="cm-def">world</span>;
<span class="cm-keyword">fn</span> <span class="cm-def">main</span>() { <span class="cm-variable-2">io::</span><span class="cm-variable">println</span>(<span class="cm-variable">~</span><span class="cm-string">&quot;hello &quot;</span> + <span class="cm-variable-2">world::</span><span class="cm-variable">explore</span>()); }
</pre>

<p>Now compile and run like this (adjust to your platform if necessary):</p>
<pre class="notrust"><code>&gt; rustc --lib world.rs  # compiles libworld-94839cbfe144198-1.0.so
&gt; rustc main.rs -L .    # compiles main
&gt; ./main
&quot;hello world&quot;</code></pre>
<p>Notice that the library produced contains the version in the filename as well as an inscrutable string of alphanumerics. These are both part of Rust's library versioning scheme. The alphanumerics are a hash representing the crate metadata.</p>
<h2 id="the-core-library"><a href="#the-core-library"><span class="header-section-number">17.4</span> The core library</a></h2>
<p>The Rust core library provides runtime features required by the language, including the task scheduler and memory allocators, as well as library support for Rust built-in types, platform abstractions, and other commonly used features.</p>
<p><a href="core/index.html"><code>core</code></a> includes modules corresponding to each of the integer types, each of the floating point types, the <a href="core/bool.html"><code>bool</code></a> type, <a href="core/tuple.html">tuples</a>, <a href="core/char.html">characters</a>, <a href="core/str.html">strings</a>, <a href="core/vec.html">vectors</a>, <a href="core/managed.html">managed boxes</a>, <a href="core/owned.html">owned boxes</a>, and unsafe and borrowed <a href="core/ptr.html">pointers</a>. Additionally, <code>core</code> provides some pervasive types (<a href="core/option.html"><code>option</code></a> and <a href="core/result.html"><code>result</code></a>), <a href="core/task.html">task</a> creation and <a href="core/comm.html">communication</a> primitives, platform abstractions (<a href="core/os.html"><code>os</code></a> and <a href="core/path.html"><code>path</code></a>), basic I/O abstractions (<a href="core/io.html"><code>io</code></a>), <a href="core/container.html">containers</a> like <a href="core/hashmap.html"><code>hashmap</code></a>, common traits (<a href="core/kinds.html"><code>kinds</code></a>, <a href="core/ops.html"><code>ops</code></a>, <a href="core/cmp.html"><code>cmp</code></a>, <a href="core/num.html"><code>num</code></a>, <a href="core/to_str.html"><code>to_str</code></a>, <a href="core/clone.html"><code>clone</code></a>), and complete bindings to the C standard library (<a href="core/libc.html"><code>libc</code></a>).</p>
<h3 id="core-injection-and-the-rust-prelude"><a href="#core-injection-and-the-rust-prelude"><span class="header-section-number">17.4.1</span> Core injection and the Rust prelude</a></h3>
<p><code>core</code> is imported at the topmost level of every crate by default, as if the first line of each crate was</p>
<pre><code>extern mod core;</code></pre>
<p>This means that the contents of core can be accessed from from any context with the <code>core::</code> path prefix, as in <code>use core::vec</code>, <code>use core::task::spawn</code>, etc.</p>
<p>Additionally, <code>core</code> contains a <code>prelude</code> module that reexports many of the most common core modules, types and traits. The contents of the prelude are imported into every <em>module</em> by default. Implicitly, all modules behave as if they contained the following prologue:</p>
<pre><code>use core::prelude::*;</code></pre>
<h1 id="what-next"><a href="#what-next"><span class="header-section-number">18</span> What next?</a></h1>
<p>Now that you know the essentials, check out any of the additional tutorials on individual topics.</p>
<ul>
<li><a href="tutorial-borrowed-ptr.html">Borrowed pointers</a></li>
<li><a href="tutorial-tasks.html">Tasks and communication</a></li>
<li><a href="tutorial-macros.html">Macros</a></li>
<li><a href="tutorial-ffi.html">The foreign function interface</a></li>
</ul>
<p>There is further documentation on the <a href="https://github.com/mozilla/rust/wiki/Docs">wiki</a>.</p>
</body>
</html>
